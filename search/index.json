[{"content":"前言 当前环境在 Windows，默认了解 C/C++ 编译流程。\n静态库 target 下直接考虑用set_kind(\u0026quot;static\u0026quot;)即可。\n有一个可以注意的地方，可以使用set_policy(\u0026quot;build.merge_archive\u0026quot;, true)来合并所有静态库。（大概是用在分发二进制的时候？）\n动态库 C 考虑到 windows dll 要在函数声明__declspec(dllexport)才能导出接口（当然不止这个方法）。\nxmake 对 C 语言做了支持，不用手动声明，只要在 target 下添加：\nadd_rules(\u0026#34;utils.symbols.export_all\u0026#34;) 如果想要自定义导出的符号，使用utils.symbols.export_list，参考文档\nC++ 众所周知 C++ 的符号比较复杂（毕竟有重载这一大特性），所以 xmake 暂未支持。\n那还是用回上述方案，通常我们定义这样一个宏：\n#ifdef _WIN32 #ifdef LIBRARY_EXPORTS #define LIBRARY_API __declspec(dllexport) #else #define LIBRARY_API // #define LIBRARY_API __declspec(dllimport) #endif #elif #define LIBRARY_API #endif 然后在函数声明加上：\nLIBRARY_API auto read_file(const char* filename) -\u0026gt; std::tuple\u0026lt;std::unique_ptr\u0026lt;char[]\u0026gt;, size_t\u0026gt;; 如果没有修饰函数，即使用了set_kind(\u0026quot;shared\u0026quot;)，当程序调用 dll 里的 api 的时候会直接崩溃。\n然后在库xmake.lua写：\nadd_includedirs(\u0026#34;include\u0026#34;, {public = true}) option(\u0026#34;shared\u0026#34;) set_default(false) set_showmenu(true) set_description(\u0026#34;Enable shared library (default: false)\u0026#34;) option_end() function my_config(target) if has_config(\u0026#34;shared\u0026#34;) then target:set(\u0026#34;kind\u0026#34;, \u0026#34;shared\u0026#34;) if is_plat(\u0026#34;windows\u0026#34;) then target:add(\u0026#34;defines\u0026#34;, \u0026#34;LIBRARY_EXPORTS\u0026#34;) end else target:set(\u0026#34;kind\u0026#34;, \u0026#34;static\u0026#34;) end end target(\u0026#34;add\u0026#34;) add_files(\u0026#34;src/add.cpp\u0026#34;) on_load(my_config) target(\u0026#34;sub\u0026#34;) add_files(\u0026#34;src/sub.cpp\u0026#34;) on_load(my_config) target(\u0026#34;test\u0026#34;) add_files(\u0026#34;src/test.cpp\u0026#34;) add_deps(\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;) if not has_config(\u0026#34;shared\u0026#34;) then set_policy(\u0026#34;build.merge_archive\u0026#34;, true) end on_load(my_config) 使用不同类型的库只要xmake f --shared=true/false就行了。\n","date":"2023-01-04T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/","title":"使用 Xmake 生成静态和动态库"},{"content":"前言 CS149 是一个教并行编程的课程，课程作业使用了 makefile 作为 build system。\n本文通过改造 build system 来讲述一些xmake的使用方法。\n分析 这个课程主要有四个作业，那么是一个多target工程，考虑用多级配置。\n作业里用到了很多工具，xmake都支持这些工具链。不过有些作业不跨平台（只能在 Linux 下运行），所以尽可能地将作业移植到 windows 上。\n改造 完整配置在GitHub上，这里选讲几个部分。\n根目录配置 最小xmake版本。ispc编译在这个版本后支持。 set_xmakever(\u0026#34;2.7.3\u0026#34;) 跨平台首选clang作为 C++ 编译器，在 windows 下使用clang-cl接受 msvc 风格的参数。 在开发环境下，链接动态库可以减少二进制体积，加速链接。 添加宏定义处理一些 windows 的屎。 if is_os(\u0026#34;windows\u0026#34;) then set_toolchains(\u0026#34;clang-cl\u0026#34;) set_runtimes(\u0026#34;MD\u0026#34;) add_defines(\u0026#34;_CRT_SECURE_NO_WARNINGS\u0026#34;, \u0026#34;NOMINMAX\u0026#34;) else set_toolchains(\u0026#34;clang\u0026#34;) end 源码目录配置 考虑到 windows 没有getopt.h，这里在 github 上随便找了一个库代替，并开放头文件权限给依赖此库的target使用。 if is_os(\u0026#34;windows\u0026#34;) then target(\u0026#34;getopt\u0026#34;) set_kind(\u0026#34;static\u0026#34;) add_includedirs(\u0026#34;getopt-for-windows\u0026#34;, {public = true}) add_files(\u0026#34;getopt-for-windows/getopt.c\u0026#34;) end 作业1 作业有多个target，其实可以考虑每个给每个target单独一个配置，不过这里选择把多个target都放在同一个xmake.lua中。\n根据原始 makefile 参数，处理一些跨平台配置。 考虑到作业会生成 ppm 格式的图片，所以改变该target的运行目录。 target(\u0026#34;mandelbrot\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;prog1_mandelbrot_threads/*.cpp\u0026#34;) set_optimize(\u0026#34;fastest\u0026#34;) add_deps(\u0026#34;common\u0026#34;) if is_os(\u0026#34;windows\u0026#34;) then add_deps(\u0026#34;getopt\u0026#34;) elseif is_os(\u0026#34;linux\u0026#34;) then add_syslinks(\u0026#34;m\u0026#34;, \u0026#34;pthread\u0026#34;) end set_rundir(\u0026#34;prog1_mandelbrot_threads\u0026#34;) 这里用到了ispc进行编译，使用xmake的内置规则进行编译。 编译 ispc 文件会生成一个对象文件和头文件，这里通过header_extension配置控制生成头文件的后缀，然后就可以在代码中引用生成的头文件xxx_ispc.h（xxx.ispc）。 由于没有内置的 ispc api，这里使用set_values传递编译参数。 target(\u0026#34;sqrt\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_rules(\u0026#34;utils.ispc\u0026#34;, {header_extension = \u0026#34;_ispc.h\u0026#34;}) add_files(\u0026#34;prog4_sqrt/*.ispc\u0026#34;) add_files(\u0026#34;prog4_sqrt/*.cpp\u0026#34;) add_cxxflags(\u0026#34;-march=native\u0026#34;) set_values(\u0026#34;ispc.flags\u0026#34;, \u0026#34;--target=avx2-i32x8\u0026#34;, \u0026#34;--arch=x86-64\u0026#34;) set_optimize(\u0026#34;fastest\u0026#34;) add_deps(\u0026#34;common\u0026#34;) if is_os(\u0026#34;linux\u0026#34;) then add_syslinks(\u0026#34;m\u0026#34;, \u0026#34;pthread\u0026#34;) end 作业2 本作业两个target的配置相同，可以用一个循环来生成。（常用于生成相同配置的单元测试）\nfor _, part in ipairs({\u0026#34;part_a\u0026#34;, \u0026#34;part_b\u0026#34;}) do target(part) set_kind(\u0026#34;binary\u0026#34;) add_includedirs(part) add_includedirs(\u0026#34;../common\u0026#34;, \u0026#34;tests\u0026#34;) add_files(part .. \u0026#34;/*.cpp\u0026#34;) add_files(\u0026#34;tests/main.cpp\u0026#34;) if is_os(\u0026#34;windows\u0026#34;) then add_deps(\u0026#34;getopt\u0026#34;) elseif is_os(\u0026#34;linux\u0026#34;) then add_syslinks(\u0026#34;m\u0026#34;, \u0026#34;pthread\u0026#34;) end end 作业内置 test，但官方没有提供完成所有测试的脚本（其实直接改源码也可以），不过这里考虑用 xmake 的脚本域来做这件事。 设置一个空目标类型，覆盖内置的on_run，然后使用 xmake 一些内置的 api 运行测试。 target(\u0026#34;part_a_test\u0026#34;) set_kind(\u0026#34;phony\u0026#34;) add_deps(\u0026#34;part_a\u0026#34;) on_run(function () local test_names = { \u0026#34;simple_test_sync\u0026#34;, \u0026#34;ping_pong_equal\u0026#34;, \u0026#34;ping_pong_unequal\u0026#34;, \u0026#34;super_light\u0026#34;, \u0026#34;super_super_light\u0026#34;, \u0026#34;recursive_fibonacci\u0026#34;, \u0026#34;math_operations_in_tight_for_loop\u0026#34;, \u0026#34;math_operations_in_tight_for_loop_fewer_tasks\u0026#34;, \u0026#34;math_operations_in_tight_for_loop_fan_in\u0026#34;, \u0026#34;math_operations_in_tight_for_loop_reduction_tree\u0026#34;, \u0026#34;spin_between_run_calls\u0026#34;, \u0026#34;mandelbrot_chunked\u0026#34;, } for _, value in ipairs(test_names) do -- cprint(\u0026#34;Testing \u0026#34; .. \u0026#34;${bright green}%s\u0026#34;, value) -- os.runv(name, {value}) os.execv(\u0026#34;xmake\u0026#34;, {\u0026#34;run\u0026#34;, \u0026#34;part_a\u0026#34;, value}) end cprint(\u0026#34;${bright red}Pass!\u0026#34;) end) 作业3 xmake 会自动探测 cuda 的目录，如果不在默认的安装目录，设置一下。\nxmake f --cuda=\u0026lt;PATH\u0026gt; xmake 对cuda支持还算完善，直接add_files就能直接编译。 cuda runtime 也有动态库，不过 xmake 默认链接静态库，这里需要手动添加链接动态库的名字。 add_cugencodes(\u0026#34;compute_35\u0026#34;) add_links(\u0026#34;cudart\u0026#34;) target(\u0026#34;render\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;render/*.cpp\u0026#34;) add_files(\u0026#34;render/*.cu\u0026#34;) add_packages(\u0026#34;freeglut\u0026#34;) set_rundir(\u0026#34;render\u0026#34;) 作业4 该作业只能运行在 Linux 平台，因为官方只提供了 Linux 平台的二进制进行链接。\n这里写了一个函数禁用target，然后在on_load时禁用，可以使用其他写法禁用target。 官方提供了一个静态库，但静态库名字前缀不是lib开头，链接器不接受，所以不能直接用add_links function only_linux(target) if target:is_plat(\u0026#34;linux\u0026#34;) then target:set(\u0026#34;enabled\u0026#34;, true) else target:set(\u0026#34;enabled\u0026#34;, false) end end target(\u0026#34;pr\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;pagerank/main.cpp\u0026#34;, \u0026#34;pagerank/page_rank.cpp\u0026#34;) add_linkdirs(\u0026#34;pagerank\u0026#34;) add_ldflags(\u0026#34;-fopenmp\u0026#34;) add_ldflags(\u0026#34;-l:ref_pr.a\u0026#34;, {force = true}) add_deps(\u0026#34;assignment4_common\u0026#34;) on_load(only_linux) 对象文件也可也直接add_files target(\u0026#34;bfs\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;bfs/main.cpp\u0026#34;, \u0026#34;bfs/bfs.cpp\u0026#34;) add_files(\u0026#34;bfs/ref_bfs.o\u0026#34;) add_ldflags(\u0026#34;-fopenmp\u0026#34;) add_deps(\u0026#34;assignment4_common\u0026#34;) on_load(only_linux) ","date":"2022-12-18T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/","title":"使用 Xmake 作为 CS149 作业的 bulild system"},{"content":"前提 目前来说 Rider 还是最好的 UE IDE，本文只是提供多一种选项来写 UE 代码。\n环境 vscode 插件 clangd clang Windows 推荐使用 scoop 下载 clang。\nscoop install llvm 部署 用 vscode 打开 UE 项目目录，新建.vscode目录。\n新建.vscode/settings.json文件，写入下面内容。\n{ \u0026#34;clangd.arguments\u0026#34;: [ \u0026#34;--background-index\u0026#34;, \u0026#34;--compile-commands-dir=.vscode\u0026#34;, // completion \u0026#34;--header-insertion=never\u0026#34;, \u0026#34;--completion-style=bundled\u0026#34;, \u0026#34;--function-arg-placeholders=false\u0026#34;, // effective \u0026#34;--pch-storage=memory\u0026#34;, \u0026#34;-j=16\u0026#34;, // coding \u0026#34;--clang-tidy\u0026#34;, // misc \u0026#34;--log=error\u0026#34; ] } 在项目目录新建.clang-format文件，谷歌一下 UE clang-format，随便找一个复制下来。这里用来格式化代码。\n使用脚本生成反射信息和compile_commands.json\ncompile_commands.json成功生成后，打开 cpp 文件，clangd 就会自动运行。\nUE 的 Unreal Build Tool 可以生成compile_commands.json，需要 clang 辅助。不过 UBT 写的比较奇葩，在命令行直接clang -v有结果，但 UBT 还是找不到，在论坛看了一遍 Linux/Windows 都是这样。\n但 Windows 还是能找到 clang 的，不过需要把 LLVM 工具链放在这里。\nC:/Program Files/LLVM 这里建议弄一个目录软链接，或者直接拷贝过来。不会用 mklink 可以看看这篇文章：比较 Windows 上四种不同的文件（夹）链接方式（NTFS 的硬链接、目录联接、符号链接，和大家熟知的快捷方式） # C:/Program Files/ cmd /c mklink /J LLVM \u0026lt;LLVM_PATH\u0026gt; 然后这里需要一个脚本来调用 UBT，可以考虑用 vscode 内置的 tasks，也可也用 python 等脚本语言，假如要用 vsocde tasks：\n新建文件.vscode/tasks.json 假设 UE 目录在 C:/Program Files/Epic Games/UE_4.27，新建项目名称为demo。\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Gen Generated Code\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Engine/Binaries/DotNET/UnrealBuildTool.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;demoEditor\u0026#34;, // \u0026lt;project name\u0026gt;Editor \u0026#34;Win64\u0026#34;, \u0026#34;DebugGame\u0026#34;, \u0026#34;-SkipBuild\u0026#34;, \u0026#34;-project=${workspaceFolder}/demo.uproject\u0026#34;, \u0026#34;-game\u0026#34;, \u0026#34;-engine\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;C:/Program Files/Epic Games/UE_4.27\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Subtask:GenClangDatabase\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Engine/Binaries/DotNET/UnrealBuildTool.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;demoEditor\u0026#34;, // \u0026lt;project name\u0026gt;Editor \u0026#34;Win64\u0026#34;, \u0026#34;DebugGame\u0026#34;, \u0026#34;-SkipBuild\u0026#34;, \u0026#34;-project=${workspaceFolder}/demo.uproject\u0026#34;, \u0026#34;-game\u0026#34;, \u0026#34;-engine\u0026#34;, \u0026#34;-mode=GenerateClangDatabase\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;C:/Program Files/Epic Games/UE_4.27\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Subtask:MoveCompileCommands\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;move\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-Force\u0026#34;, \u0026#34;compile_commands.json\u0026#34;, \u0026#34;${workspaceFolder}/.vscode\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;C:/Program Files/Epic Games/UE_4.27\u0026#34; } }, { \u0026#34;label\u0026#34;: \u0026#34;Gen Compile Commands\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;Subtask:GenClangDatabase\u0026#34;, \u0026#34;Subtask:MoveCompileCommands\u0026#34; ], \u0026#34;dependsOrder\u0026#34;: \u0026#34;sequence\u0026#34; } ] } Reference Windows 下使用 Vscode + Clangd 搭建 UE4 开发环境 ","date":"2022-11-25T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E7%94%A8-vscode-%E5%86%99-ue-%E4%BB%A3%E7%A0%81/","title":"用 vscode 写 UE 代码"},{"content":"使用 edge，不需要科学上网就能在不同电脑同步插件\n整洁 清理广告 -\u0026gt; AdGuard 移除 cookies 提醒 -\u0026gt; I don\u0026rsquo;t care about cookies 移除 url 跟踪参数 -\u0026gt; ClearURLs 效率 生成目录 -\u0026gt; Smart TOC 浏览网页 -\u0026gt; Vimium C 鼠标悬停链接显示图像/视频 -\u0026gt; Imagus 贴心工具 网页截图 -\u0026gt; Awesome Screenshot 听歌 -\u0026gt; Listen 1 自定义个人主页 -\u0026gt; Custom New Tab URL 破解网页限制复制 -\u0026gt; SuperCopy github 代码文件树 -\u0026gt; Octotree 集成 Aria2 for Edge KeePassXC-Browser v2ex plus Tampermonkey B站增强 -\u0026gt; Bilibili Evolved 移除 url 跟踪参数 -\u0026gt; Bilibili 干净链接 秒传 -\u0026gt; rapidupload-userscript 给片假名显示原词 -\u0026gt; 片假名终结者 知乎增强 贴吧页面精简 护眼模式 ","date":"2022-11-06T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/","title":"浏览器插件"},{"content":"某些 STL 容器 在刷 leetcode，其中某道题中的代码片段是这样的\nstring res; res.resize(size - i); // res.reserve(size - i); for (int j = 0; i \u0026lt; size; i += 1, j += 1) { res[j] = arr[i] + \u0026#39;0\u0026#39;; // res.push_back(arr[i] + \u0026#39;0\u0026#39;); } 没注释的代码比注释的快了几ms，原因如下\n因为容器一开始是空的，不需要考虑拷贝原来的元素\nresize 重新分配内存并且默认初始化，size 改变（大概开销 malloc + memset） reserve 重新分配了内存，不初始化，size 不变 push_back 需要检查 size 有没有大于 capacity，多了分支的开销 然而这里代码也不是最快的，思考一下，这里 resize 还多了一个 memset 的开销，所以最优解应该是，用自己写的 vector（逃\n不知道是历史原因还是标准委员会根本没考虑到，应该加多几个函数来表示需不需要初始化\n改造容器 这里先看一个别人家的 vector：Less\n看一下某个代码片段\nstruct default_init_t {}; inline constexpr default_init_t default_init; struct with_capacity_t {}; inline constexpr with_capacity_t with_capacity; vector(default_init_t, size_type const size) { this-\u0026gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T; }); } vector(size_type size) { this-\u0026gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T(); }); } vector(with_capacity_t, size_type const capacity) { this-\u0026gt;construct(0u, capacity, [](auto, auto) {}); } vector(size_type size, T const\u0026amp; value) { this-\u0026gt;construct(size, size, [\u0026amp;](auto p, auto) { new (p, placement_tag) T(value); }); } 思考🤔，直接把一个结构体类型作为参数？算了直接去 c++ 群问一下\n哦，原来这个叫tag dispatch，才发现这语法在（MSVC STL）到处都是，感觉不如多写个 make 系列函数，而不是重载构造函数\n我觉得更好的实践应该是：\n// 分配内存，size 改变，默认初始化 static vector\u0026lt;T\u0026gt; make_default_init(std::size_t size, const T\u0026amp; val = T{}); // 分配内存，size 改变，不进行初始化 static vector\u0026lt;T\u0026gt; make_default_without_init(std::size_t size); // 分配内存，size 不变，不进行初始化 static vector\u0026lt;T\u0026gt; make_with_capacity(std::size_t size); // 重新分配内存，size 改变，不进行初始化 void resize_without_init(std::size_t size); 这个库还有个设计是，抛弃 std::allocator，使用自定义 new 和 delete\nstd::allocator 这玩意设计有误，扔掉很正常，至于为什么，看这个\n自增运算符 在最上面的代码，里面自增1都是使用+=，这是好的代码风格\n有时候你会看见这种代码：++array[index++]\n前缀/后缀自增运算符赶紧死一死，后出世的语言基本都没有++这个语法了\n更让我觉得恶心的是，群友在 AMD 的笔试说考i+++++i这种题，就算是外企我也想开喷：中国本土化了这是，真接“谭教授”的地气啊\n别说能考你 体系结构/操作系统/编译器 的知识，首先有一个大前提就是，ub 不能拿来做题目\n","date":"2022-09-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx1/","title":"C++ 胡言乱语X1"},{"content":"学vulkan时的笔记（胡言乱语\n前言 渲染需要呈现最终结果，所以和游戏引擎是“耦合”的\n写一个简单的渲染引擎，其实和写一个游戏引擎也没什么区别，因为物理和动画的呈现依赖于渲染\n这里所说的渲染应该不包含各种shader效果，更类似于怎么调图形api\n所以写渲染引擎，本质还是写游戏引擎，那么最终还是要参考游戏引擎的架构\n学vulkan也一样，最终都会写成渲染引擎，所以提前架构一下比较好。这样在使用vulkan tutorial学习时，不局限于单文件恶心自己\n调api渲染的流程 加载数据到cpu/gpu，在gpu描述数据的布局，如何操作数据\n虽然就短短一行字，但拆分下来每一部分都可以讲很多\n资产管理 资产管理，可以简单自定义一个自己的资产文件格式，可以参考vulkan guide\n我的想法是，定义一个最底层的存储格式，如 metadata + data，data 可以使用lz4算法进行压缩\nmetadata 可以是格式版本、data 的大小、是否加密\u0026hellip;\u0026hellip;\n然后又可以自定义一个 texture 和 mesh 的格式，也是 metadata + data 模式，然后把这些打包塞给上面格式的 data 里\n然后我们还需要一个转换器，负责把不同的模型格式（比如obj）转换成我们自定义的格式\n思路理清的话，基本上都是一些工程脏活了，实现难度不大\n待续 等我过一遍 unity 的 urp\n参考 有关图形学入门的一些思考·谈谈Vulkan ","date":"2022-08-08T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84/","title":"渲染引擎的架构"},{"content":"起因 在实现我的离线渲染器中，用到了大量oop（其实就是基类然后继承）\n我有一个Shape基类，里面接口全声明为标准的纯虚函数接口\nvirtual TYPE FUNCTION() const = 0; 当你继承这个类后，继承类必须实现这个接口，不然编译报错\n一开始还没有写实现，但类已经继承了，没办法，在接口开个洞（真难看啊\nvirtual TYPE FUNCTION() const {} 于是我基于 C++20 标准库的source_location写了一个\n[[noreturn]] inline void unimplemented(const std::source_location location = std::source_location::current()) { std::cerr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#39;[\u0026#39; \u0026lt;\u0026lt; location.file_name() \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; location.line() \u0026lt;\u0026lt; \u0026#34;] \u0026#34; \u0026lt;\u0026lt; location.function_name() \u0026lt;\u0026lt; \u0026#34; unimplemented!\\n\u0026#34;; exit(-1); } 还没有实现接口的时候留下unimplemented，然后运行时报错\nsource_location暂时只有clang不支持（clang对C++20支持太慢了\n网上冲浪时看到有人说，接口虚函数实现动态多态是一种糟糕实践，优雅的做法是Existential Type，在C++社区称为sean parent polymorphism\n详细可以看这个视频\nJohn Bandela “Polymorphism != Virtual: Easy, Flexible Runtime Polymorphism Without Inheritance”\nreddit上的关于该视频的讨论\n什么是多态 特定多态 Ad hoc polymorphism\n函数重载，当然运算符重载也一样\n参数化多态 Parametric polymorphism\n类似 C++ 的模板，也可以称为泛型\n子类型多态 Subtyping\n平时编程用的最多的，继承基类，调用相同符号的方法\nExistential Type 中文语境下叫类型擦除/隐藏类型实现（机翻直译叫存在类型）\n看一段 C++ 代码\n#include \u0026lt;functional\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; // type Messenger = ∃ a. { x: a, Print: a -\u0026gt; string -\u0026gt; ⊥ } struct Messenger { using QuantificationBound = auto(std::string_view)-\u0026gt;void; std::function\u0026lt;QuantificationBound\u0026gt; f = {}; Messenger() = default; Messenger(auto x) { f = [=](auto msg) { x.Print(msg); }; } auto Print(auto msg) const { f(msg); } }; struct A { auto Print(auto msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;A says \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; struct B { auto Print(auto msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;B says \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; auto main()-\u0026gt;int { auto x = std::vector\u0026lt;Messenger\u0026gt;{ A{}, B{} }; for (auto y : x) y.Print(\u0026#34;hi\u0026#34;); } 我觉得有点像上面所说的子类型\n在代码中，用std::function封装了真正的调用函数，而不需要考虑具体类型。std::function除了保存函数状态，还有运行时多态。但在不同 stl 的实现，有些是直接用 virtual，有些手动用指针打虚表。虽然看起来底层实现一样，不过好处就是，不需要给类函数加上 virtual，这算是一种解耦\n但用std::function实现其实有一些缺陷，比如将 lambda 函数赋值给它的时候，lambda capture 的变量太多会动态分配内存。比较推荐的是用 template\nReference Existential type 是什么？ 多态都不知道，谈什么对象 关于std function和lambda function的性能调试 ","date":"2022-07-25T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%A4%9A%E6%80%81/","title":"多态"},{"content":"下面的目录不好使，只要小部分能跳转，点右边的目录跳转吧\n我在知乎的点赞其实是当收藏用的， 这么多点赞，打算找时间用爬虫全部爬下来慢慢整理\n数学 物理 信息 计算机理论 软件工程 理论 实践 编程语言 C C++ Rust Haskell 体系结构 编译原理 可视化 优化 高性能计算 计算机图形学 旋转 音视频 逆向 Linux 工具 在线工具 Git Unity 二次元 galgame 资源 在线 生肉 音声 色度学 日语 misc 数学 我在知乎学数学 图形数学方法：FFT（快速傅里叶）的原理讲述 有没有比较好的学习高等数学，线性代数，概率论数理统计的英文书籍推荐？ 物理 Ten Minute Physics 信息 压缩算法lzma2,zstd,rar,brotli,lz4,lizardv1对比推荐 计算机理论 计算复杂度理论基础（一）Preliminaries 软件工程 理论 语义化版本 2.0.0 读《Fundamentals of Software Architechture》 可逆计算：下一代软件构造理论 抽象的幻觉（1） 抽象的幻觉（2） 为什么这么设计系列文章 实践 游戏架构设计——面向数据编程（DOP） 游戏架构设计——高性能并行编程 为什么我认为Rust的Result错误处理方式不如Exception，探讨了Monad和工业界主流的异常处理两种错误处理的差异 游戏编程模式 阿里云块存储团队软件工程实践 Chromium 渲染流水线——字节码到像素的一生 A development process startup founders should use to ship features weirdly fast 编程语言 C 现代化 C 使用体验 The different ways to handle errors in C C Isn\u0026rsquo;t A Programming Language Anymore C++ 单例模式 简单的 C++ 结构体字段反射 make a shared_ptr from scratch C++ 系列专题 Changing std::sort at Google’s Scale and Beyond 最好的C++学习教程(上篇)——The Cherno CppSeries 最好的C++学习教程(下篇)——The Cherno CppSeries More C++ Idioms Learn Modern C++ 现代化工具链在大规模 C++ 项目中的技术实践 Understanding the different flavors of Clang C and C++ compilers in Windows，讲述了C++ 不同编译工具链的差异 从无栈协程到C++异步框架 Rust 文組也能懂的 Rust async 機制 Rust Language Cheat Sheet Haskell Learn Haskell by building a blog generator 体系结构 与程序员相关的CPU缓存知识 深入理解CPU cache：组织、一致性（同步）、编程 深入GPU硬件架构及运行机制 如何设计内存池？ - 韦易笑的回答 - 知乎，内存管理是最能体现体系结构知识的地方之一 Microarchitecture cheat sheet When an instruction depends on the previous instruction depends on the previous instructions… : long instruction dependency chains and performance 编译原理 【科普】编译器的构建基本原理 Programming Language Documentations 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 可视化 浮点数可视化 正则表达式可视化 马尔科夫链可视化 四元数可视化 数据结构可视化 优化 浮点数计算优化 vfixupimm: signum，用 AVX 优化取浮点数符号 When an instruction depends on the previous instruction depends on the previous instructions… : long instruction dependency chains and performance，CPU 指令依赖链太长拖慢速度，但依赖链解决不了，只能交叉两个依赖链提高效率 高性能计算 高性能计算学习路线 从零开始的C/C++高性能编程指南 C++ 高性能编程实战系列（1） C++ 高性能编程实战系列（2） C++ 高性能编程实战系列（3） CMU15418 并行计算机架构与编程 计算机图形学 使用有理数进行渲染 如何验证BXDF 实时\u0026amp;离线皮肤渲染技术（Real-time \u0026amp; Offline Skin Rendering） Enterprise PBR Shading Model 多种几何体求交 How to build a BVH 旋转 可视化和公式推导 音视频 FFmpeg原理 FFmpeg5开发入门系列索引 逆向 这里我推荐 CSAPP Lab2-Bomb Lab\n[原创] 逆向并提取QQ截图\u0026ndash;OCR和其他功能 Linux Linux 101 archlinux 简明指南 一张图理解Linux文件权限 解释 shell 参数 Delightful io_uring packages and resources 工具 在线工具 知春在线工具箱 つつの工具箱 在线Ping/测速等 Git 在使用 git 时的一些尴尬场景里的修复方案 Git Command Explorer(git速查表) Unity Catlike Coding unity tutorials Unity SRP下做PBR基于物理的渲染和踩坑（一） 二次元 galgame galgame常用名词中日对照小辞典 混沌之子 CHAOS;CHILD LOVE chu chu!! 资源 VCB-Studio，专门修复动漫画质\n次元图书馆，galgame资源多，od盘下载\n琉璃神社(无注册要求)\n量子ACG(无注册要求，主要是游戏)\n萌次元(无法注册，资源社区)\nZodgame(注册已关闭，论坛)\n最ACG(无注册要求，资源社区)\nACEACG(在线本子漫画)\n紳士会所(无注册，资源社区)\nUZXun社区(无注册要求，资源论坛)\n紳士漫畫(无注册，在线本子漫画)\n松鼠症倉庫(无注册要求，在线本子漫画)\n梦璃(无注册要求，资源社区）\n布璃(无注册要求，声音资源社区)\n资源统筹局(答题注册获取邀请码，资源社区)\n次元计划(资源社区)\n梦幻之乡(无注册要求，资源社区)\n心動漫(答题注册邀请码，资源转载)\nsaber酱的抱枕(个人资源博客)\n暗萌(无注册要求，资源社区)\n灵梦御所(个人资源博客，官方有社区软件)\n初音社(无注册要求，资源社区)\n绅士茶馆(资源社区，无注册)\n扶她404(资源社区，无注册要求)\n绅士咖啡厅(资源论坛，注册邀请码获取)\n在线 bimi动漫 异世界动漫 生肉 https://www.ggbases.com https://sukebei.nyaa.si http://www.anime-sharing.com https://bbs4.2djgame.net 绯月 幽隐恋梦 音声 ASMR Online eat ASMR 色度学 色彩空间基础 色彩空间表示与转换 光谱渲染的几个例子 色温、白平衡与色彩恒常性 色彩科学学习笔记：专栏自述、目录 日语 日语学习网站\n時雨の町 duolingo LingQ 日语语法指南 misc GNU工具实现解密 漫画数据化——计算机科学在漫画领域的相关研究简介 整理记录各个包管理器，系统镜像，以及常用软件的好用镜像 图解Functor和Monad GitHub开源项目维护指南 在线矩阵计算 三维重建\u0026amp;点云处理\u0026amp;图形渲染\u0026amp;网格处理\u0026amp;游戏开发 （可能是）全网最好用的 HDR 术语速查手册 凤凰架构 构建可靠的大型分布式系统 汉语反向词典，查近义词 Lights and Shadows Quick Reference，针对开发人员的速查表 Practical Deep Learning ","date":"2022-07-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%94%B6%E8%97%8F%E5%A4%B9%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB/","title":"收藏夹（知识分类）"},{"content":"技术书看新不看旧\n计算机科学 人月神话 黑客与画家 敏捷软件开发 代码整洁之道 程序员的自我修养 : 链接、装载与库 七周七语言 代码本色 x86汇编语言 : 从实模式到保护模式 深入理解计算机系统 Head First设计模式 编程语言 C C Primer Plus C++ C++ Primer C++ Primer PLus Effective C++ More Effective C++ Effective Modern C++ C++ Best Practices: 45ish Simple Rules with Specific Action Items for Better C++ C++性能优化指南 C++并发编程实战 Rust 深入浅出Rust Rust程序设计语言 Python Python编程 从入门到实践 Haskell Haskell趣学指南 Haskell函数式编程入门 数据结构与算法 大话数据结构 算法导论 计算机体系结构 计算机组成与设计：硬件/软件接口 计算机系统要素 : 从零开始构建现代计算机 编码 : 隐匿在计算机软硬件背后的语言 操作系统 一个64位操作系统的设计与实现 Linux内核设计与实现 现代操作系统 现代操作系统：原理与实现 计算机网络 计算机网络自顶向下方法 TCP/IP详解 卷1：协议 图解HTTP 计算机图形学 Fundamentals of Computer Graphics Ray Tracing Gems series 全局光照技术 实时渲染 Real-Time Rendering 离线渲染 The Ray Tracer Challenge Ray Tracing in One Weekend series Advanced Global Illumination Physically Based Rendering: From Theory to Implementation 数学 线性代数的几何 线性代数及其应用 漫画线性代数 数值分析 从博弈问题到方法论学科 物理 现代光学基础 光学原理 游戏 游戏编程模式 游戏引擎架构 游戏设计艺术 日语 新版中日交流标准日本语初级 音乐 超简单的乐理学习图解版 认识乐理：视唱练耳同步学 杂书 视觉艺术用光 色彩与光线 写实主义绘画指南 我的二本学生 信息简史 信息论基础 信号与系统 ","date":"2022-07-05T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95%E4%B8%8B%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B9%A6%E5%90%A7/","title":"随便记录下看过的书吧"},{"content":"最近超星学习通数据泄露大家应该都知道吧，全国上下学生很多都依赖这么一个中心化的网课平台。而且学习通可能还是明文存储密码，这下坏事了，直接撞库\n撞库攻击是网络犯罪分子试图使用一组帐密同时访问多个帐户\n我很久以前就知道有密码管理器的存在，但我是懒鬼，所以没弄过。这次事件提醒了我，还是别偷懒了（\nGetting started KeePass是什么呢\nKeePass is an encrypted password database format. It is an alternative to online password managers and is supported on all major platforms.\n我这里推荐使用跨平台的KeePassXC客户端，原始KeePass客户端实在太丑陋了\n下载客户端后，新建数据库需要一个主密码，这个密码需要你记忆\n我们先来看一个图，来自xkcd 那如何根据上图思路创建一个好密码呢，这里可以看一下diceware的方法\n这个网站根据diceware方法提供在线生成随机英语单词\n如果想要生成随机中文词语，可以在此网页找到 使用diceware构造好的密码\n创建好数据库后，保存在本地随便一个目录，然后我们去KeePassXC设置面板开启浏览器集成，下载对应浏览器插件\n浏览器插件启动后需要连接KeePassXC客户端\n在网站登录页面，如果数据库里没有对应网站url或者已存在，会提示你为该网站新建/更新账号密码。如果没有提示，可以手动使用插件，或者直接在KeePassXC客户端手动录入\nKeePassXC里随手就可以生成一个密码，无论是大小写字母数字还是各种特殊符号。如果想使用密码，Ctrl-C会自动复制到你剪切板上，然后在10秒后清除\n如果手机也要密码管理，安卓客户端可以在f-droid上下载keepassdx\n同步 所有信息都在keepass创建的数据库里，这里可以使用一些文件传输软件进行备份同步，或者存github也没啥问题\n","date":"2022-06-27T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8keepass%E4%BD%9C%E4%B8%BA%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/","title":"使用KeePass作为密码管理器"},{"content":"也可以是C++小项目的配置\n开发环境构建 vscode+xmake+clang+clangd\n如果在配置过程中有问题，可以先看一下文末的FQA\nC++编译工具链 Visual Studio 2022 clang 构建系统 xmake\nVulkan SDK https://www.lunarg.com/vulkan-sdk/\n假装IDE的文本编辑器 Visual Studio Code\n安装插件\nclangd XMake Getting started 上面列出来的工具下载完成后，新建一个目录，在目录下新建xmake.lua，写入下面内容\nset_project(\u0026#34;vulkan\u0026#34;) set_arch(\u0026#34;x64\u0026#34;) set_warnings(\u0026#34;all\u0026#34;) set_languages(\u0026#34;c++20\u0026#34;) set_toolchains(\u0026#34;clang\u0026#34;) add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.releasedbg\u0026#34;, \u0026#34;mode.release\u0026#34;, \u0026#34;mode.minsizerel\u0026#34;) add_requires(\u0026#34;vulkansdk\u0026#34;, \u0026#34;glfw\u0026#34;, \u0026#34;glm\u0026#34;) target(\u0026#34;main\u0026#34;) set_default(true) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;src/main.cpp\u0026#34;) add_packages(\u0026#34;vulkansdk\u0026#34;, \u0026#34;glfw\u0026#34;, \u0026#34;glm\u0026#34;) 依赖的 vulkansdk 在上面已经下载，如果用他的 installer 安装会自动设置环境变量，xmake 会根据环境变量自动探测编译器、vulkansdk 的正确位置，glm 和 glfw 由 xmake 的包管理处理\n编译 测试代码来自vulkan tutorial\n直接新建一个main.cpp，把代码复制下来\n一切配置好后，可以测试一下了\nxmake xmake run 出现窗口代表环境配置成功\nIntellisense xmake会在.vscode目录自动生成compile_commands.json\n所以我们在.vscode/settings.json给clangd加上参数\n{ \u0026#34;clangd.arguments\u0026#34;: [ \u0026#34;--compile-commands-dir=.vscode\u0026#34;, \u0026#34;--header-insertion=never\u0026#34;, \u0026#34;--completion-style=detailed\u0026#34; ] } FQA Q: xmake下载包失败怎么办\nA: 查看文档使用远程包 - xmake\nQ: 编译失败怎么办\nA: 执行xmake -v，查看详细输出信息\nQ: 我想用vs写代码怎么办\nA: 执行xmake project -k vsxmake -m \u0026quot;debug,release\u0026quot;生成vs工程文件\n","date":"2022-06-20T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%9C%A8-windows-%E4%B8%8A%E4%BD%BF%E7%94%A8-xmake-%E9%85%8D%E7%BD%AE-vulkan-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","title":"在 Windows 上使用 Xmake 配置 Vulkan 开发环境"},{"content":"图形笑话三则 来点图程破防乐子 无内鬼，来点图形笑话 再来点图程破防乐子 免费渲染模型 McGuire Computer Graphics Archive Rendering Resources 博客 A GRAPHICS GUY\u0026rsquo;S NOTE Computer Graphics IQ YangWC\u0026rsquo;s Blog AirGuanZ 《高级计算机图形学——真实感图像合成》目录及序言 OEOTYAN 课程 CS 87/287 | RENDERING ALGORITHMS UCSD CSE 272: Advanced Image Synthesis Advanced Graphics CSE 168 Computer Graphics II: Rendering CIS 565 GPU Programming and Architecture Fall 2022 各种效果 光谱 Simple Spectral Spectral Ray Tracing 天空 The Sky Dome Appearance Project 彩虹 Physically-based simulation of rainbows 动物毛发 An Efficient and Practical Near and Far Field Fur Reflectance Model 肥皂泡 Chemomechanical Simulation of Soap Film Flow on Spherical Bubbles FQA （其实就是把群友讨论结果收藏一下\n知乎上的常见问题 如何在离线渲染（路径追踪）中实现IBL？ 光线追踪中的透视畸变如何矫正？ 在通常渲染中的漫反射项，究竟是属于反射还是折射？ 如何将Surface Area Heuristic(表面面积启发式)运用到BVH的构建中？ 路径追踪光源重要性采样中为什么要每次均匀选取一个光源？ 微表面模型中几何项使用H还是N 在离线里面，一般用general smith，不需要用到H或者N的，就无所谓了。\n虚幻第一次把G=G1G1带到引擎，也是根据egsr07来的，egsr07用的就是H，但到虚幻那就突然变成N了。这也是有原因的，虚幻把Schlick G当做G1，而不是用对应D项的G1,而Schlick G的确是根据N来的。\n然后heitz后面提出了joint G，heitz的paper里面当然用的H而不是N，但是，虚幻看之前非joint g的代码用的N，就copy过来了，所以现在虚幻的joint g也是用的N。\n不知为啥，unity也用的N，好像大家都用N。\n什么是漫反射 先分类\n有无折射率突变的表面 表面是否完全光滑 透射距离与观察距离的比值大小 漫反射到底是什么呢，是材质中参与介质的部分，且特指材质中透射距离非常短的部分 这个距离不是固定短的，它跟你视角观察的距离是相关的，你拿个头发看着跟实心的似得，你拿近看会发现光线还能传过去，当可透射距离小于屏幕上一个像素，那就是漫反射了。它是不是模拟微表面多重散射用的？完全不是。\n","date":"2022-05-30T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E8%BF%9B%E9%98%B6/","title":"渲染进阶"},{"content":"随手记录的一些编译原理笔记。\n现代编译器分为前后端，为了进一步降低复杂度(模块化)，前端的流程通常是：\n词法分析 -\u0026gt; 语法分析 -\u0026gt; 语义分析 上一步的输出是下一步的输入。\n词法分析 常见的应用有正则表达式。\n先定义一个映射， tokens = map(字符串)\n这个token是啥呢，比如说我有下面这个算式：\n1 + 2 * ３ 解析后：\n值 类型 １ 整数 + 加号 2 整数 * 乘号 3 整数 我们暂时不知道有什么用，但现在我们解决了字符串里的空格，如果字符串里有奇怪的字符，比如#啥的，也可以报错。\n怎么解析其实也是个大问题，通常用自动机解决这个问题。\n语法分析 把词法分析输出的一堆token，组合成句子，检查句子的语法，最后生成抽象语法树(AST)\nAST用处广泛，比如：\n编辑器错误提示 代码格式化 代码高亮 代码自动补全 ","date":"2022-05-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A8%8B%E5%BA%8F/","title":"从代码到程序"},{"content":"Windows10 提高游戏分辨率 -\u0026gt; Magpie\n统计游戏时长兼启动器 -\u0026gt; Etupirka\n用手柄玩galgame -\u0026gt; Steam Controller\n现在你获得了一个很好的体验，启动Etupirka，然后选中想玩的galgame，绑定Magpie的快捷键到手柄上，对游戏全屏，我一个Quick load，可以继续用手柄摇杆推线咯\nLinux 一个坏消息，大部分黄油开发者根本没想过Linux平台\n一个好消息，steam的Proton可以帮助我们玩到Windows上的galgame(感谢V社)\n首先在Linux上下载steam，然后添加非steam游戏，游戏设置使用Proton，然后你就可以启动游戏啦\n但实际上只有少部分黄油能打开，就算能打开还一定会伴随bug\n能打开的游戏没见过能播放op 传言有些游戏要对应Proton版本才能打开 游戏能打开，但bug太致命完全打不了 我超，汉化补丁能打开生肉却打不开，但我想全都要怎么办 游戏打不开怎么办，乱试一下吧\n游戏路径全ascii且不留空格(游戏目录也算路径) 参考这篇文章 能用Proton直接打开基本无bug游玩是最好的，如果要折腾很久才能玩我觉得真的没必要，不如用回Windows或者虚拟机(两台以上电脑是Linux用户的最优解)\n先列个能打开的黄油名单在这吧，排排坑\n名字 Pronton版本 体验 放課後シンデレラ 7.0 非常好，没遇到坑 はつゆきさくら 7.0 播放序章op闪退了一次，再打开会提示你要不要播放op，能流畅游玩 いきなりサキュバス ～いちゃらぶ搾精ライフ～ 7.0 没完整打完，暂时无bug 白昼夢の青写真 7.0 黑屏bug，如果不是一直渲染的画面就会黑屏，比如显示文字的时候，文字外的全黑 有群友推荐lutris和proton-ge，还未研究\n","date":"2022-05-09T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E5%92%8Cwindows%E4%B8%8A%E4%BC%98%E9%9B%85%E5%9C%B0%E7%8E%A9galgame/","title":"如何在Linux和Windows上优雅地玩galgame"},{"content":"录播：Chinagraph2020\n论文推荐 真实感图形渲染科研入门笔记（一）：论文推荐\n工具链与参考资料 真实感图形渲染科研入门笔记（二）：工具链与参考资料\n迈向科研的训练 离线 用Intel的Embree写一个光线追踪器 使用多重重要性采样 支持微表面材质 实现一个正确的BDPT 95%做渲染的科研人员都没写对BDPT(太难了)\n检验：和PT的结果比较\n实时 用C++封装OpenGL 支持arcball(能用鼠标拖拽的一个球，里面的物体一起动起来)，写一个VSSM 使用Optix和OpenGL实现RTRT 使用SVGF降噪 未来 材质外观的研究才刚刚开始\n现在用的基本这两种\ndiffuse + microfacet 迪士尼原则BRDF 尽管实现很简单，但第一种对真实感渲染错的离谱\n人脸的渲染也没有好的正向模型\n","date":"2022-05-04T00:00:00Z","permalink":"https://star-hengxing.github.io/p/chinagraph2020%E4%BC%9A%E5%89%8D%E8%AF%BE%E7%A8%8B-%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%A7%91%E7%A0%94%E5%85%A5%E9%97%A8-%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95/","title":"Chinagraph2020会前课程 真实感图形渲染科研入门 随手记录"},{"content":"当发现了一个好软件，但aur上没有人打包，这很难受，所以不如自己来为社区做贡献\n这次我打的包是一个appimage，理所当然去参考一些现有的appimage打包PKGBUILD\n所以先设计再编码\nPKGBULID编写 下载最新版本的软件到本地 提取appimage，把软件icon放到/usr/share/icons 制作Desktop Entry，放到/usr/share/applications 最后将软件去掉版本号，安装到常见目录（我选择了放在/opt/appimages） 是不是看起来很简单，但由于不熟悉linux和一些常用工具，一顿操作下来，花了半天才写好PKGBUILD。\n首先是学会用sed，因为appimage里自带了一个Desktop Entry，所以要进行修改。\n其次就是安装到目录的时候需要给权限目录权限，不然复制不进去。\n当上游的包没有checksum的时候，还要自己download到本地生成然后加上PKGBULID。当然makepkg然后给了个便利的命令。\n# 如果有上一个版本的checksum,先用sed删除再执行该命令 sed -i \u0026#34;$d\u0026#34; PKGBULID makepkg -g \u0026gt;\u0026gt; PKGBULID 测试 写好PKGBULID，检查能不能用。\n# 检查PKGBUILD格式 namcap PKGBUILD # 生成包 makepkg -s # 检查包是否缺少依赖等等 namcap xxx.pkg.tar.zst 检查包的时候我弹了许多报错，不知道怎么修。然后我去用namcap检查一下我参考的那个appimage包，好家伙，他的报错跟我一样。既然他没修那我也就算了吧。\n然后尝试安装\n# 生成.SRCINFO给aur仓库的页面展示，如果第一次提交没有生成，aur仓库会拒绝你的包 makepkg -i \u0026amp;\u0026amp; makepkg --printsrcinfo \u0026gt; .SRCINFO 上传 如果一切没问题，那就可以用git上传aur了（需要一个aur帐号）。\n如果会基本的git操作，下面应该都明白怎么操作。\n# 为aur创建ssh key touch ~/.ssh/config # 写入这些 Host aur.archlinux.org IdentityFile ~/.ssh/aur User aur # 生成 ssh-keygen -f ~/.ssh/aur # 首先创建一个aur项目 git clone ssh://aur@aur.archlinux.org/\u0026lt;你的包名字\u0026gt;.git git add PKGBUILD .SRCINFO git commit -m \u0026#34;init v1.x.x\u0026#34; git push 成功之后呢，你就可以尝试用paru/yay来下载了。\nReference Arch Linux 第一次打包就上手\n","date":"2022-03-02T10:03:35+08:00","permalink":"https://star-hengxing.github.io/p/aur%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95/","title":"AUR打包记录"},{"content":"至今看过最棒的关于基础色彩理论的视频\n常识 红色和黄色可以变成橙色;黄色和蓝色变成绿色;而蓝色和红色变成紫色。如果我们将这些颜色混合在一起，我们得到更多的色调，如红橙色和黄绿色。总之，它们形成了所谓的色轮。 色调是最简单的，它基本上就是我们所说的“颜色”。 饱和度是指强度，换句话说，颜色是否重叠更微妙，或者更具活力。 色值与深浅的颜色相关，从黑到白。 专业配色方案 最简单的方法是单色因为它仅使用一个颜色或色调，选择在色轮上挑选一个点，并使用饱和度和色值的知识，能够保证匹配。 相似色搭配是使用色轮中彼此相邻的色彩样式，如红色和橙色、蓝色和绿色······ 互补色彼此相对，例如，蓝色和橙色\u0026hellip;或经典的红色和绿色。为了避免互补配色方案过于简单化可以增加更轻，更深，或者一些不同饱和度的颜色。 分裂互补配色方案使用的相对颜色的双重配色，能够提升对比之外，更有趣的结果。 三元配色方案采用三种均匀分布的颜色，在色轮上形成一个完美的三角形。这些组合的效果醒目，特别是与主色或辅色的运用。 四元色搭配在色轮上形成了一个矩形，可以通过将其中的一个颜色用于主色，其余为辅色。 解决方法 色彩扎眼——选择一种颜色，并尝试调整其亮度，暗度或饱和度。 色彩过多——也许一点点色彩就可以满足你的画面需要。 色不平衡——中性颜色，如黑色，白色和灰色可以帮助您平衡画面。 实际经验 每种颜色都会发出一个信息。考虑到项目的色调，并选择一个合理的配色方案。 明亮的颜色往往能够带来有趣或现代感的效果。 低饱和度的色彩搭配经常会受到商业公司的喜爱。 你可以在各种有趣的地方找到配色方案，比如某些广告、艺术品、配色网站、周围世界，颜色无处不在。 ","date":"2022-02-07T15:25:20+08:00","permalink":"https://star-hengxing.github.io/p/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"色彩搭配的基础知识"},{"content":"重新排版了一下\n出处： 御宅族与ChaosChild症候群 - 历久弥新的文章 - 知乎 https://zhuanlan.zhihu.com/p/44592537\n御宅族已死。\n\u0026ndash;冈田斗司夫 真正的御宅族如今是否已经消亡了？我没有相关的数据情报，所以无法作出回答。然而，在我的臆测中，真正的御宅族还存在着，但不过只是很少的一部分，并且这部分人中并没有关联。 所以，在新世代宅的急速涌入下不断被稀释着。\n我也自认为真正的御宅族，然而在我全通了CHAOS;CHILD后，发觉我也不过是“ChaosChild症候群”的一员罢了。\n逃避性 无论是真正御宅族们，还是新世代的御宅族们，虽然是不同的个体，但是却进行着妄想同步。得益于网络的普及，御宅们把本我至于同一个巨大的名为御宅文化的妄想之中（网络未普及之前已经开始，不过那时候只是小型的妄想体，朋友、学校的讨论，电视活动之类）。 美好的妄想，它与严酷的现实有着天壤之别，为了生存不得不经历人世，但是，本我还有御宅文化这个桃花源，经过学习、工作的洗礼后，坐到电脑或是沙发前，打开动画亦或是游戏，全身心的投入。\n大部分的人玩游戏的时候有个特点，对于外界置若罔闻，仿佛所有感官都集中在了游戏上，而这在做其他事情的时候是很少出现的，而且并不是可以人为控制的现象。 全身心的投入妄想之中，大脑分泌刺激性神经递质，所有其他事情烦恼都被抛在脑后，此时，仿佛就是游戏中的人物。 放松，就像是在逃避，而这并没有错，我们无时无刻不想着逃避，而超我却告诉我们不行，现在并不是共产主义社会。最后，我们只得在苦劳与逃避之间无限循环。\n有的人为自己创造虚伪的现实妄想，沉溺其中，彻底的利己主义，而这你又得到了什么呢？也许你可能得到你想要的，而这个世界却更加崩坏。当然，利己主义者不会考虑这些，只会考虑自己能否享乐。\n优越性 宅文化的一些特性加上事件误导，使得它天生作为一种非主流道德亚文化，被一般人所不适，因为历史原因在我国更是如此。\n所以宅这个ChaosChild症候群群体，天生是活在一个被一般人所蔑视的妄想中，因主流文化使得宅文化变成了自卑性的妄想，而对此宅们当然要作出应激反应。 以前，所谓的真正御宅族，用各式各样，各个门类的创作证明着自身的能力性，并与社会相关联，这样，不仅在宅圈收获了虚荣并且证明给社会人自己比他们还要强。 如果是什么都不会且自控力低下不去学的人，通常情况类似宫代拓留，自诩为情报强者，在宅圈混迹获得大量情报，自以为看透了世界的真实，看不起周围的普通人，甚至包括父母，认为他们的情报量太少，包括我也是此类。\n你们这些人天天就是看这些无脑电视剧，追星，看着无聊的花边新闻，全是萌二的B站，一遍遍刷着全是垃圾信息的微博，呵，这个人还在煞有其事地看知乎啊，知乎早就和微博没区别了，哈哈，你们这些情报弱者。\n而我不同，我刚通了CHAOS；CHILD，你们这些人一辈子也接触不到这个神作吧，呵呵，通过这个游戏，我知道了……而你们就这样浑浑噩噩地活着吧，我早已看穿一切。\n而新世代宅更加常用的是自嘲的手法，死宅真恶心、肥宅快乐……在疯狂地传播下无形间降低这些词的伤害力，并成为一种调侃娱乐。 真是可笑的手法呢，本身含着自卑的群体夺取外部人的武器抢先自行使用，而造成外部人无枪可打，同时加深内部的归属感使原本那些刺耳的话也只成为了笑料……\n我与宫代拓留有着许多相似之处，不健全的家庭环境，把自己放入妄想中，吸收大量情报，在学校，身为班级下层的我却看不起班级上层的学生，找的理由和宫代差不多，进入工作后依然是如此状态，在公司，交际能力极差导致也没有人愿意主动交谈，每天中午在食堂都是一个人吃午餐，而我，却觉得这样很轻松。\n看着周围有说有笑的人们，情报强者这个武器还真是好用呢，每天使用它来填补自己的自尊心，回到家再次沉溺在妄想之中。\n矛盾性 几个人的御宅妄想无法抵抗这个社会的压力与反对，而一大群人妄想就可以做到。作为这个妄想的每个终端，每个人把自己置于其中就可以感受到整体的包容，从而抵抗外部的侵犯。 回到家，打开电脑，进入一些网站或者社交软件，看着御宅相关的东西，购买周边，放置手办，感觉安心了，此刻，我作为子体感受到了母体的包容性。即使外面的人反对御宅文化本身，因为这个妄想内部人的数量足够庞大，个体也不会慌乱，因为我们人数众多。 矛盾的是，作为处于同一个妄想下的我们，也如One World Order实验一样，自个划分起阶级。我们共同构建起名为御宅文化的妄想，然后并不是同伴，我们只是都在汲取它而已。 具体表现之一，讽刺B站，看不惯B站小学生，认为B站已经变质，却还总是上B站。其原因在于只有B站能提供足够的妄想力。 其实所谓的真正御宅也在享受着新世代宅的恩惠，新世代宅的急流涌入增大着妄想圈，不过这样也伴随着大量的副作用。这些副作用改变了御宅妄想的形态，与真正御宅一直一来所容纳自己的妄想形态产生了变异，真正御宅因妄想的变异而发生不适，所以必须要嘲讽新世代来缓解。 并且，嘲讽新世代宅还能使用优越感这个武器填补自己的自尊心。 御宅妄想的变异越严重，对于真正御宅的压力就愈发高涨，这种压力会转变为各种行为，但这些行为基本脱离不了对于新世代御宅的嘲讽与虚荣，并且企图能有另外一些真正御宅，不，不管什么人，只要能回复支持自己就行了，这样妄想不同步产生的压力就能减轻。\n而御宅文化妄想的变异是不可逆的，如今只有两种选择：\n适应不断变化的妄想，仍然沉溺其中。 脱离妄想。 而这点不只是本人的抉择，而是和每个人的经历相关，有时候轮不到你自由选择，生活会主动帮你进行选择。\n一般来说，第二种选择脱离妄想符合绝大部分人的现实情况，也符合社会主流文化的诉求，被社会所绑架的所有人也会觉得这是合理的，应该的，是一种必经阶段。\n而我可能不会这样，如同沉迷游戏的孩子不是教训孩子而是需要从家庭与父母入手解决一样，我明白我作出这样的选择是因为我家庭的不健全所导致的，并没有、也无法像正常家庭的孩子一般，按流程走人生，所以我可能会一直停留在妄想之中。\n哪个选项比较好？从社会来说，必然是第二种：\n第一种选项意味着逃避、自卑、矛盾。而第二种意味着面对、自信、成长。\n这是对于社会人来说，显而易见的答案。\n我难道不明白吗？怎么可能？但是我为什么不选第二种，是因为懦弱？逃避？也许是这样吧。\n但是我啊，总是有一种感觉，选了第二种答案就会失去一些什么……\n你们会如何选择呢？\n","date":"2022-02-07T13:08:04+08:00","permalink":"https://star-hengxing.github.io/p/%E5%BE%A1%E5%AE%85%E6%97%8F%E4%B8%8Echaoschild%E7%97%87%E5%80%99%E7%BE%A4/","title":"御宅族与ChaosChild症候群"},{"content":"Enable ARK: Survival Evolved Events -activeevent=EventName List of ARK Events Active event Command Love Evolved -activeevent=vday Eggcelect Adventure -activeevent=Easter Anniversary -activeevent=birthday Summer Bash -activeevent=Summer Fear Evolved -activeevent=FearEvolved Turkey Trial -activeevent=TurkeyTrial Winter Wonderland -activeevent=WinterWonderland ","date":"2022-02-04T13:33:27+08:00","permalink":"https://star-hengxing.github.io/p/ark-survival-evolved-%E5%BC%80%E5%90%AF%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/","title":"ARK Survival Evolved 开启活动的命令行参数"},{"content":"务必以下三连\n大変申し訳ございません 突然フォローで失礼ですが この度は,大変ご迷惑をおかけして誠に申し訳ございませんでした。ご無礼のありました段、重ねて謹んでお詫び申し上げます。今後このようなことのありませんよう誠心誠意努力して参りますので、これからもご贔屓賜りますよう重ねて宜しくお願い申し上げます ","date":"2022-01-30T14:26:50+08:00","permalink":"https://star-hengxing.github.io/p/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%92%8C%E6%97%A5%E6%9C%AC%E4%BA%BA%E4%BA%A4%E6%B5%81/","title":"当你第一次和日本人交流"},{"content":"音程（Interval） 两个音高不同的音在一起会形成音程。一个音到下一个相邻的音的距离叫二度（second）。如果距离是半音，音程叫小二度（m2）；全音就叫大二度（M2）\n单位度作为音程的冲量单位\n旋律（Melodic） -\u0026gt; 两个音一前一后发声\n和声（Harmonic） -\u0026gt; 多个音同时发声\n和弦（chord） 同时发声的音 \u0026gt;= 3 就叫和弦\nReference 精通乐理不是梦：超简单的乐理学习图解版 认识乐理：视唱练耳同步学 ","date":"2022-01-30T11:25:23+08:00","permalink":"https://star-hengxing.github.io/p/%E9%9A%8F%E6%89%8B%E8%AE%B0%E7%9A%84%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86/","title":"随手记的乐理知识"},{"content":"Run cd /path/to/AppImage chmod +x xxx.AppImage ./xxx.AppImage Extra icon ./xxx.AppImage --appimage-extract Desktop Entry For example:\n[Desktop Entry] Version=1.0 Type=Application Name=xxx Comment=A cross platform comic client. Exec=/home/\u0026lt;user\u0026gt;/Desktop/AppImages/xxx.AppImage Icon=/home/\u0026lt;user\u0026gt;/Desktop/AppImages/icons/xxx.png Terminal=false tags=Game X-AppImage-Version=1.0.0 # Copy the content to xxx.desktop mkdir -p ~/.local/share/applications touch ~/.local/share/applications/xxx.desktop ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/appimage%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"AppImage的使用"},{"content":"基本软件 工具 名字 display manager lightdm desktop environment xfce4 文本编辑器 vscode/vim/emacs 程序启动器 rofi 输入法 fcitx5 browser microsoft-edge-dev(AUR) 多线程下载 aria2 压缩包解压/查看 ark proxy clash for window(AUR) RSS fluent-reader shell zsh PDF zathura 命令行软件 描述 名字 显示目录大小 ncdu 高级版top gotop(AUR)/htop 打印彩色的十六进制 hexyl 语法高亮和行号的cat+less bat 统计目录代码量 loc 文件浏览器 ranger 比tmux更好用的单窗口多终端 zellij 新建用户 useradd -m -G wheel username passwd username ln -s /usr/bin/vim /usr/bin/vi visudo 找到# %wheel ALL=(ALL)ALL取消注释\n硬件 网卡 万物起源先上网，但有些网卡需要手动装驱动(比如我笔记本的博通网卡)\nsudo pacman -S linux-headers broadcom-wl-dkms reboot dkms status 声卡 sudo pacman -S alsa-utils pulseaudio-alsa 蓝牙 sudo pacman -S bluez bluez-utils /etc/bluetooth/main.conf [Policy] AutoEnable=true # 开机自启 联网 启动之前安装的NetworkManager\nsystemctl enable NetworkManager 图形界面 sudo pacman -S xf86-video-intel sudo pacman -S xorg sudo pacman -S xfce4 xfce4-goodies sudo pacman -S lightdm lightdm-gtk-greeter sudo systemctl enable lightdm AUR sudo pacman -S paru bash sudo pacman -S zsh sudo chsh -s /bin/zsh username 中文字体/输入法 sudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-rime 下载 sudo pacman -S aria2 # web前端(还有很多前端可供挑选) paru ariang-allinone # copy 大佬的配置 git clone https://github.com/P3TERX/aria2.conf mkdir ~/.aria2 mv aria2.conf ~/.aria2/ touch ~/.aria2/aria2.session 看aria2.conf注释配置路径 看wiki配置开机自启 Reference Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/linux%E9%85%8D%E7%BD%AE/","title":"Linux配置"},{"content":"其实大部分情况下和raytracing类似\n不同:\n几何物体的描述 光线与几何物体求交 法线的获取 Reference iq大佬的网站 ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%9F%BA%E4%BA%8Esdf%E7%9A%84raymarching/","title":"基于SDF的Raymarching"},{"content":"自学怎么说呢，我也在摸索，不过我认为先做一下CSAPP的bomb lab比较好\nbomb lab 逆向汇编破解程序\n这个作业怎么下载还有工具自己找吧，都很容易获取\n可能要用到的东西\ngdb x86指令文档 我研究的时候是边做边学，打断点，单步看汇编，不懂的指令/寄存器现场查\ntools 强大的工具 ghidra ida gdb 十六进制编辑器 bless 十六进制查看 hexyl(跨平台/终端彩色输出) 解包 arc_unpacker crass Reference 逆向工程入门简述 汇编语言简述(逆向工程) ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","title":"逆向工程"},{"content":"我的系统是ArchLinux，所以看着archwiki一路配置比较舒服\n其他系统请看官方文档\n从安装到启动 my.domain.name替换成自己的域名就行\nsudo cd /var/lib/synapse sudo -u synapse python -m synapse.app.homeserver \\ --server-name my.domain.name \\ --config-path /etc/synapse/homeserver.yaml \\ --generate-config \\ --report-stats=yes sudo systemctl start synapse.service # 服务器至少要有一个用户 register_new_matrix_user -c /etc/synapse/homeserver.yaml http://127.0.0.1:8008 这时候应该就可以用一个matrix client来连接了，这里选择element\n","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8synapse%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"使用Synapse自建聊天服务器"},{"content":"yt-dlp 一个命令行下载youtube视频软件，目前来说就他下载速度还行，其他同类工具被限速了\nTL;DR\n下载一个视频\nyt-dlp URL 不下载，查看视频下载的信息(选择画质)\nyt-dlp -F URL [BiliBili] 12Q4y1S73g: Downloading webpage [BiliBili] 12Q4y1S73g: Downloading video info page [info] Available formats for 12Q4y1S73g: format code extension resolution note 0 flv unknown 1 flv unknown 2 flv unknown 295.77MiB (best) 下载bilibili视频 Bilibili Evolved + aria2 下载视频\nBilibili Evolved提供了几种视频下载方式，我这里选择aria2\n启动aria2后，在插件里选择aria2 rpc就可以自动下载视频了\n","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91/","title":"使用命令行工具下载在线视频"},{"content":"编年史和纪传体 编年史:\n15年你，你表哥，你表妹做了哪些事情\n16年你，你表哥，你表妹做了哪些事情\n。。。。。\nN年你，你表哥，你表妹做了哪些事情\n记传使：\n15-N年，你做了什么事情\n15-N年，你表哥做了什么事情\n15-N年，你表妹做了什么事情\n小结，比喻不准确。\n断网时谷歌浏览器小游戏 谷歌浏览器输入chrome://dino/\nEnter后按空格\n就有个小游戏玩了\n甚至还有人用js写了个外挂\n乱数假文 Lorem ipsum，中文又称“乱数假文”，是指一篇常用于排版设计领域的拉丁文文章，主要的目的为测试文章或文字在不同字型、版型下看起来的效果，通常网站还没建设好时会出现这段字 -来自百度 科普\n【木鱼说129】如果你网龄够长，一定看过这张图——从「乱数假文」到「互联网第一夫人」知识科学科普\nsex English words Cunnilingus paedophilia pspanking ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%B0%8F%E7%9F%A5%E8%AF%86/","title":"小知识"},{"content":"圆内接正多边形的面积 假设半径为R，正多边形顶点数为n\n正多边形外接圆，圆和正多边形中心点为同一位置\n将中心点对每个角连线，生成n个等腰三角形，腰长等于半径\n求出单个三角形面积，再乘以三角形数量\n$$ S = \\frac{nR^{2}sin(\\frac{2\\pi}{n})}{2} $$\n","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%9C%86%E5%86%85%E6%8E%A5%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/","title":"圆内接正多边形的面积"},{"content":"满足range这个concept就可以使用该函数\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;ranges\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; template \u0026lt;std::ranges::range T\u0026gt; void println(const T\u0026amp; args) { for(const auto\u0026amp; v : args) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template \u0026lt;std::ranges::range... Ts\u0026gt; void print(Ts... args) { (println(args), ...); } int main() { std::array\u0026lt;int, 10\u0026gt; arr; std::iota(arr.begin(), arr.end(), 0); std::vector\u0026lt;int\u0026gt; vec(10); std::iota(vec.begin(), vec.end(), -10); print(arr, vec); } 输出\n0 1 2 3 4 5 6 7 8 9\r-10 -9 -8 -7 -6 -5 -4 -3 -2 -1\r","date":"2022-01-11T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0stl%E5%AE%B9%E5%99%A8/","title":"一个函数打印STL容器"},{"content":"前置知识 编译链接到可执行程序一系列流程 x86架构的一些寄存器 elf头 下面工具的使用 环境配置 os: Linux\n可能会用到的工具:\ngcc(编译) ld(链接) objcopy(提取二进制) dd(写入虚拟镜像) gdb(调试) make(自动化构建) qemu(虚拟机) 大部分linux发行版都会自带大部分工具，自行安装最新版本即可\n基本介绍 目标是实现一个不依赖操作系统就能运行的二进制程序，在虚拟机屏幕显示hello world\n计算机启动，按下电源开关通电启动bios，检查硬件，没啥问题的话，bios会加载该储存设备第一个扇区的512字节(MBR)到物理内存0x7C00\n如果扇区最后两个字节是0x55和0xAA，那么说明是启动设备，否则bios会跳过该扇区\n如果装过系统的话，会发现这就是BIOS+MBR传统启动计算机方式，而现在比较“先进”的方式是UEFI启动\n最后bios使用命令jmp 0x7c00跳到我们代码，我们旅程就这样开始了\n实现 coding 汇编大体上两种语法，intel和AT\u0026amp;T，这里选择AT\u0026amp;T，如果是用intel语法，可以去找nasm等汇编器编译\n附上两个伪指令，表明是16位代码和程序开头在main\n.globl main\r.code16\r然后设置段寄存器为零，异或清零是常用的手法。为什么要清零，因为此时cpu在实模式下(real mode)，物理内存寻址是采用 段：偏移，计算方式如下\n物理地址 = 段 * 16 + 偏移\n如果我们直接设零，那么偏移量直接等于物理地址\nxorw %ax, %ax\rmovw %ax, %ds\rmovw %ax, %es\rmovw %ax, %ss\r因为现代操作系统是分页管理内存，段管理内存已经不再使用，但有时候他会以某种方式出现我们眼前\n比如：平时写C/C++程序遇到的Segmentation fault\n如何在屏幕上输出字符串呢，答案是使用bios中断\nbios中断没必要深究，当成api使用即可，使用方法就是在指定寄存器赋值，然后使用int指令和对应中断号\n这里看0x10中断指令的用法\n中断返回后，可以看到字符串按照我们的格式输出在屏幕上\n编译 这里我们使用make来管理编译流程\ngcc/ld/objcopy/dd等使用方法参考我的makefile\n编译汇编源文件为.o文件 指定程序入口函数和地址，链接成elf文件 将elf文件中代码和数据提取成纯二进制文件 然后使用dd拼接512字节的MBR\n生成全为零的512字节文件 开头刻录我们的二进制文件 最后两个字节刻录魔数 这里使用其他工具或python脚本也可以完成\n运行 qemu-system-x86_64 -no-shutdown -no-reboot -m 128M -hda \u0026lt;你的镜像\u0026gt;\rdebug 加上debug参数的启动命令\nqemu-system-x86_64 -S -s -no-shutdown -no-reboot -m 128M -hda \u0026lt;你的镜像\u0026gt;\rgdb脚本解读：设置架构-远程链接虚拟机-debug文件-在main函数打断点-显示汇编和寄存器-运行\nset architecture i386:x86-64\rtarget remote:1234\rfile build/debug/hello.elf\rbreak main\rlayout asm\rlayout regs\rcontinue\r使用gdb脚本\ngdb -q -x kernel.gdbinit\r输入si执行单条汇编指令，观察寄存器变化\nReference INT 10H AMD64 Architecture Programmer’s Manual Volume 3: General Purpose and System Instructions ","date":"2021-10-12T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E8%A3%B8%E6%9C%BA%E8%BF%90%E8%A1%8Chello-world/","title":"裸机运行Hello world"},{"content":" 部分游戏没有全通 有些gal没有吐槽 系列作品会合在一起 没有汉化 tag 的默认是生肉 内有剧透（这不是废话么） オモカゲ ～えっちなハプニング!? なんでもどんとこい!～ 译名：思影\n会社：あかべぇそふとすりぃ\nTag：汉化 萌拔 幼驯染 后宫\n空の青と白と／瞬きの夏 译名：天空的蓝与白/如梭夏日\n会社：バリスタラボ\nTag：汉化 废萌\n輪舞曲Duo -夜明けのフォルテシモ- ぷにゅぷりff 译名：天空的蓝与白/如梭夏日\n会社：ティンクルベル\nTag：汉化 百合 扶她 拔作\n神採りアルケミーマイスター 译名：神采炼金大师\n会社：エウシュリー\nTag：汉化 SLG 后宫\n放課後シンデレラ２ 译名：放学后的灰姑娘2\n会社：HOOKSOFT\nTag：废萌\n共通日常可以，个人线没对上胃口\n終わる世界とバースデイ 译名：世界末日和生日\n会社：コットンソフト\nTag：科幻 悬疑 妹系 泣系 猎奇\n演出神作，尽管推完的那天并不是自己的生日，还是被感动到哭了\n穢翼のユースティア 译名：秽翼的尤斯蒂娅\n会社：オーガスト\nTag：汉化 奇幻\nISLAND 会社：Front Wing\nTag：汉化 科幻 悬疑\nシロナガス島への帰還 译名：重返蓝鲸岛\n会社：旅の道\nTag：汉化 恐怖 悬疑 馆系\nふゆから、くるる 译名：冬旅，方冥冥\n会社：シルキーズプラス\nTag：汉化 科幻 悬疑 百合 扶她\n時計仕掛けのレイライン 译名：时钟机关的Ley-line\n会社：ユニゾンシフト：ブロッサム\nTag：汉化 傲娇\n有人讲是三部曲，但我感觉是分割商法出的三部作品，所以应该当成同一部作品对待\n在第一部中，各种遗品剧情的插入感觉有点生硬，后面有所改观。剧情最后提了一点因果律，但没有继续深入\n总的来说，算是稳扎稳打，伏笔都能完整回收，剧情高潮时一气呵成，因此可能缺乏一定的剧情深度\n最棒的是塑造了个完美的傲娇女主-憂緒，而且巨乳角色很少，治好了我的晕奶。其他女主的恋爱戏份很少，几乎可以当只有憂緒一个女主。不过一些个人线玩起来很欢乐，比如眠子\n金色ラブリッチェ 译名：金辉恋曲四重奏\n会社：Saga Planets\nTag: 汉化 废萌 后宫\n玲奈线，感觉剧情浪费人设了😢\n3p先不谈，先打炮再表白感觉不爽，后半段剧情还一点镜头都没有，变成基友主场\n在bangumi吐槽区发现一处很符合我的想法\n情弱弟\n游艺dz，鉴定为：八成废萌。剩下两成是作者多次强调的：找到属于自己的金色时光，在这短暂的日子里不留遗憾地尽情“耍帅”。虽然升华了，但可能笔力有限，情感传达不到位，有点强行点题，显得说教意味偏浓了。\n和我以前写语文作文强行点题那味了\nRewrite 译名：罚抄\n会社：Key\nFD：Rewrite Harvest festa!\n后劲很大\nはつゆきさくら 译名：初雪樱\n会社：Saga Planets\n好像勉勉强强get到新岛夕说什么，但又没说什么。最后的毕业倒是有点煽情\n毕业的时候来栖老师说，把一堆麻烦塞给男主，其实是为了让他过上正常的校园生活，这一点我倒是很赞同(谁不想过上青春的校园生活)。不过本作的日常写的一般，而且黄段子属实尬，但女主面对黄段子的演出不错，属实浪费好画风和cv了\n不过相比魔女恋爱日记好的就是，起码把故事给我讲懂了\n大部分个人线感觉良好，除了シロクマ，完全意义不明。个人最喜欢あずま 夜\nClover Day\u0026rsquo;s 译名：幸运草的约定\n会社：ALcot\n治愈废萌，可爱就完事\n幼馴染と十年、夏 译名：幼驯染与十年之夏\n会社：夜のひつじ\n短篇单线幼驯染作品，氛围不错，但我觉得还是太短了\n放課後シンデレラ 译名：放学后的灰姑娘\n会社：HOOKSOFT\n平平淡淡的废萌发糖作，共通线基本就是与女主深入了解交流（不点名批评某位女主，在共通线一直觉得操作很迷惑）\nPRIMAL×HEARTS 月幕\n译名：月色天娇\n会社：ま～まれぇど\n也是比较平平淡淡废萌作品，一开始推了駒形线，感觉不是很对胃口\n其实进线前我是二选一，所以我直接冲向歌奈线\n不行了我，麻麻的，感觉身体有电流穿过，这就是恋爱么，而且还是小恶魔学姐，一直拖着不给男主告白，却又给男主尝了点甜头，实在是太刺激了\n个人线里的冲突事件都处理的很好，很快就完事了，没有高血压操作\nかりぐらし恋愛 月幕\n译名：寄宿之恋\n会社：ASa Project\n共通线够搞笑，个人线只推了理兎，平平淡淡的发糖\n群友告诉我，说不定其他线路有意想不到的剧情了，单线战士不可取（可恶，我是纯爱党）。所以我还是去推其他线了\n好家伙，几乎每条线都能看到理兎妒忌其他女主吃醋，这不让我更爱这个美少女么，呜呜\nすぃ～と・はに～・ふぁみり～ 娘ト妻ニ甘イハ父ノ習ヒ 月幕\n译名：甜蜜家庭～妻女和宠溺父亲的每一天～\n会社：オーバードーズ\n拔作，老婆女儿孕肚play好耶\nレイジングループ 译名：人狼村之谜\n会社：KEMCO\n日式狼人杀，故事看得很上头\n灰色系列 会社：Frontwing\nグリザイアの果実 月幕\n译名：灰色的果实\n个人线都很赞，辛线是唯一看哭的（呜呜）\n蒔菜线，两个结局感觉都很痛苦（但拿狙击枪的美少女真的很帅啊，后续乐园还有狙击操作）\n天音线，懂得都懂，那段生存剧情确实很过瘾，动画制作组也懂，所以动画也花了很多精力去做这段剧情。最后面有段小高潮被人追杀，能互相为对方舍命，有点感动。好结局有一丝丝悲伤，毕竟，看到了美少女变老的场景，总觉得心，哪里很难受\nグリザイアの迷宮 月幕\n译名：灰色的迷宫\nOP最好听\nグリザイアの楽園 月幕\n译名：灰色的乐园\n战斗的美少女太帅啦\nフレラバ ～Friend to Lover～ 月幕\n译名：从朋友到恋人\n会社：Smee\nFD：フレラバ 〜Friend to Lover〜 ミニファンディスク\n甜死了甜死了，傲娇大好き\nいきなりサキュバス ～いちゃらぶ搾精ライフ～ 月幕\n译名：\n会社：ZION\n白丝巨乳萝莉魅魔，魅魔星奏的发糖续作\nChaos;Child 月幕 /萌娘百科\n译名：混沌之子\n会社：5pb.\n通关后感觉不是滋味，我实在与宮代 拓留太像了，刚好看的一篇文章也令人深思\n御宅族与ChaosChild症候群\n说的对，这就是部垃圾作品，痛击死宅罢了\nRemember11 -The Age of Infinity- 月幕 /中文版解密篇网站\n译名：Remember11：无限轮回的时光\n会社：KID\n从艺术方面看，即使解密篇没有出，但刚刚好完成了困住玩家的这个目标 从商业作品看，确实是部不完整的作品 但对于我来说，在我认为的神作中排第一\nEver17 —the out of infinity— 译名：Ever17—时空轮回\n会社：KID\n约定好不要剧透\n出会って5分は俺のもの！時間停止と不可避な運命 译名：相遇之后的5分钟属于我！时间停止与不可避的命运\n会社：Hulotte\n白毛萝莉妙啊\nキミのとなりで恋してる 译名：慕情之心今随君作伴\n会社：ALcot ハニカム\nFD：キミのとなりで恋してる！ -THE RESPECTIVE HAPPINESS-\n理想中的幼驯染\n車輪の国、悠久の少年少女 译名：车轮之国：悠久之少男少女\n会社：AKABEiSOFT2\n不会日语，还好早就被剧透了游戏的最后一句话，毕竟这句话是真的man\n車輪の国、向日葵の少女 译名：车轮之国：向日葵的少女\n会社：AKABEiSOFT2\n05年画风也真好看\nG線上の魔王 译名：G弦上的魔王\n会社：AKABEiSOFT2\n带有叙诡类型的游戏玩的少，所以智斗代入感非常强，看的也很爽\nきまぐれテンプテーション 译名：异想魅惑\n会社：Silky\u0026rsquo;s Plus WASABI\nnaizi好晃\nきゃらぶれーしょん！ ～乙女は恋してキャラぶれる～ 译名：恋爱少女人格崩坏\n会社：AKABEiSOFT3\n表里不一（\n抖m狂喜\neuphoria 译名：乐园\n会社：CLOCKUP\n第一次碰猎奇作品，感觉慢慢能接受？\n倉野くんちのふたご事情 译名：仓野家的双子情事\n会社：CUBE\n妹妹可爱\n3days～満ちてゆく刻の彼方で～ 译名：3days～在逝去时间的另一端～\n会社：Lass\n死了N次，还是得看攻略啊（\n君と彼女と彼女の恋 译名：你和她和她的恋爱\n会社：Nitro+\n打到困住轮回里就没怎么打了\nSummer Pockets 译名：夏日口袋\n会社：Key\nKey社换画师后画风好了很多\n恋×シンアイ彼女 译名：想要传达给你的爱恋\n会社：Us:track\n彩音线好甜\n魔女こいにっき 译名：魔女恋爱日记\n会社：Qoobrand\n故事没看懂\u0026hellip;\nオトメ＊ドメイン 译名：少女领域\n会社：Palette\n忘却執事と恋するお嬢様の回想録 译名：忘却管家与恋爱大小姐的回忆录\n会社：Campus\n僕と恋するポンコツアクマ。すっごいえっち 译名：与我恋爱的废材恶魔\n会社：Smile\n太拔勒，虚了\nイブニクル 译名：夏娃年代记1\n会社：Alicesoft\n打怪升级玩上瘾了，已经三周目\n","date":"2021-09-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/galgame%E6%B8%B8%E7%8E%A9%E8%AE%B0%E5%BD%95/","title":"galgame游玩记录"},{"content":"配置 虚拟机: Oracle VM VirtualBox 笔记本：UEFI启动 镜像: 官网 前提 了解UEFI还是BIOS启动，不同的启动方式对应不同的步骤 基本的linux命令行操作和知识 足够耐心 善用archwiki 安装 联网 wifi配置麻烦，强烈建议网线或者手机usb联网\nip link 然后ping查看联网是否成功\nping baidu.com 更新系统时间 timedatectl set-ntp true timedatectl status # 检查服务状态 硬盘分区 硬盘分区工具有很多，推荐小白使用cfdisk\n查看硬盘用lsblk\n在分区前，需了解swap(分区)，区别linux根分区和windows盘符的概念\n如果是UEFI启动，需要分一个EFI区，而BIOS则不用\n分区步骤大概就是：new-\u0026gt;分大小-\u0026gt;改类型-\u0026gt;保存-\u0026gt;格式化-\u0026gt;挂载\nEFI分区和正常分区格式化工具不一样\n根分区需要首先挂载\nswap区看需求分(格式化和挂载是单独命令使用)\n添加国内镜像加速 vim /etc/pacman.d/mirrorlist # 添加 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.zju.edu.cn/archlinux/$repo/os/$arch 安装基本包 pacstrap /mnt base linux linux-firmware 在此步骤可以考虑把常用软件装了(vim/networkmanager/sudo)\n配置Fstab genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab # 检查 change root 切换到自己系统\narch-chroot /mnt 设置时区 # Asia和Shanghai按需替换 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 设置Locale # 把需要用的注释取消 vim /etc/locale.gen # 当前使用的locale echo LANG=en_US.UTF-8 \u0026gt;\u0026gt; /etc/locale.conf # 初始化 locale-gen 设置root密码 passwd # 密码不回显 网络配置 # myhostname替换自己主机名 echo myhostname \u0026gt;\u0026gt; /etc/hostname vim /etc/hosts 添加 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyhostname.localdomain\tmyhostname # 主机名.本地域名 主机名 安装引导程序 grub 不使用grub启动 ps:用这个方法前，假如你是intel-cpu，需要先安装intel-ucode\nbootctl install # 添加 vim /boot/loader/loader.conf default arch timeout 4 # 添加 vim /boot/loader/entries/arch.conf title Arch Linux linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux.img options root=根分区路径 rw # 例如/dev/sda2 重新启动 exit poweroff/reboot 拔掉u盘，等待弹出tty终端，要求输入账户密码登录\n因为我是UEFI引导，所以笔记本需要更改启动方式为UEFI，而不使用BIOS，\nReference 以官方Wiki的方式安装ArchLinux ","date":"2021-08-02T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E8%AE%B0%E5%BD%95%E5%AE%89%E8%A3%85arch%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"记录安装arch的过程"},{"content":"在一些基础的光线追踪教程中，光线求交通常发生在世界空间(world space)\n但在离线渲染器中(比如PBRT)，光线求交发生在几何图形自己的局部空间(local/object/model space)\n这是有好处的，比如说简化求交代码，相交表面的normal和uv也很容易计算\n下面就记录一些几何求交的做法，自身经验有限，如有错误请指出\n前提 这里采用的是y轴朝上的右手坐标系，-z轴指向屏幕里，x轴在右手 默认光线已经变换到对象的局部空间 使用几何体的变换矩阵和其逆矩阵，求交时将光线变换到对象空间\n$$ Ray(t)=o+td (t \u0026gt; 0) $$\n$$ Ray_{object}=M^{-1}Ray_{world} $$\n矩形(Rectangle) 假设矩形高度为0，躺在xz平面上。长和宽控制矩形大小\n忽略平行于平面的光线\nif(is_zero(ray.direction.y)) return false; 使用高度计算相交点 $$ t=\\frac{0 - o_{y}}{d_{y}} $$\nconst auto t = ray.inv_at\u0026lt;Axis::Y\u0026gt;(0); const auto [x, y, z] = ray.at(t); 在矩形范围内的点才算相交成功\nif(std::abs(x) \u0026gt; length || std::abs(z) \u0026gt; width) return false; 球(Sphere) 假设球心在原点，半径控制球的大小\n三维空间中球的一般方程 $$ x^{2}+y^{2}+z^{2}=r^{2} $$\n将光线代入方程 $$ (o+td)^{2}=r^{2} $$\n整理可得关于t的一元二次方程 $$ d^{2}t^{2}+2odt+o^{2}-r^{2}=0\\ \\begin{align*} \u0026amp; a=d^{2}\\ \u0026amp; b=2od\\ \u0026amp; c=o^{2}-r^{2} \\end{align*} $$\n假如光线的方向向量已经归一化，那么 $$ |\\overrightarrow{d}|^{2}=1 $$\nconst auto a = 1; const auto b = 2 * dot(ray.origin, ray.direction); const auto c = dot(ray.origin, ray.origin) - radius * radius; 解一元二次方程，没有解则求交失败\nconst auto result = quadratic(a, b, c); if(!result) return false; 有解则找到最近的交点\nconst auto [x1, x2] = result.value(); const auto t = min(x1, x2); 圆柱(Cylinder) 假设圆柱底面在xz平面，底面圆心在原点，半径和高度控制圆柱大小和长度，phi表示圆柱曲面的完整度\n首先忽略y轴，求出相交点是否在圆柱底面\n圆柱底面的一般方程 $$ x^{2}+z^{2}=r^{2} $$\n将光线代入，同理可得 $$ (d_{x}^{2}+d_{z}^{2})t^{2}+2(o_{x}d_{x}+o_{z}d_{z})t+o_{x}^{2}+o_{z}^{2}-r^{2}=0 $$\n日常解一元二次方程\n$$ \\begin{align*} \u0026amp; a = d_{x}^{2}+d_{z}^{2}\\ \u0026amp; b = 2(o_{x}d_{x}+o_{z}d_{z})\\ \u0026amp; c = o_{x}^{2}+o_{z}^{2}-r^{2} \\end{align*} $$\nconst auto a = dx * dx + dz * dz; const auto b = 2 * (ox * dx + oz * dz); const auto c = ox * ox + oz * oz - radius * radius; const auto result = quadratic(a, b, c); if(!result) return false; 计算相交点高度判断是否在范围内，先从最小t开始\nauto [x1, x2] = result.value(); if(x1 \u0026gt; x2) std::swap(x1, x2); auto t = x1; auto [x, y, z] = ray.at(t); auto phi = std::atan2(z, x); if(phi \u0026lt; 0) phi += 2 * PI\u0026lt;f32\u0026gt;; 假如第一个x1不符合条件，需要对x2继续进行判断\nif(y \u0026lt; min_height || y \u0026gt; max_height || phi \u0026gt; max_angle) { t = x2; auto [x, y, z] = ray.at(t); phi = std::atan2(z, x); if(phi \u0026lt; 0) phi += 2 * PI\u0026lt;f32\u0026gt;; if(y \u0026lt; min_height || y \u0026gt; max_height || phi \u0026gt; max_angle) return false; } 小提示：当圆柱曲面不是封闭的时候，所求相交点有可能在圆柱内部，这时需要反转(flip)法线才能进行正确的着色\n顶盖和底盖(Cap) 这时候圆柱求交算是基本完成了，但渲染的时候又发现一个问题，圆柱没有顶盖和底盖，也就是二维曲面并不是封闭的，因为圆柱体是一个退化的二维曲面\n这时候相当于加入了两个圆盘(Disk)\n如果在之前与圆柱曲面相交了，需要传入t与这次求交所得cap_t判断哪个最近\nconst auto intersect = [\u0026amp;](f32 cap_t) { if(cap_t \u0026gt;= t || cap_t \u0026lt;= 0) return; if(!check_cap(ray, cap_t)) return; t = cap_t; }; 我们可以增加一个枚举变量cylinder_shape，来表示需要圆柱的顶面/底面，或者说我全都要也行\nif(cylinder_shape \u0026amp; cylinder_top) intersect(ray.inv_at\u0026lt;Axis::Y\u0026gt;(max_height)); if(cylinder_shape \u0026amp; cylinder_bottom) intersect(ray.inv_at\u0026lt;Axis::Y\u0026gt;(min_height)); 圆盘求交也很简单 $$ x^{2}+z^{2} \\leq r^{2} $$\nbool Cylinder::check_cap(const Ray3f\u0026amp; ray, f32 t) const { const auto x = ray.at\u0026lt;Axis::X\u0026gt;(t); const auto z = ray.at\u0026lt;Axis::Z\u0026gt;(t); return (x * x + z * z) \u0026lt;= radius * radius; } Reference Physically Based Rendering: From Theory to Implementation The Ray Tracer Challenge ","date":"2021-04-11T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%85%89%E7%BA%BF%E4%B8%8E%E5%90%84%E7%A7%8D%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E6%B1%82%E4%BA%A4/","title":"光线与各种几何图形求交"},{"content":"GAMES101:现代计算机图形学入门 网课，可在b站上观看\nassignment 5-7 是光线追踪的作业\n如果对光栅化，几何，动画与模拟，不感兴趣，可以只看Lecture 13-20（个人建议：把整套课看完也是不错的）\nTaichi课程 课程主页\n网课，其中6-7讲涉及光线追踪\nPeter Shirley写的光线追踪三部曲 Ray Tracing in One Weekend Ray Tracing: The Next Week Ray Tracing: The Rest of Your Life 书中配套代码，在网上能搜到这三本的笔记和翻译版本\n我认为这是光线追踪入门的最好教程\nDaily Pathtracer Aras Pranckevičius大佬写的教程\n介绍 博客\nNori an educational ray tracer\n主页\n5个assignment\nPBRT Physically Based Rendering:From Theory To Implementation\n这本书是学习离线渲染系统书（离线渲染圣经），配套代码在github上\n网上在线阅读\n此为光线追踪进阶书籍\n书 Ray Tracing Gems Advanced global illumination Fundamentals of Computer Graphics Real-Time Rendering 全局光照技术 杂类 github上收集的图形学资料 milo yip的用JavaScript玩转计算机图形学-光线追踪入门 scratchapixel，图形学网站，对细节讲解很详细，配套代码 99行代码写出路径追踪-smallpt real-time-rendering，网站内附带很多图形学资料 mitsuba,一个开源渲染器 stackexchange的计算机图形学板块 ","date":"2020-12-16T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/","title":"离线渲染-光线追踪框架学习资料"}]