[{"content":"先来展示个 cmake 包模板。\npackage(\u0026#34;xxx\u0026#34;) set_homepage(\u0026#34;https://github.com/xxx/yyy\u0026#34;) set_description(\u0026#34;\u0026#34;) set_license(\u0026#34;\u0026#34;) add_urls(\u0026#34;https://github.com/xxx/yyy/archive/refs/tags/$(version).tar.gz\u0026#34;, \u0026#34;https://github.com/xxx/yyy.git\u0026#34;) add_versions(\u0026#34;v1.0.0\u0026#34;, \u0026#34;sha256\u0026#34;) add_deps(\u0026#34;cmake\u0026#34;, \u0026#34;ninja\u0026#34;) on_install(function (package) local configs = {} table.insert(configs, \u0026#34;-DCMAKE_BUILD_TYPE=\u0026#34; .. (package:is_debug() and \u0026#34;Debug\u0026#34; or \u0026#34;Release\u0026#34;)) table.insert(configs, \u0026#34;-DBUILD_SHARED_LIBS=\u0026#34; .. (package:config(\u0026#34;shared\u0026#34;) and \u0026#34;ON\u0026#34; or \u0026#34;OFF\u0026#34;)) if package:is_plat(\u0026#34;windows\u0026#34;) and package:config(\u0026#34;shared\u0026#34;) then table.insert(configs, \u0026#34;-DCMAKE_WINDOWS_EXPORT_ALL_SYMBOLS=ON\u0026#34;) end io.replace(\u0026#34;CMakeLists.txt\u0026#34;, \u0026#34;xxx\u0026#34;, \u0026#34;\u0026#34;, {plain = true}) import(\u0026#34;package.tools.cmake\u0026#34;).install(package, configs, {cmake_generator = \u0026#34;Ninja\u0026#34;}) end) on_test(function (package) assert(package:has_cxxfuncs(\u0026#34;xxx\u0026#34;, {includes = \u0026#34;yyy.h\u0026#34;})) end) 观察发现，这其实和写 target 差不多，不过 api 的语义不一样而已。\ngit clone https://github.com/xmake-io/xmake-repo # 使用脚本生成模板 xmake l scripts/new.lua github:yyy/xxx 在本地测试包。\nxmake l scripts/test.lua -vD --shallow xxx 可以添加 -p mingw 或 -k shared 等参数来测试不同的平台 和 configs。\n测试成功后，可以提交 pr。注意要 push 到 dev 分支才能触发 ci 的检测。\n其实选错分支也没关系，可以重新选择，然后先 close pr 再 open 来触发 ci。\nAPI 解读 名字 包名一律统一为小写，这是规定。这是为了适配不同系统环境下，系统库的查找。\nversion 通常情况下，使用 git tag 作为包的版本号。如果下载 tar.gz 压缩包失败，只要 url 中添加了库的 git 地址，xmake 就可以使用 git clone 并根据 tag 号切换。\n有些库版本号不是以 x.y.z 的形式来命名，这样 xmake 会解析失败，需要我们转换版本号。\n比如 directx 相关的包都是用月份+年份来命名，我们需要把他转换成用点和数字表示的日期。\nlocal tag = { [\u0026#34;2023.06\u0026#34;] = \u0026#34;jun2023\u0026#34;, } local version = function (version) return tag[tostring(version)] end add_versions(\u0026#34;2023.06\u0026#34;, \u0026#34;sha256\u0026#34;) configs 对应库的构建选项。如果一些内置选项支持不完善，比如 shared，就会打上 readonly，表示不可修改，只能使用默认配置。\nadd_configs(\u0026#34;shared\u0026#34;, {description = \u0026#34;Build shared library.\u0026#34;, default = true, type = \u0026#34;boolean\u0026#34;, readonly = true}) 需要打上 readonly 的情况各有不同，比如库根本就不支持，或构建的时候有问题，打包者处理不了。\non_install 这一步需要调用构建系统对库 配置 -\u0026gt; 构建 -\u0026gt; 安装。\n最简单的，直接把 debug/release 和 shared/static 等选项传给构建系统。如果库在 Windows 上没支持动态库，我们可以尝试使用 cmake 的导出符号来支持。\nif package:is_plat(\u0026#34;windows\u0026#34;) and package:config(\u0026#34;shared\u0026#34;) then table.insert(configs, \u0026#34;-DCMAKE_WINDOWS_EXPORT_ALL_SYMBOLS=ON\u0026#34;) end xmake 包默认是不保留例子和测试的，所以需要打包者添加构建选项取消。然而有些库根本没有这些选项，我们可以适当优化，比如使用 io.replace 修改 cmakelists，把 add_subdirectory(test) 等删掉，或者直接打个 patch 修改。\non_test 平时用 has_cxxfuncs 系列既可以保持简洁，又可以检测到依赖的静态库/动态库有没有被正常链接上。\non_test(function (package) assert(package:has_cxxfuncs(\u0026#34;xxx\u0026#34;, {includes = \u0026#34;yyy.h\u0026#34;})) end) 有些 C++ 库只暴露出类接口，只能通过写相关代码进行测试。\non_test(function (package) assert(package:check_cxxsnippets({test = [[ #include \u0026lt;xxx/yyy.hpp\u0026gt; void test() { auto var = xxx(); } ]]}, {configs = {languages = \u0026#34;c++17\u0026#34;}})) end) 优化库的构建 本地测试 因为要保持 xmake 包最小化依赖原则，实际上 cmake 包只使用系统默认的构建系统，而不是 ninja。但打包者依然可以在测试中使用 ninja 加速编译。\n头文件库 设置 headeronly 类型后，build hash 会唯一，避免浪费硬盘。\nset_kind(\u0026#34;library\u0026#34;, {headeronly = true}) 有些库可能支持非头文件模式编译，通常使用 header_only 来命名 config，然后 on_load 和 on_install 需要做对应处理。\nadd_configs(\u0026#34;header_only\u0026#34;, {description = \u0026#34;Use header only version.\u0026#34;, default = true, type = \u0026#34;boolean\u0026#34;}) on_load(function (package) if package:config(\u0026#34;header_only\u0026#34;) then package:set(\u0026#34;library\u0026#34;, {headeronly = true}) end end) on_install(function (package) if package:config(\u0026#34;header_only\u0026#34;) then os.cp(\u0026#34;include\u0026#34;, package:installdir()) return end -- 非头文件模式编译 end) 有些库会提供构建系统来安装头文件库，那么就要优先使用构建系统安装头文件，而不是手动拷贝。\nport（使用 xmake 构建） 当一些库没有构建系统，或者库使用的构建系统，在尝试多次但都构建失败，那么需要考虑用 xmake 本身来编译该库，这对打包者来说是一个挑战。\n这里先给出模板。\non_install(function (package) io.writefile(\u0026#34;xmake.lua\u0026#34;, [[ add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) set_languages(\u0026#34;c++17\u0026#34;) target(\u0026#34;xxx\u0026#34;) set_kind(\u0026#34;$(kind)\u0026#34;) add_files(\u0026#34;src/**.cpp\u0026#34;) add_headerfiles(\u0026#34;include/**.h\u0026#34;) if is_plat(\u0026#34;windows\u0026#34;) and is_kind(\u0026#34;shared\u0026#34;) then add_rules(\u0026#34;utils.symbols.export_all\u0026#34;, {export_classes = true}) end ]]) import(\u0026#34;package.tools.xmake\u0026#34;).install(package) end) 有时候 xmake.lua 太大，影响包描述文件的简洁性，可以在包目录新建一个 port/xmake.lua，然后描述文件这样写：\non_install(function (package) os.cp(path.join(package:scriptdir(), \u0026#34;port\u0026#34;, \u0026#34;xmake.lua\u0026#34;), \u0026#34;xmake.lua\u0026#34;) import(\u0026#34;package.tools.xmake\u0026#34;).install(package) end) ","date":"2023-08-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%A6%82%E4%BD%95%E7%BB%99-xmake-%E6%89%93%E5%8C%85/","title":"如何给 Xmake 打包"},{"content":"子标题：一个第三方库需要哪些构建选项。\nC Runtime 在 Linux 下编译，基本都是动态链接 glibc 吧，如果你想静态链接，或者静态链接其他 libc (如 musl)。 在 Windows 下，通常都是链接 UCRT，那问题来了，应该有个选项选择 MT/MTd/MD/MDd 吧。 生成动态/静态库 这貌似是一个很基础的选项，没必要提出来，但事实上还是有很多开发者根本不处理（也许别人没考虑过 Windows 平台）。\n比如在编译静态库时用了 #define EXPORT __declspec(dllexport)，但根本不需要这玩意。\n对编译不负责任就算了，实在偷懒可以用构建系统自带的导出符号。\n测试/例子 一个库总会有测试和例子，那问题来了，你不提供选项，内部也没处理，编译的时候还得顺带编译这一坨东西，但我最终只是想用 bin/lib/include 作为开发而已。\n依赖管理 现在的项目管理外部依赖，通常考虑集成第三方库源码在项目里或者通过包管理下载（vcpkg/conan/CPM/FetchContent etc\u0026hellip;）。\n应该有一些构建选项可以让用户选择，自行下载依赖库还是使用集成在项目里的源码。但也有例外，有些项目的 cmakelists 里没有相关逻辑去选择，会直接用 CPM/FetchContent 下载依赖，直接打满硬盘空间，这就很可怕。不过这点可以通过加硬盘处理。\n但要命的是，有时候会出现几个依赖库，本身也依赖了同一个库的情况，项目在编译链接的时候大概率报错失败，因为违反了 odr 原则，符号冲突了。不过大部分包管理也很难解决级联依赖的冲突，所以还是要要自己手工处理依赖，而依赖库可以提供选择自行下载依赖选项就好了。\nAddress Sanitizer 现在编译器已经普及了这一技术，然而很多开发者根本不知道有这玩意，或者知道了但没去开启 asan 。除了自己代码开 asan，所依赖的库最好也开启 asan 编译效果才最佳，否则有机率会出现 \u0026ldquo;假阳性\u0026rdquo;。\n未完待续 ","date":"2023-08-15T00:00:00Z","permalink":"https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx3/","title":"C++ 胡言乱语X3"},{"content":"构建系统的文档好像都有一个老毛病，就是不太适合新手去阅读（官方教程过于简短）。一些人认为文档写得很混乱，cmake/xmake/meson 都是如此，因此有了这个教程。\n新手，是指了解 c/c++ 基础的编译链接，并不是对计算机科学（用过至少一门编程语言）一无所知的萌新。\n这里还有两份教程可以互相参考。\nA Tour of xmake 一份非官方的xmake教程 xmake从入门到精通1：安装和更新 如果想看类似于 meson 的 How do I do X in Meson? 和 Frequently Asked Questions，请看另一篇文章： Xmake 常见问题解答。\nxmake 的官方交流群，可以查看文档自行添加。\n安装 这部分文档写得很清楚，在各自的平台用对应的包管理安装即可，另外使用 Windows 系统的读者需要注意两点：\n自行下载压缩包然后解压到某个目录，确保该目录没有其他东西。 曾有人解压到了软件目录，里面有其他软件，然后卸载 xmake 的时候，把其他软件也删了。\n想通过源码的方式编译安装，需要提前装好一个 xmake，因为 xmake 源码由 c + lua 组成，c 源码需要 xmake 自己编译，也就是\u0026quot;自举\u0026quot;。 打开命令行，输入xmake --version验证一下是否正确安装。\nHello world 这里先介绍怎么编译一个 hello world 工程。\n打开命令行，输入xmake create hello，用 xmake 生成自带的 hello world 模板。\n$ xmake create hello create hello ... [+]: src/main.cpp [+]: xmake.lua [+]: .gitignore create ok! 假如你已经安装好了 c/c++ 编译器（msvc/gcc/clang），我们可以直接编译运行，并看到打印出了 hello world。\n$ cd hello $ xmake $ xmake run hello world! 在 Windows 上，请不要在 git 自带的终端上执行 xmake 命令，可以选择使用 cmd 或 powershell，或者在执行 xmake 命令前，先指定目标平台：xmake f -p windows。\n在 Linux 上，xmake 默认编译器是 gcc ，Windows 则是 msvc。clang 在两个平台都可以使用，我们可以在命令行切换工具链进行编译。\n$ xmake f --toolchain=clang $ xmake $ xmake run hello world! 编码 现在最基本的编译已经完成了，但我们怎么写代码呢？这里介绍几个常用的文本编辑器。\nVisual Studio 下面命令会生成 sln 工程，点开后和平时使用 vs 写代码一样。\nxmake project -k vsxmake -m \u0026#34;debug,release\u0026#34; Visual Studio Code vscode 是 xmake 支持度最高（vscode 插件比较好开发）的编辑器，只需要安装 xmake 插件，然后挑选一个你喜欢的 intellisense 插件即可。\n假如你使用 clangd + codelldb（clangd 是语法提示/补全工具，codelldb 是调试工具），因为 xmake 插件默认在 .vscode 目录下生成 compile_commands.json，那么只要在.vscode/settings.json写下：\n{ \u0026#34;clangd.arguments\u0026#34;: [ \u0026#34;--compile-commands-dir=.vscode\u0026#34;, ], \u0026#34;xmake.debugConfigType\u0026#34;: \u0026#34;codelldb\u0026#34;, } 这时候点开 src/main.cpp 文件，clangd 会自动运行，vscode 算是配置完成了，是不是很简单。\n如果想用 cpptools（微软的 c++ 插件），请参考文档\n官方演示视频：\nhttps://www.bilibili.com/video/BV1sF411E7DA https://www.youtube.com/watch?v=yAYYuXmPXPc Clion 目前来说，clion 的 xmake 插件是不可用状态，只能靠生成 cmakelists 来支持 clion。\nxmake project -k cmakelists 其他 没介绍的文本编辑器请看文档。此外，一个小众的国产 c/c++ 编辑器 edx 也支持了 xmake，可以玩玩。\nHello world 模板解析 部署了开发环境，回顾一下刚刚的生成的 xmake.lua。\nadd_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) target(\u0026#34;hello\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;src/*.cpp\u0026#34;) 工程需要至少一种构建类型（build type），常见的有 debug/release，可以通过xmake f -m \u0026lt;build type\u0026gt;切换构建类型。\nadd_rules(\u0026quot;mode.debug\u0026quot;, \u0026quot;mode.release\u0026quot;)使用了 xmake 内置的编译参数，也就是说，xmake 帮我们写好了这些代码。\nif is_mode(\u0026#34;debug\u0026#34;) then set_symbols(\u0026#34;debug\u0026#34;) set_optimize(\u0026#34;none\u0026#34;) elseif is_mode(\u0026#34;release\u0026#34;) then set_symbols(\u0026#34;hidden\u0026#34;) set_optimize(\u0026#34;fastest\u0026#34;) set_strip(\u0026#34;all\u0026#34;) add_cxflags(\u0026#34;-DNDEBUG\u0026#34;) end 通过判断构建类型，设置了不同的参数。\nsymbols -\u0026gt; 设置生成符号信息，这样才可以调试我们的程序，hidden 表示符号不可见。 optimize -\u0026gt; 优化等级（等级越高，程序运行越快），none 表示不需要优化。 strip -\u0026gt; 去掉符号，all 表示链接的时候，strip 掉所有符号，包括调试符号。 cxflags -\u0026gt; 给 c/c++ 添加编译选项，-DNDEBUG就是塞了一个NDEBUG宏 除了构建类型，工程还需要至少一个构建目标（target），target(\u0026quot;hello\u0026quot;)代表新建一个目标，并命名为 hello。后面所有的设置，都只会对这个目标生效。目标类型可以是静态库（static），也可以是动态库（shared），当然最常见的是可执行程序（binary），对应上面的 xmake.lua 就是set_kind(\u0026quot;binary\u0026quot;)。\n除了上面这三种类型，set_kind 还支持 phony/object/headeronly 类型。\nadd_files 是一个很强大的接口，这里只简单介绍，详细可以去看文档。\n*是通配符，可以根据文件后缀匹配一批符合要求的文件。\n* -\u0026gt; 在目录内添加文件。假如 src 目录下有 hello.cpp 和 world.cpp 文件，add_files(\u0026quot;src/*.cpp\u0026quot;)只会把 hello.cpp 和 world.cpp 添加进去。 - src - hello.cpp - world.cpp - xmake.lua - main.cpp ** -\u0026gt; 递归目录添加文件。假如 src 目录下有 hello.cpp，src 目录下还有一个 tmp 目录，里面有一个 world.cpp 文件，add_files(\u0026quot;src/**.cpp\u0026quot;)还是只会把 hello.cpp 和 world.cpp 添加进去。 - src - hello.cpp - tmp - world.cpp - xmake.lua - main.cpp 命令行解析 在上面我们用到了许多命令，比如xmake f -m debug，其实完整命令如下：\nxmake config --mode=debug 一个工程需要先配置（config）后构建（build），在新工程中，直接执行xmake命令，代表使用默认配置直接构建。\nxmake --help可以输出 xmake 的命令行操作。\nxmake v2.7.9+HEAD.c87922676, A cross-platform build utility based on Lua Copyright (C) 2015-present Ruki Wang, tboox.org, xmake.io _ __ ___ __ __ __ _| | ______ \\ \\/ / | \\/ |/ _ | |/ / __ \\ \u0026gt; \u0026lt; | \\__/ | /_| | \u0026lt; ___/ /_/\\_\\_|_| |_|\\__ \\|_|\\_\\____| by ruki, xmake.io 👉 Manual: https://xmake.io/#/getting_started 🙏 Donate: https://xmake.io/#/sponsor Usage: $xmake [task] [options] [target] Build targets if no given tasks. Actions: b, build Build targets if no given tasks. u, uninstall Uninstall the project binary files. i, install Package and install the target binary files. q, require Install and update required packages. p, package Package target. c, clean Remove all binary and temporary files. f, config Configure the project. service Start service for remote or distributed compilation and etc. update Update and uninstall the xmake program. r, run Run the project target. create Create a new project. g, global Configure the global options for xmake. ... 在 Actions 中，最常用的是config/build/run。输入xmake config --help，则会打印子选项更多操作。\n本文大多数命令使用简写。\n通用操作 -h|--help -\u0026gt; 帮助信息。 -v|--verbose -\u0026gt; 输出更多的信息。在构建时使用这个命令，可以看到 xmake 调用编译器的每一步。 -D|--diagnosis -\u0026gt; 通常用于调试 xmake 本身。 这些简写通常可以合并在一起操作，比如xmake -vD。\naction 常用操作 xmake f -c -\u0026gt; 清除当前 xmake 工程的缓存。当你遇到了无法解决的问题，可以先来一发这个命令。 xmake f -p mingw -\u0026gt; 指定构建目标平台。在 Windows 系统上默认平台是 windows，想要在 mingw/msys2 平台编译，需要手动切换。 xmake f -P ../projectdir -o ../build -\u0026gt; 把工作目录和构建目录放在其他地方。保持源码目录整洁，适合洁癖。 - build (generated) - workdir - .xmake (generated) - projectdir - src - xmake.lua xmake build -r -\u0026gt; 重新编译整个工程，xmake build -r target则是重新编译指定 target。 xmake build -j4 -\u0026gt; xmake 默认多线程（根据 cpu 核心数）编译跑满 CPU 所有核心，-j4调整并行编译任务数，。 当工程 config 后，xmake -r和xmake -j4和上面是完全等价的。\nxmake run -d target -\u0026gt; 启动调试器调试指定 target。 包管理 xmake 的包管理十分强大，除了自动下载依赖库源码编译安装，还可以使用其他包管理的库。\n包可以分类为系统库和非系统库，系统库是最稳定的，但基本是版本固定的预编译二进制，不太灵活。而非系统库直接拉取源码编译，可以最大化自定义操作（比如调整编译参数、只启用包的某个组件等）。\n使用 修改一下 hello world 模板。这里使用了一个比较知名的库（已经加入了 c++20 标准库）。\nadd_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) add_requires(\u0026#34;fmt\u0026#34;) target(\u0026#34;hello\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;src/*.cpp\u0026#34;) add_packages(\u0026#34;fmt\u0026#34;) 引入 fmt 库就这么简单，只需要add_requires和add_packages。然后执行：\nxmake f -y xmake 如果不使用-y，那么下载依赖的时候需要手动确认。\n依赖下载在 config 阶段，只有正确编译测试包才算成功安装。如果想知道下载编译安装的全过程，可以使用xmake f -vD。\n由于不可描述原因，源码可能会下载失败，请根据文档为 xmake 挂上代理。\n系统库 系统库通常都是从系统官方包管理（apt/pacman/homebrew）下载的包。默认情况下 xmake 会先去找系统库，如果没有才下载远程包，基本上只有在非 Windows 平台才需要考虑是否使用系统库，我们也可以通过add_requires传入参数强制 xmake 使用系统库。\nadd_requires(\u0026#34;zlib\u0026#34;, {system = true}) 我们也可以直接指定想用的系统包。\nadd_requires(\u0026#34;brew::zlib\u0026#34;, {alias = \u0026#34;zlib\u0026#34;}) add_requires(\u0026#34;pacman::zlib\u0026#34;, {alias = \u0026#34;zlib\u0026#34;}) add_requires(\u0026#34;pkgconfig::zlib\u0026#34;, {alias = \u0026#34;zlib\u0026#34;}) -- 第三方包管理 add_requires(\u0026#34;vcpkg::zlib\u0026#34;, {alias = \u0026#34;zlib\u0026#34;}) add_requires(\u0026#34;conan::zlib\u0026#34;, {alias = \u0026#34;zlib\u0026#34;}) 设置了 alias，我们只需要add_packages(\u0026quot;zlib\u0026quot;)而不是add_packages(\u0026quot;brew::zlib\u0026quot;)。\n在 Windows 平台，有些库需要使用它的预编译二进制进行开发，如 cuda/vulkansdk/qt。执行xmake f -h，可以看到 qt 和 cuda 是可配置选项，可以直接用xmake f --qt=或者xmake f --cuda=指定 sdk 目录。\n但选项中没有 vulkansdk，因为 cuda/qt 是 c++ 大生态的一部分，xmake 内部都对此做了支持。这种情况下，执行xrepo search vulkansdk查找包。如果搜索结果显示有这个包，那就和上面引入 fmt 库操作一样。\nxrepo search \u0026lt;package\u0026gt; 基于包名和包描述模糊搜索，如果想用的包搜不到，大概率是 xmake 官方还没有支持这个库，可以尝试提 pull request 贡献或者 feature request 的 issue。\n如果显示安装vulkansdk失败，可以去提 issue 或者自行排除错误。因为 Windows 平台上的系统包通常都是基于环境变量和注册表来查找 sdk 目录，然后提取头文件和库目录。这些环境变量和注册表时在官方安装器安装时设置的，如果下载的是便携版（压缩包解压开箱即用），那么需要自己去设置环境变量等操作。\nxrepo 是 xmake 包管理的名字，类似于 meson 的 wrap。如果你查看 xrepo 的脚本，发现实质上还是调用 xmake。\n非系统库（远程依赖） xmake-repo 是 xmake 的官方包管理仓库，上面存放的是各种包的编译脚本。\n大多数包是从 github 上下载，其他包管理也是这么做。 大多数包都是下载源码本地编译安装，小部分是下载预编译二进制。如果在 config 阶段卡住了，那基本上都是卡在编译阶段。 需要编译的包，大多数是用库自己的构建系统（cmake/meson/makefile）来进行构建，然后把 bin/lib/include 安装到 xmake 指定的位置，这像是包了一层胶水。如果库构建失败，xmake-repo 的打包者则会尝试使用 xmake 来构建此库。 包的存放路径可以执行xmake show查看packagedir，基本上都是按这种规范存放： - f - fmt - version - hash - bin -\u0026gt; .dll/.exe - lib -\u0026gt; .lib/.a - include -\u0026gt; .h/.hpp 可以通过改变 xmake 的环境变量来切换包的存放路径。 xmake 支持改变包的编译配置。比如包默认是静态库，我们可以传入 configs 使其编译成动态库。\nadd_requires(\u0026#34;zlib\u0026#34;, {configs = {shared = true}}) 我们还可以传入 debug/pic/lto/vs_runtime 等 configs，这些都是 xmake 内置的 configs。\n而在 c/c++ 生态中，每个包都会有自己的编译选项。fmt 是一个头文件库，他支持非头文件的方式编译，那么可以传入对应 configs 来编译成动态库。\nadd_requires(\u0026#34;fmt\u0026#34;, {configs = {header_only = false, shared = true}}) 正因为包可以用不同 configs 来编译，所以 xmake 会对这些 configs 生成唯一 hash，这也是为什么同一个包同一个版本，还会有多个编译产物。\n想了解对应包更多的 configs 选项，执行xrepo info \u0026lt;package\u0026gt;。\n其他 xmake 的包管理还有许多功能，比如指定包的不同版本，版本可以精确到 git tag/branch/commit，还有适合内部开发的自建包仓库，更多功能可以看这篇文章：Xmake 和 C/C++ 包管理。\n编写 xmake.lua 在介绍完一些基础的操作后，本文开始讲解各种基础用法。\n规范 xmake.lua 基于 lua 编程语言，所有语句必须符合 lua 的语法。\n正如其他构建系统一样，文档上各种 api 其实就是 xmake 自定义的 dsl(Domain-specific language)，方便用户使用。虽然有很多人讨厌 lua，但实际上，我们有 80% 的时间在使用 xmake 的 dsl 写描述文件，20% 的时间才可能用到 lua 进行编程。\n如果有 xmake 的 dsl 不能完成的操作，我们完全可以退化到用 lua 来完成，对比使用其他构建系统的 dsl 进行编程，lua 写起来不至于那么讨厌了。\nxmake 的 api 基于官方指定的命名规范，非常容易理解，比如接口末尾有s代表可以传入至少两个参数。\n作用域 假设我们的工程目录长这样：\n- demo - include - base.hpp - src - base - base.cpp - sandbox - main.cpp - xmake.lua 编写对应的 xmake.lua。\nadd_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) add_requires(\u0026#34;fmt\u0026#34;) add_includedirs(\u0026#34;include\u0026#34;) target(\u0026#34;base\u0026#34;) set_kind(\u0026#34;static\u0026#34;) add_files(\u0026#34;src/base/*.cpp\u0026#34;) target(\u0026#34;sandbox\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;src/sandbox/*.cpp\u0026#34;) add_packages(\u0026#34;fmt\u0026#34;) 相比 hello world 模板，我们使用了add_includedirs来添加头文件的目录，并声明了两个 target，其中一个 target 类型是静态库，另一个是可执行程序。\n在 base.cpp 编码的时候，你会发现引用不了 fmt 头文件，上面讲过：\n声明新目标后，后面所有的设置都只会对这个目标生效。\n在这里修正一下：声明新目标后，我们就进入了该目标的描述域，所有的设置只会对这个 target 生效。\n那在 target 之外就是全局作用域了。\n把add_packages(\u0026quot;fmt\u0026quot;)放在add_requires(\u0026quot;fmt\u0026quot;)语句后面，也就是放到全局作用域，为所有 target 都添加了 fmt 的依赖，就能在任何 cpp 文件引用 fmt 头文件了。\nadd_requires(\u0026#34;fmt\u0026#34;) -- 在全局作用域设置 add_packages(\u0026#34;fmt\u0026#34;) add_includedirs(\u0026#34;include\u0026#34;) add_rules和add_includedirs这些接口同理，所以所有 target 都享受到了同样的配置，都能引用 base.hpp 这个头文件。\n多级配置 修改一下工程。\n- demo - include - base.hpp - src - base - base.cpp - xmake.lua - sandbox - main.cpp - xmake.lua - xmake.lua 编写对应的 xmake.lua。\ndemo/xmake.lua add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) add_requires(\u0026#34;fmt\u0026#34;) add_includedirs(\u0026#34;include\u0026#34;) includes(\u0026#34;src/base\u0026#34;, \u0026#34;src/sandbox\u0026#34;) demo/src/base/xmake.lua target(\u0026#34;base\u0026#34;) set_kind(\u0026#34;static\u0026#34;) add_files(\u0026#34;*.cpp\u0026#34;) demo/src/sandbox/xmake.lua add_packages(\u0026#34;fmt\u0026#34;) target(\u0026#34;sandbox\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;*.cpp\u0026#34;) 我们使用了一个新接口includes，这个接口可以添加 xmake 的 lua 脚本，也可以添加 xmake 的子配置文件（文件名必须为xmake.lua）。同时我们写了两个 xmake.lua，这样就可以模块化描述工程。因为add_files是基于配置文件的位置来转换文件路径，所以直接用*.cpp匹配当前 xmake.lua 目录内的文件。\n在 base.cpp 编码的时候，你会发现又引用不了 fmt 头文件。这是因为add_packages(\u0026quot;fmt\u0026quot;)只配置了demo/src/sandbox/xmake.lua内的 target，也就是说，只是个局部配置。\n但 base 和 sandbox 依然享受到了add_rules(\u0026quot;mode.debug\u0026quot;, \u0026quot;mode.release\u0026quot;)和add_includedirs(\u0026quot;include\u0026quot;)的配置，这是因为两个子配置文件继承了根配置文件的配置。\n由于作用域的限定，子配置文件只能继承了根配置文件中全局作用域里的配置。\n这类似于一颗多叉树，根节点的配置可以传播给叶节点，但叶节点的配置只能自己用或者继续向下传播，无法向上传播。\nxmake.lua / \\ base/xmake.lua sandbox/xmake.lua 目标依赖 保持工程目录，修改 xmake.lua。\ndemo/xmake.lua add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) includes(\u0026#34;src/base\u0026#34;, \u0026#34;src/sandbox\u0026#34;) demo/src/base/xmake.lua target(\u0026#34;base\u0026#34;) set_kind(\u0026#34;static\u0026#34;) add_includedirs(\u0026#34;include\u0026#34;, {public = true}) add_files(\u0026#34;*.cpp\u0026#34;) demo/src/sandbox/xmake.lua target(\u0026#34;sandbox\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;*.cpp\u0026#34;) add_deps(\u0026#34;base\u0026#34;) 我们使用add_deps显示指定依赖的 target，这样在构建工程会先构建 base 然后构建 sandbox。\n注意，不同 target 内部的 c/c++ 文件还是并行编译的，即使他们有依赖关系。因为 c/c++ 编译流程为：\n预处理 -\u0026gt; 中间对象 -\u0026gt; 链接 所以 target 只有在链接的时候才会有依赖关系（如果有特殊情况，target 不能参与并行编译，为该 target 设置set_policy(\u0026quot;build.across_targets_in_parallel\u0026quot;, false)）。\ntarget 设置的编译链接相关的 api，还会有一个属性（private/interface/public）。\napi 默认 private 属性，也就是说设置的配置仅供自己使用。interface 反过来，只能给下游依赖了自己的 target 使用。\n而public == private + interface，自己和下游依赖都能用。\n因为 base 的add_includedirs设置了public = true，所以 base 和 sandbox 内的 cpp 文件，都可以引用来自 base 的头文件 base.hpp。\n脚本域 上面讲了那么多，基本上可以应付一些小型项目了。如果有更复杂的需求，就需要到脚本域里干活（也就是说，平时都是在描述域干活）。\n因为 xmake 的特性，描述域的代码需要被扫描多次，而脚本域的代码只会被执行一次。执行xmake f -c，可以看见 world 只被打印一次。\nprint(\u0026#34;hello\u0026#34;) target(\u0026#34;test\u0026#34;) on_load(function (target) print(\u0026#34;world\u0026#34;) end) print 是 xmake 最强大的调试手段。\n在描述域，我们使用 xmake api 添加了各种配置，但有一些 api 只能在脚本域运行，比如在脚本域获取描述域中（任何 add/set api）设置的配置和执行 ls 命令。\ntarget(\u0026#34;test\u0026#34;) add_cxflags(\u0026#34;-O3\u0026#34;) add_defines(\u0026#34;Win32\u0026#34;) on_load(function (target) print(target:get(\u0026#34;cxflags\u0026#34;)) print(target:get(\u0026#34;defines\u0026#34;)) os.vrun(\u0026#34;ls\u0026#34;) end) 如果在描述域使用 os.vrun 会直接报错，只有少部分接口（例如 print）才能在描述域和全局作用域使用。\non_load只是编写脚本域代码的其中一处，我们还可以在下面每一步编写对应脚本。\non_load -\u0026gt; after_load -\u0026gt; on_config -\u0026gt; before_build -\u0026gt; on_build -\u0026gt; after_build on_config 在xmake config执行后，before_build执行前的时候运行。 如果是 c/c++ 程序，还可以在[before|on|after]_link编写脚本。 自定义on_[build|link]会覆盖 xmake 内置的脚本。 不同构建阶段的脚本基本上可以满足各种定制化需求。\n规则 规则是 xmake 最强大的工具之一，你可以做到：\n给不同 target 应用不同的构建参数。 和add_rules(\u0026quot;mode.debug\u0026quot;, \u0026quot;mode.release\u0026quot;)一样定制编译参数。\nrule(\u0026#34;module\u0026#34;) on_load(function (target) if target:name() == \u0026#34;main\u0026#34; then target:add(\u0026#34;packages\u0026#34;, \u0026#34;fmt\u0026#34;) end local is_test = target:extraconf(\u0026#34;rules\u0026#34;, \u0026#34;module\u0026#34;, \u0026#34;test\u0026#34;) if is_test then target:add(\u0026#34;cxflags\u0026#34;, \u0026#34;-fsanitize=address\u0026#34;) target:add(\u0026#34;ldflags\u0026#34;, \u0026#34;-fsanitize=address\u0026#34;) end end) target(\u0026#34;main\u0026#34;) add_rules(\u0026#34;module\u0026#34;) target(\u0026#34;test\u0026#34;) add_rules(\u0026#34;module\u0026#34;, {test = true}) 我们可以通过判断 target 名字是否添加 fmt 包，也可以直接传入配置来判断是该 target 是否需要启用 asan，非常灵活。\n构建非 c/c++ 编译产物，比如使用 typst 生成 pdf，只需要下面几十行代码。 工程目录。\n- src - resume-zh.typ - xmake.lua xmake.lua\nrule(\u0026#34;typst\u0026#34;) set_extensions(\u0026#34;.typ\u0026#34;) on_load(function (target) -- 设置输出文件目录 target:set(\u0026#34;targetdir\u0026#34;, path.join(\u0026#34;build\u0026#34;, \u0026#34;pdf\u0026#34;)) end) on_build_file(function (target, sourcefile, opt) -- 导入模块 import(\u0026#34;lib.detect.find_tool\u0026#34;) import(\u0026#34;core.project.depend\u0026#34;) import(\u0026#34;utils.progress\u0026#34;) -- 创建输出文件目录 os.mkdir(target:targetdir()) -- 找到编译器 local typst = assert(find_tool(\u0026#34;typst\u0026#34;, {version = true}), \u0026#34;typst not found\u0026#34;) -- 拼接输出文件路径 local targetfile = path.join(target:targetdir(), path.basename(sourcefile) .. \u0026#34;.pdf\u0026#34;) -- 一个封装好的函数，当源文件修改就会重新构建 depend.on_changed(function () os.vrunv(typst.program, {\u0026#34;compile\u0026#34;, sourcefile, targetfile}) progress.show(opt.progress, \u0026#34;${color.build.object}compiling %s\u0026#34;, sourcefile) end, {files = sourcefile}) end) target(\u0026#34;resume\u0026#34;) set_kind(\u0026#34;object\u0026#34;) add_rules(\u0026#34;typst\u0026#34;) add_files(\u0026#34;src/resume-zh.typ\u0026#34;) 和平常一样执行xmake，就可以得到我们的 pdf 文件。\n[ 33%]: compiling src/resume-zh.typ [100%]: build ok, spent 0.281s 如果没找到编译器，assert 会失败，需要参考文档进一步学习find_tool的用法。\n调试 获取 xmake 和 xmake-repo 最新版。\nxmake update -s dev xrepo update-repo 清理全局/工程缓存。\nxmake g -c xmake f -c 上面是最基础的调试手段，下面介绍一些需要人工辅助的方法。\nprint大法。 print无论在配置文件哪里都可以使用，cprint还可以输出有颜色的 log。除此之外还可以使用assert和raise。\n输出调用各种工具操作，编译的详细参数，如果出错还会打印 xmake 的栈回溯。 xmake -vD 如果要给 xmake 提 issue 报 bug，请务必使用该命令生成 log 提交上去。\n可以显示指定 target 配置信息，可以看到各种配置来源于哪个配置文件和具体的行数。 xmake show -t \u0026lt;target\u0026gt; 检查工程配置和代码。 $ xmake check # 调用 clang-tidy 检测代码 $ xmake check clang.tidy 因为 xmake 基本上都是依靠字符串传递各种配置，如果打错参数名（typo）就会导致xmake config失败。这个 xmake 插件能检测到 typo （基于 Levenshtein Distance 算法），也能检测各种通过add_xxx接口添加的文件/目录，是否匹配文件成功。\nxmake 还有很多有用的插件，多多尝试使用。\n可能的最佳实践 一个完整的项目，目录结构可能长这样：\n- src - xmake - rule - module.lua - option.lua - package.lua - xmake.lua - test - xmake.lua - test1.cpp - test2.cpp - xmake.lua 对应的部分配置：\nxmake.lua\nset_project(\u0026#34;name\u0026#34;) set_version(\u0026#34;0.0.1\u0026#34;) set_xmakever(\u0026#34;2.7.9\u0026#34;) set_warnings(\u0026#34;all\u0026#34;) set_languages(\u0026#34;c++20\u0026#34;) set_allowedplats(\u0026#34;windows\u0026#34;, \u0026#34;linux\u0026#34;, \u0026#34;macosx\u0026#34;) includes(\u0026#34;test\u0026#34;, \u0026#34;src\u0026#34;, \u0026#34;xmake\u0026#34;) xmake/xmake.lua\nincludes(\u0026#34;option.lua\u0026#34;) includes(\u0026#34;package.lua\u0026#34;) includes(\u0026#34;rule/module.lua\u0026#34;) xmake/option.lua\noption(\u0026#34;test\u0026#34;, {default = false, showmenu = true, description = \u0026#34;Enable test\u0026#34;}) option(\u0026#34;feature\u0026#34;, {default = false, showmenu = true, description = \u0026#34;Enable feature\u0026#34;}) 可以把构建选项集中在一起（选项在xmake config的时候传递--test=[y/n]启用或关闭）。\nxmake/package.lua\nadd_requires(\u0026#34;fmt\u0026#34;) if has_config(\u0026#34;test\u0026#34;) then add_requires(\u0026#34;gtest\u0026#34;) end gtest 库只有在 test 选项启用后才会安装。\n单元测试 xmake 官方不支持单元测试，相关讨论。\n可以参考下面这个单元测试模板。\nxmake/rule/module.lua\nrule(\u0026#34;module.test\u0026#34;) on_load(function (target) -- 没有开启 test 选项，就关闭 target if not has_config(\u0026#34;test\u0026#34;) then target:set(\u0026#34;enabled\u0026#34;, false) return end -- 运行目录修改为根目录 target:set(\u0026#34;rundir\u0026#34;, os.projectdir()) -- 添加测试组 target:set(\u0026#34;group\u0026#34;, \u0026#34;test\u0026#34;) -- 选择你想要的单元测试库 target:add(\u0026#34;packages\u0026#34;, \u0026#34;gtest\u0026#34;) end) test/xmake.lua\nadd_rules(\u0026#34;module.test\u0026#34;) -- 假设 test 目录下每个 cpp 文件都有自己的 main 函数 for _, file in ipairs(os.files(\u0026#34;*.cpp\u0026#34;)) do local name = path.basename(file) target(\u0026#34;test.\u0026#34; .. name) set_kind(\u0026#34;binary\u0026#34;) add_files(file) target_end() end 首先写了一个名叫module.test的 rule，这是给测试 target 添加编译参数。然后使用os.files收集文件，遍历目录获取指定文件并生成 target。\n然后我们执行命令开启 test 选项并指定 test 组编译运行：\nxmake f -m debug --test=y xmake build -g test xmake run -g test 如果想一行xmake test命令搞定，可以使用task。\ntask(\u0026#34;test\u0026#34;) on_run(function () os.exec(\u0026#34;xmake f -m debug --test=y\u0026#34;) os.exec(\u0026#34;xmake build -g test\u0026#34;) os.exec(\u0026#34;xmake run -g test\u0026#34;) end) set_menu{} 库 假如你要写一个库，给别人调用或者自己使用。\n因为 xmake 没有类似 c++ namespace 的特性，可能 target/rule/option\u0026hellip; 与自己的定义的名字发生冲突。而 xmake 有自己的包管理，只要贡献到 xmake-repo 别人就能使用，所以不推荐使用includes集成库。\ninclude 需要安装的头文件，使用add_headerfiles。\n-- 保留头文件目录结构 add_headerfiles(\u0026#34;include/(**.h)\u0026#34;) -- 丢弃文件目录结构，所有头文件都放在 include 目录 add_headerfiles(\u0026#34;include/**.h\u0026#34;) lib 基于 build.merge_archive，对某个 target 使用set_policy(\u0026quot;build.merge_archive\u0026quot;, true)，可以自动合并依赖的所有静态库。这样在发布的时候可以只安装一个静态库。\nbin 在 Windows 上编译动态库，但又不想自己导出符号，可以使用add_rules(\u0026quot;utils.symbols.export_all\u0026quot;)自动导出所有符号（如果是 c++ 库还要给该规则传递参数{export_classes = true}）。\n如果需要安装其他文件，比如文档，使用add_installfiles(\u0026quot;doc/*.md\u0026quot;, {prefixdir = \u0026quot;share/doc\u0026quot;})。 导出该库给其他构建系统交互。 add_rules(\u0026#34;utils.install.cmake_importfiles\u0026#34;) add_rules(\u0026#34;utils.install.pkgconfig_importfiles\u0026#34;) 想把这个库提交到 xmake-repo 上，还需要写对应的包描述脚本，这里只能参考文档和 xmake-repo 上其他包。 软件 如果要发布一个软件，基本上都要重写on_install脚本。\n因为不需要安装头文件，配置add_headerfiles(\u0026quot;src/xxx.h\u0026quot;, {install = false})。因为add_headerfiles这个接口不止用来安装头文件，还可以用作 ide 的工程目录显示（也就是说，如果不使用add_headerfiles，ide 工程目录只会显示源文件）。 xmake 内部封装了常用的压缩工具，在on_install最后一步可以把所有文件打包成压缩包。 如果想用 upx 压缩也很简单。\nrule(\u0026#34;module.program\u0026#34;) after_build(function (target) -- 判断是否使用 upx local enabled = target:extraconf(\u0026#34;rules\u0026#34;, \u0026#34;module.program\u0026#34;, \u0026#34;upx\u0026#34;) if not enabled or target:kind() ~= \u0026#34;binary\u0026#34; then return end local upx = assert(import(\u0026#34;lib.detect.find_tool\u0026#34;)(\u0026#34;upx\u0026#34;), \u0026#34;upx not found!\u0026#34;) -- 生成在 build 目录里 local file = path.join(\u0026#34;build\u0026#34;, path.filename(target:targetfile())) os.tryrm(file) os.vrunv(upx.program, {target:targetfile(), \u0026#34;-o\u0026#34;, file}) end) 使用：\ntarget(\u0026#34;main\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_rules(\u0026#34;module.program\u0026#34;, {upx = true}) add_files(\u0026#34;*.cpp\u0026#34;) 我们可以进一步优化这个 rule。\nrule(\u0026#34;module.program\u0026#34;) on_load(function (target) target:set(\u0026#34;kind\u0026#34;, \u0026#34;binary\u0026#34;) end) after_build(function (target) local enabled = target:extraconf(\u0026#34;rules\u0026#34;, \u0026#34;module.program\u0026#34;, \u0026#34;upx\u0026#34;) if (not enabled) or (not is_mode(\u0026#34;release\u0026#34;)) then return end import(\u0026#34;core.project.depend\u0026#34;) import(\u0026#34;lib.detect.find_tool\u0026#34;) local targetfile = target:targetfile() depend.on_changed(function () local file = path.join(\u0026#34;build\u0026#34;, path.filename(targetfile)) local upx = assert(find_tool(\u0026#34;upx\u0026#34;), \u0026#34;upx not found!\u0026#34;) os.tryrm(file) os.vrunv(upx.program, {targetfile, \u0026#34;-o\u0026#34;, file}) end, {files = targetfile}) end) target(\u0026#34;main\u0026#34;) add_rules(\u0026#34;module.program\u0026#34;, {upx = true}) add_files(\u0026#34;*.cpp\u0026#34;) 在 target 的描述域中，set_kind也不需要写了。通过 depend.on_changed 接口，判断依赖文件的修改时间，避免每次重新构建。\n","date":"2023-06-30T00:00:00Z","permalink":"https://star-hengxing.github.io/p/xmake-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/","title":"Xmake 新手教程"},{"content":"如果在本文没找到解答，可以去 github 提 issue 和讨论区搜索。\n如果是官方包管理的问题，或者想请求加入一些包，去 xmake-repo 提 issue。\n提 issue 请附带 log，xmake -vD命令可以输出详细的 log 信息。\n基础 避免外网访问 xmake 很多操作需要访问 github（拉取 xmake-repo/build-artifact），而在公司内网开发是不需要这些操作的。\nxmake g --network=private 参考：\nhttps://github.com/xmake-io/xmake/issues/947 Windows 上 Qt 项目控制台没有输出 使用：\nadd_ldflags(\u0026#34;/subsystem:console\u0026#34;) xmake 的 qt rule 里会检测 ldflags 里有没有/subsystem，如果没有就默认/subsystem:windows。\n给单独源文件添加参数 add_files(\u0026#34;test/*.c\u0026#34;, \u0026#34;test2/test2.c\u0026#34;, {defines = \u0026#34;TEST2\u0026#34;, languages = \u0026#34;c99\u0026#34;, includedirs = \u0026#34;.\u0026#34;, cflags = \u0026#34;-O0\u0026#34;}) -- 强制禁用 cxflags,cflags 等编译选项的自动检测 add_files(\u0026#34;src/*.c\u0026#34;, {force = {cxflags = \u0026#34;-DTEST\u0026#34;, mflags = \u0026#34;-framework xxx\u0026#34;}}) 给指定文件添加 config target(\u0026#34;test\u0026#34;) add_files(\u0026#34;test/*.cpp\u0026#34;, {foo = 1}) on_config(function (target) -- configs = {foo = 1} local configs = target:fileconfig(\u0026#34;src/main.cpp\u0026#34;) end) 找不到 vs 工具链 在 Visual Studio Installer 修改了配置后，清除全局缓存。\nxmake g -c xmake f -c 参考：\n显示找不到 Microsoft Visual Studio (x64) version https://github.com/xmake-io/xmake/issues/770 https://github.com/xmake-io/xmake/discussions/3785 xmake can not find visual studio XMake无法自动发现MSVC编译工具 指定 vs 版本 xmake f --vs=2017 --vs_toolset=14.0 --vs_sdkver=10.0.15063.0 IDE(vscode/vs)不显示头文件 给 target 加上add_headerfiles(\u0026quot;**.h\u0026quot;)\n终端不支持色彩输出 切换主题。\nxmake g --theme=plain 如何在脚本域添加文件 只能在on_load添加，并且需要确保路径正确。\n因为描述域的add_files()和脚本域的target:add(\u0026quot;files\u0026quot;)有一些差异，并不会做路径转换。\n后者接口可能会在任何地方使用，所以路径只能用os.projectdir或者os.scriptdir进行拼接路径。\n此外，需要确保该 target 已经应用了一个编译规则，否则不会根据后缀名去添加文件（可能会出现error: unknown source file: xxx.cpp）。\n比如你在脚本域添加 .cpp 文件，那么首先在描述域添加add_rules(\u0026quot;c++\u0026quot;)。\n增量配置 假如我们做以下操作：\nxmake f -m debug --test=y xmake f --test=n 你会发现当前mode又切换了为默认配置的release。\nxmake 暂时没有支持增量配置，这里有过相关讨论。\n但我们也有解决的方法，使用SirLynix写的插件。\nxmake plugin --install https://github.com/SirLynix/xmake-plugins 用xmake config-update或者xmake cu代替原来的xmake config或者xmake f。\n在不同脚本域之间传递数据 memcache target(\u0026#34;foo\u0026#34;) on_load(function (target) import(\u0026#34;core.cache.memcache\u0026#34;) memcache.set(\u0026#34;cachename\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) end) target(\u0026#34;bar\u0026#34;) on_load(function (target) import(\u0026#34;core.cache.memcache\u0026#34;) local memcache.get(\u0026#34;cachename\u0026#34;, \u0026#34;key\u0026#34;) end) target:data() target(\u0026#34;foo\u0026#34;) on_load(function (target) target:data_set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) end) target(\u0026#34;bar\u0026#34;) on_load(function (target) import(\u0026#34;core.project.project\u0026#34;) local foo = project.targets()[\u0026#34;foo\u0026#34;] local value = foo:data(\u0026#34;key\u0026#34;) end) 单个脚本文件 target(\u0026#34;foo\u0026#34;) on_load(function (target) import(\u0026#34;load_module\u0026#34;).load_foo(target) end) target(\u0026#34;bar\u0026#34;) on_load(function (target) import(\u0026#34;load_module\u0026#34;).load_bar(target) end) load_module.lua\nfunction load_foo(target) _g.key = \u0026#34;value\u0026#34; end function load_bar(target) local value = _g.key end 参考：\nhttps://github.com/orgs/xmake-io/discussions/3926 自动化 如何一键编译运行 在 target 下加入以下代码：\nbefore_run(function (target) os.execv(\u0026#34;xmake build \u0026#34; .. target:name()) end) -- xmake run target vs 工程 自动更新 sln。 add_rules(\u0026#34;plugin.vsxmake.autoupdate\u0026#34;) 使用add_filegroups可以打平嵌套过深的目录树，可读性更高。 单元测试 xmake 官方不支持单元测试，这里有过相关讨论。\n但自己写一个也很简单，下面是一个参考：\nrule(\u0026#34;module.test\u0026#34;) on_load(function (target) if not has_config(\u0026#34;test\u0026#34;) then target:set(\u0026#34;enabled\u0026#34;, false) return end target:set(\u0026#34;policy\u0026#34;, \u0026#34;build.warning\u0026#34;, true) target:set(\u0026#34;rundir\u0026#34;, \u0026#34;$(projectdir)\u0026#34;) target:set(\u0026#34;group\u0026#34;, \u0026#34;test\u0026#34;) -- 选择你想要的单元测试库 target:add(\u0026#34;packages\u0026#34;, \u0026#34;gtest\u0026#34;) end) rule_end() add_rules(\u0026#34;module.test\u0026#34;) -- 假设 test 目录下每个 cpp 文件都有自己的 main 函数 for _, file in ipairs(os.files(\u0026#34;test/*.cpp\u0026#34;)) do local name = path.basename(file) target(\u0026#34;test.\u0026#34; .. name) set_kind(\u0026#34;binary\u0026#34;) add_files(file) target_end() end 然后我们使用下面命令：\nxmake f -m debug --test=y xmake build -g test xmake run -g test 如果想一行xmake test命令搞定，使用task。\ntask(\u0026#34;test\u0026#34;) on_run(function () os.exec(\u0026#34;xmake f -m debug --test=y\u0026#34;) os.exec(\u0026#34;xmake build -g test\u0026#34;) os.exec(\u0026#34;xmake run -g test\u0026#34;) end) set_menu{} 自定义检测行为 xmake 在检测各种工具、配置等等信息时都会有缓存，我们可以自定义一个检测行为并对其缓存。\non_config(function (target) import(\u0026#34;core.cache.detectcache\u0026#34;) local has_deprecated_key = \u0026#34;custom.has_deprecated\u0026#34; local has_deprecated = detectcache:get(has_deprecated_key) if not has_deprecated then has_deprecated = target:check_csnippets({ has_deprecated = [[ #define TEST __declspec(deprecated) int somefunc() { return 0; } int main() { return somefunc();} ]] }) detectcache:set(has_deprecated_key, has_deprecated) detectcache:save() end -- has_deprecated is now cached end) 包管理 依赖同一个包多个版本 有依赖包 A 和 B，A 包依赖 1.0.0 版本的 C 包，B 包依赖 1.1.0 版本的 C 包，如果继续编译的话，可能会链接失败，解决方法就是打平依赖，只依赖 C 包同一个版本。\nadd_requireconfs(\u0026#34;B.C\u0026#34;, {version = \u0026#34;1.0.0\u0026#34;, override = true}) 这里把 C 包统一到 1.0.0 版本。\n参考\nhttps://github.com/xmake-io/xmake/issues/3868 https://github.com/orgs/xmake-io/discussions/2220 vcpkg 包不会自动处理依赖 暂时不支持，最好去用官方包\n参考\nhttps://github.com/xmake-io/xmake/issues/3634 如何调试包源码 xmake 早期是保留源码的，但每次安装都保留源码和编译产物，容易把磁盘用满，所以现在优化了，不再保留。\n# -d 指定源码覆盖安装，本地源码调试包 xrepo install -m debug -d package_sourcedir xxx 有些远程包为什么没有拉预编译版本 众所周知 c++ 编译器编译出的二进制有 abi 问题，同一个编译器不同版本都可能不兼容，所以当预编译库的编译器版本（github ci 编译）和本地编译器版本不一致的时候，会拉取源码进行编译。\n有些库很大，编译需要很久，可以考虑下面方案：\n比较推荐通过set_base(\u0026quot;package\u0026quot;)继承包，然后覆盖包的一些设置，跳过 xmake 的检查直接安装二进制包。这里可能需要对 xmake 有一定的基础，不过完成后都是自动化，这是值得的。\n手动下载预编译包到本地包仓库\n假设预编译包目录和xmake.lua同一个目录，使用on_fetch进行配置。\n这里拿 glfw 作为参考。\n我这里下载并解压了glfw-3.3.8.bin.WIN64.zip，然后在xmake.lua这样写：\n-- 演示操作，不一定正确 package(\u0026#34;glfw\u0026#34;) on_load(function (package) -- set package dir package:set(\u0026#34;installdir\u0026#34;, path.join(os.scriptdir(), \u0026#34;glfw-3.3.8.bin.WIN64\u0026#34;)) end) on_fetch(function (package) -- add dll package:addenv(\u0026#34;PATH\u0026#34;, package:installdir(\u0026#34;lib-vc2022\u0026#34;)) local result = {} if is_plat(\u0026#34;windows\u0026#34;) then result.syslinks = {\u0026#34;user32\u0026#34;, \u0026#34;shell32\u0026#34;, \u0026#34;gdi32\u0026#34;} end result.links = {\u0026#34;glfw3\u0026#34;, \u0026#34;glfw3_mt\u0026#34;, \u0026#34;glfw3dll\u0026#34;} result.includedirs = package:installdir(\u0026#34;include\u0026#34;) result.linkdirs = package:installdir(\u0026#34;lib-vc2022\u0026#34;) return result end) package_end() 使用：\nset_runtimes(\u0026#34;MD\u0026#34;) add_requires(\u0026#34;glfw\u0026#34;) target(\u0026#34;test\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;*.cpp\u0026#34;) add_packages(\u0026#34;glfw\u0026#34;) 其他 xmake 源码怎么看 有一篇老文章可以看看 -\u0026gt; xmake 源码架构剖析\n定制 api 参考一下这个 pr 是怎么写的：Add set_encodings api to set source/target encoding\n","date":"2023-03-04T00:00:00Z","permalink":"https://star-hengxing.github.io/p/xmake-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/","title":"Xmake 常见问题解答"},{"content":"子标题：理解 std::move 和所有权。\n前言 关于 std::move 其实也有很多文章了，不过为了给群友解释，再造一次轮子。\nstd::move 我们打开 std::move 的实现，发现里面是一个强制类型转换（随便找的代码）。\ntemplate \u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; arg) { return static_cast\u0026lt;typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(arg); } 使用：\nObject A; Object B = std::move(A); 这右值有啥用啊？假设 Object 类有以下构造函数：\n// 函数1 Object(const Object\u0026amp; object); // 函数2 Object(Object\u0026amp;\u0026amp; object); 如果没有std::move(A)这一步，那么B将会调用函数1进行构造，反之调用函数2。\n但分开两个构造函数是干什么呢，这里就牵涉到一个资源分配和所有权问题。\n所有权 假如你是A，你从宠物商店买了一只仓鼠回来（仓鼠挺可爱的），那你就成为了这只仓鼠的主人。\nB是你的好朋友，他经常到你家玩。他觉得你的仓鼠很可爱，于是他也想买一只，但是他没有足够的钱。\n分支路线1： 可是突然有一天，你不想养这只仓鼠了，就想找个人帮你继续养下去。你知道B也想养一只属于自己的仓鼠，但没有钱去买。于是你找来了B，将仓鼠送给了他。\n那么B从这天起，就成为了仓鼠的第二任主人了。\n分支路线2： 有一天B打工赚了许多钱，于是他去问你这只仓鼠是什么品种，然后自己到宠物商店买了一只差不多一样的。\n现在又有一只小仓鼠找到了新家了。\n回到主题，在上面，抽象来讲，买了一只仓鼠，其实就是分配了一个资源，你就拥有了他的使用权（所有权）。\n分支路线1中，A把仓鼠送给了B，这就是转移了仓鼠的所有权，主人从A变成了B，对应Object(Object\u0026amp;\u0026amp; object)。\n分支路线2中，B也买了一只仓鼠，这样两只仓鼠，都有了各自的主人，对应Object(const Object\u0026amp; object)。\n要知道买一只新仓鼠是要花钱的，所以在某些场景用 std::move 来节省这个资源的开销。\n但仓鼠毕竟是别人养过的，想要一只独一无二属于自己的小仓鼠，那就买一只新的吧，所以就需要申请一份新的资源。\n后记 理解所有权后，就像学数据结构学会了链表。学习新的知识，第一步总是最难的。\n","date":"2023-02-25T00:00:00Z","permalink":"https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx2/","title":"C++ 胡言乱语X2"},{"content":"前言 当前环境在 Windows，默认了解 C/C++ 编译流程。 不一定是最佳实践。 静态库 target 下直接考虑用set_kind(\u0026quot;static\u0026quot;)即可。\n有一个可以注意的地方，可以使用set_policy(\u0026quot;build.merge_archive\u0026quot;, true)来合并所有静态库。（大概是用在分发二进制的时候？）\n动态库 考虑到 windows dll 要在函数声明__declspec(dllexport)导出接口（也可以用.def文件）。\n手动给每个符号声明很麻烦，需要 build system 来自动化。\nxmake 对此做了支持，只需要在 target 下添加：\n-- C add_rules(\u0026#34;utils.symbols.export_all\u0026#34;) -- C++ add_rules(\u0026#34;utils.symbols.export_all\u0026#34;, {export_classes = true}) 就会生成正确 dll 文件了。\n如果想要自定义导出符号，使用utils.symbols.export_list。\n直接配置 假设test目录下是一个库，把上面静态库和动态库的用法结合起来：\nadd_includedirs(\u0026#34;include\u0026#34;, {public = true}) target(\u0026#34;add\u0026#34;) set_kind(\u0026#34;$(kind)\u0026#34;) add_files(\u0026#34;src/add.cpp\u0026#34;) if is_kind(\u0026#34;shared\u0026#34;) and is_plat(\u0026#34;windows\u0026#34;) then add_rules(\u0026#34;utils.symbols.export_all\u0026#34;, {export_classes = true}) end target(\u0026#34;sub\u0026#34;) set_kind(\u0026#34;$(kind)\u0026#34;) add_files(\u0026#34;src/sub.cpp\u0026#34;) if is_kind(\u0026#34;shared\u0026#34;) and is_plat(\u0026#34;windows\u0026#34;) then add_rules(\u0026#34;utils.symbols.export_all\u0026#34;, {export_classes = true}) end target(\u0026#34;test\u0026#34;) set_kind(\u0026#34;$(kind)\u0026#34;) add_files(\u0026#34;src/test.cpp\u0026#34;) add_deps(\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;) if is_kind(\u0026#34;shared\u0026#34;) and is_plat(\u0026#34;windows\u0026#34;) then add_rules(\u0026#34;utils.symbols.export_all\u0026#34;, {export_classes = true}) elseif is_kind(\u0026#34;static\u0026#34;) then set_policy(\u0026#34;build.merge_archive\u0026#34;, true) end 使用不同类型的库只要xmake f -k shared/static就行了。\n使用规则 上面只是临时用法，实际在工程中，我推荐使用规则。下面代码和上面效果是一样的。\nrule(\u0026#34;module\u0026#34;) on_load(function (target) if is_mode(\u0026#34;debug\u0026#34;, \u0026#34;releasedbg\u0026#34;) then target:set(\u0026#34;kind\u0026#34;, \u0026#34;shared\u0026#34;) if is_plat(\u0026#34;windows\u0026#34;) then import(\u0026#34;core.project.rule\u0026#34;) local rule = rule.rule(\u0026#34;utils.symbols.export_all\u0026#34;) target:rule_add(rule) target:extraconf_set(\u0026#34;rules\u0026#34;, \u0026#34;utils.symbols.export_all\u0026#34;, {export_classes = true}) end elseif is_mode(\u0026#34;release\u0026#34;) then target:set(\u0026#34;kind\u0026#34;, \u0026#34;static\u0026#34;) else assert(false, \u0026#34;Unknown build kind\u0026#34;) end end) rule_end() 开发时(debug mode)，全编译为动态库，加速链接。 发布时(release mode)，全编译为静态库，生成单个可执行程序文件。 使用：\ntarget(\u0026#34;test\u0026#34;) set_kind(\u0026#34;$(kind)\u0026#34;) add_files(\u0026#34;src/test.cpp\u0026#34;) add_deps(\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;) add_rules(\u0026#34;module\u0026#34;) ","date":"2023-01-04T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/","title":"使用 Xmake 生成静态和动态库"},{"content":"前言 CS149 是一个教并行编程的课程，课程作业使用了 makefile 作为 build system。\n本文通过改造 build system 来讲述一些xmake的使用方法。\n分析 这个课程主要有四个作业，那么是一个多target工程，考虑用多级配置。\n作业里用到了很多工具，xmake都支持这些工具链。不过有些作业不跨平台（只能在 Linux 下运行），所以尽可能地将作业移植到 windows 上。\n改造 完整配置在GitHub上，这里选讲几个部分。\n根目录配置 最小xmake版本。 set_xmakever(\u0026#34;2.7.5\u0026#34;) 跨平台首选clang作为 C++ 编译器，在 windows 下使用clang-cl接受 msvc 风格的参数。 在开发环境下，链接动态库可以减少二进制体积，加速链接。 添加宏定义处理一些 windows 的屎。 if is_plat(\u0026#34;windows\u0026#34;) then -- set_toolchains(\u0026#34;clang-cl\u0026#34;) set_runtimes(\u0026#34;MD\u0026#34;) add_defines(\u0026#34;_CRT_SECURE_NO_WARNINGS\u0026#34;, \u0026#34;NOMINMAX\u0026#34;) else -- set_toolchains(\u0026#34;clang\u0026#34;) end 源码目录配置 考虑到 windows 没有getopt.h，这里在 github 上随便找了一个库代替，并开放头文件权限给依赖此库的target使用。 if is_plat(\u0026#34;windows\u0026#34;) then target(\u0026#34;getopt\u0026#34;) set_kind(\u0026#34;static\u0026#34;) add_includedirs(\u0026#34;getopt-for-windows\u0026#34;, {public = true}) add_files(\u0026#34;getopt-for-windows/getopt.c\u0026#34;) target_end() end 作业1 作业有多个target，其实可以考虑每个给每个target单独一个配置，不过这里选择把多个target都放在同一个xmake.lua中。\n根据原始 makefile 参数，处理一些跨平台配置。 考虑到作业会生成 ppm 格式的图片，所以改变该target的运行目录。 target(\u0026#34;mandelbrot\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;prog1_mandelbrot_threads/*.cpp\u0026#34;) set_optimize(\u0026#34;fastest\u0026#34;) add_deps(\u0026#34;common\u0026#34;) if is_plat(\u0026#34;windows\u0026#34;) then add_deps(\u0026#34;getopt\u0026#34;) elseif is_plat(\u0026#34;linux\u0026#34;) then add_syslinks(\u0026#34;m\u0026#34;, \u0026#34;pthread\u0026#34;) end set_rundir(\u0026#34;prog1_mandelbrot_threads\u0026#34;) target_end() 这里用到了ispc进行编译，使用xmake的内置规则进行编译。 编译 ispc 文件会生成一个对象文件和头文件，这里通过header_extension配置控制生成头文件的后缀，然后就可以在代码中引用生成的头文件xxx_ispc.h（xxx.ispc）。 由于没有内置的 ispc api，这里使用set_values传递编译参数。 target(\u0026#34;sqrt\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_rules(\u0026#34;utils.ispc\u0026#34;, {header_extension = \u0026#34;_ispc.h\u0026#34;}) add_files(\u0026#34;prog4_sqrt/*.ispc\u0026#34;) add_files(\u0026#34;prog4_sqrt/*.cpp\u0026#34;) add_cxxflags(\u0026#34;-march=native\u0026#34;) set_values(\u0026#34;ispc.flags\u0026#34;, \u0026#34;--target=avx2-i32x8\u0026#34;, \u0026#34;--arch=x86-64\u0026#34;) set_optimize(\u0026#34;fastest\u0026#34;) add_deps(\u0026#34;common\u0026#34;) if is_plat(\u0026#34;linux\u0026#34;) then add_syslinks(\u0026#34;m\u0026#34;, \u0026#34;pthread\u0026#34;) end target_end() 作业2 本作业两个target的配置相同，可以用一个循环来生成。（常用于生成相同配置的单元测试）\nfor _, part in ipairs({\u0026#34;part_a\u0026#34;, \u0026#34;part_b\u0026#34;}) do target(part) set_kind(\u0026#34;binary\u0026#34;) add_includedirs(part) add_includedirs(\u0026#34;../common\u0026#34;, \u0026#34;tests\u0026#34;) add_files(part .. \u0026#34;/*.cpp\u0026#34;) add_files(\u0026#34;tests/main.cpp\u0026#34;) if is_plat(\u0026#34;windows\u0026#34;) then add_deps(\u0026#34;getopt\u0026#34;) elseif is_plat(\u0026#34;linux\u0026#34;) then add_syslinks(\u0026#34;m\u0026#34;, \u0026#34;pthread\u0026#34;) end target_end() end 作业内置 test，但官方没有提供完成所有测试的脚本（其实直接改源码也可以），不过这里考虑用 xmake 的脚本域来做这件事。 设置一个空目标类型，覆盖内置的on_run，然后使用 xmake 一些内置的 api 运行测试。 target(\u0026#34;part_a_test\u0026#34;) set_kind(\u0026#34;phony\u0026#34;) add_deps(\u0026#34;part_a\u0026#34;) on_run(function () local test_names = { \u0026#34;simple_test_sync\u0026#34;, \u0026#34;ping_pong_equal\u0026#34;, \u0026#34;ping_pong_unequal\u0026#34;, \u0026#34;super_light\u0026#34;, \u0026#34;super_super_light\u0026#34;, \u0026#34;recursive_fibonacci\u0026#34;, \u0026#34;math_operations_in_tight_for_loop\u0026#34;, \u0026#34;math_operations_in_tight_for_loop_fewer_tasks\u0026#34;, \u0026#34;math_operations_in_tight_for_loop_fan_in\u0026#34;, \u0026#34;math_operations_in_tight_for_loop_reduction_tree\u0026#34;, \u0026#34;spin_between_run_calls\u0026#34;, \u0026#34;mandelbrot_chunked\u0026#34;, } for _, value in ipairs(test_names) do -- cprint(\u0026#34;Testing \u0026#34; .. \u0026#34;${bright green}%s\u0026#34;, value) -- os.runv(name, {value}) os.execv(\u0026#34;xmake\u0026#34;, {\u0026#34;run\u0026#34;, \u0026#34;part_a\u0026#34;, value}) end cprint(\u0026#34;${bright red}Pass!\u0026#34;) end) target_end() 作业3 xmake 会自动探测 cuda 的目录，如果不在默认的安装目录，设置一下。\nxmake f --cuda=\u0026lt;PATH\u0026gt; xmake 对cuda支持还算完善，直接add_files就能直接编译。 cuda runtime 也有动态库，不过 xmake 默认链接静态库，这里需要手动添加链接动态库的名字。 add_cugencodes(\u0026#34;compute_35\u0026#34;) add_links(\u0026#34;cudart\u0026#34;) target(\u0026#34;render\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;render/*.cpp\u0026#34;) add_files(\u0026#34;render/*.cu\u0026#34;) add_packages(\u0026#34;freeglut\u0026#34;) set_rundir(\u0026#34;render\u0026#34;) target_end() 作业4 该作业只能运行在 Linux 平台，因为官方只提供了 Linux 平台的二进制进行链接。\n这里写了一个函数禁用target，然后在on_load时禁用，可以使用其他写法禁用target。 官方提供了一个静态库，但静态库名字前缀不是lib开头，链接器不接受，所以不能直接用add_links function only_linux(target) if target:is_plat(\u0026#34;linux\u0026#34;) then target:set(\u0026#34;enabled\u0026#34;, true) else target:set(\u0026#34;enabled\u0026#34;, false) end end target(\u0026#34;pr\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;pagerank/main.cpp\u0026#34;, \u0026#34;pagerank/page_rank.cpp\u0026#34;) add_linkdirs(\u0026#34;pagerank\u0026#34;) add_ldflags(\u0026#34;-fopenmp\u0026#34;) add_ldflags(\u0026#34;-l:ref_pr.a\u0026#34;, {force = true}) add_deps(\u0026#34;assignment4_common\u0026#34;) on_load(only_linux) target_end() 对象文件也可也直接add_files target(\u0026#34;bfs\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;bfs/main.cpp\u0026#34;, \u0026#34;bfs/bfs.cpp\u0026#34;) add_files(\u0026#34;bfs/ref_bfs.o\u0026#34;) add_ldflags(\u0026#34;-fopenmp\u0026#34;) add_deps(\u0026#34;assignment4_common\u0026#34;) on_load(only_linux) target_end() ","date":"2022-12-18T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/","title":"使用 Xmake 作为 CS149 作业的 bulild system"},{"content":"前提 目前来说 Rider 还是最好的 UE IDE，本文只是提供多一种选项来写 UE 代码。\n环境 vscode 插件 clangd clang Windows 推荐使用 scoop 下载 clang。\nscoop install llvm 部署 用 vscode 打开 UE 项目目录，新建.vscode目录。\n新建.vscode/settings.json文件，写入下面内容。\n{ \u0026#34;clangd.arguments\u0026#34;: [ \u0026#34;--background-index\u0026#34;, \u0026#34;--compile-commands-dir=.vscode\u0026#34;, // completion \u0026#34;--header-insertion=never\u0026#34;, \u0026#34;--completion-style=bundled\u0026#34;, \u0026#34;--function-arg-placeholders=false\u0026#34;, // effective \u0026#34;--pch-storage=memory\u0026#34;, \u0026#34;-j=16\u0026#34;, // coding \u0026#34;--clang-tidy\u0026#34;, // misc \u0026#34;--log=error\u0026#34; ] } 在项目目录新建.clang-format文件，谷歌一下 UE clang-format，随便找一个复制下来。这里用来格式化代码。\n使用脚本生成反射信息和compile_commands.json\ncompile_commands.json成功生成后，打开 cpp 文件，clangd 就会自动运行。\nUE 的 Unreal Build Tool 可以生成compile_commands.json，需要 clang 辅助。不过 UBT 写的比较奇葩，在命令行直接clang -v有结果，但 UBT 还是找不到，在论坛看了一遍 Linux/Windows 都是这样。\n但 Windows 还是能找到 clang 的，不过需要把 LLVM 工具链放在这里。\nC:/Program Files/LLVM 这里建议弄一个目录软链接，或者直接拷贝过来。不会用 mklink 可以看看这篇文章：比较 Windows 上四种不同的文件（夹）链接方式（NTFS 的硬链接、目录联接、符号链接，和大家熟知的快捷方式） # C:/Program Files/ cmd /c mklink /J LLVM \u0026lt;LLVM_PATH\u0026gt; 然后这里需要一个脚本来调用 UBT，可以考虑用 vscode 内置的 tasks，也可也用 python 等脚本语言，假如要用 vsocde tasks：\n新建文件.vscode/tasks.json 假设 UE 目录在 C:/Program Files/Epic Games/UE_4.27，新建项目名称为demo。\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Gen Generated Code\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Engine/Binaries/DotNET/UnrealBuildTool.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;demoEditor\u0026#34;, // \u0026lt;project name\u0026gt;Editor \u0026#34;Win64\u0026#34;, \u0026#34;DebugGame\u0026#34;, \u0026#34;-SkipBuild\u0026#34;, \u0026#34;-project=${workspaceFolder}/demo.uproject\u0026#34;, \u0026#34;-game\u0026#34;, \u0026#34;-engine\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;C:/Program Files/Epic Games/UE_4.27\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Subtask:GenClangDatabase\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Engine/Binaries/DotNET/UnrealBuildTool.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;demoEditor\u0026#34;, // \u0026lt;project name\u0026gt;Editor \u0026#34;Win64\u0026#34;, \u0026#34;DebugGame\u0026#34;, \u0026#34;-SkipBuild\u0026#34;, \u0026#34;-project=${workspaceFolder}/demo.uproject\u0026#34;, \u0026#34;-game\u0026#34;, \u0026#34;-engine\u0026#34;, \u0026#34;-mode=GenerateClangDatabase\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;C:/Program Files/Epic Games/UE_4.27\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Subtask:MoveCompileCommands\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;move\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-Force\u0026#34;, \u0026#34;compile_commands.json\u0026#34;, \u0026#34;${workspaceFolder}/.vscode\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;C:/Program Files/Epic Games/UE_4.27\u0026#34; } }, { \u0026#34;label\u0026#34;: \u0026#34;Gen Compile Commands\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;Subtask:GenClangDatabase\u0026#34;, \u0026#34;Subtask:MoveCompileCommands\u0026#34; ], \u0026#34;dependsOrder\u0026#34;: \u0026#34;sequence\u0026#34; } ] } Reference Windows 下使用 Vscode + Clangd 搭建 UE4 开发环境 ","date":"2022-11-25T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E7%94%A8-vscode-%E5%86%99-ue-%E4%BB%A3%E7%A0%81/","title":"用 vscode 写 UE 代码"},{"content":"使用 edge，不需要科学上网就能在不同电脑同步插件\n整洁 清理广告 -\u0026gt; AdGuard 移除 cookies 提醒 -\u0026gt; I don\u0026rsquo;t care about cookies 移除 url 跟踪参数 -\u0026gt; ClearURLs 效率 生成目录 -\u0026gt; Smart TOC 浏览网页 -\u0026gt; Vimium C 鼠标悬停链接显示图像/视频 -\u0026gt; Imagus 贴心工具 网页截图 -\u0026gt; Awesome Screenshot 听歌 -\u0026gt; Listen 1 自定义个人主页 -\u0026gt; Custom New Tab URL 破解网页限制复制 -\u0026gt; SuperCopy github 代码文件树 -\u0026gt; Octotree 集成 Aria2 for Edge KeePassXC-Browser v2ex plus Tampermonkey B站增强 -\u0026gt; Bilibili Evolved 移除 url 跟踪参数 -\u0026gt; Bilibili 干净链接 秒传 -\u0026gt; rapidupload-userscript 给片假名显示原词 -\u0026gt; 片假名终结者 知乎增强 贴吧页面精简 护眼模式 ","date":"2022-11-06T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/","title":"浏览器插件"},{"content":"某些 STL 容器 在刷 leetcode，其中某道题中的代码片段是这样的\nstring res; res.resize(size - i); // res.reserve(size - i); for (int j = 0; i \u0026lt; size; i += 1, j += 1) { res[j] = arr[i] + \u0026#39;0\u0026#39;; // res.push_back(arr[i] + \u0026#39;0\u0026#39;); } 没注释的代码比注释的快了几ms，原因如下\n因为容器一开始是空的，不需要考虑拷贝原来的元素\nresize 重新分配内存并且默认初始化，size 改变（大概开销 malloc + memset） reserve 重新分配了内存，不初始化，size 不变 push_back 需要检查 size 有没有大于 capacity，多了分支的开销 然而这里代码也不是最快的，思考一下，这里 resize 还多了一个 memset 的开销，所以最优解应该是，用自己写的 vector（逃\n不知道是历史原因还是标准委员会根本没考虑到，应该加多几个函数来表示需不需要初始化\n改造容器 这里先看一个别人家的 vector：Less\n看一下某个代码片段\nstruct default_init_t {}; inline constexpr default_init_t default_init; struct with_capacity_t {}; inline constexpr with_capacity_t with_capacity; vector(default_init_t, size_type const size) { this-\u0026gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T; }); } vector(size_type size) { this-\u0026gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T(); }); } vector(with_capacity_t, size_type const capacity) { this-\u0026gt;construct(0u, capacity, [](auto, auto) {}); } vector(size_type size, T const\u0026amp; value) { this-\u0026gt;construct(size, size, [\u0026amp;](auto p, auto) { new (p, placement_tag) T(value); }); } 思考🤔，直接把一个结构体类型作为参数？算了直接去 c++ 群问一下\n哦，原来这个叫tag dispatch，才发现这语法在（MSVC STL）到处都是，感觉不如多写个 make 系列函数，而不是重载构造函数\n我觉得更好的实践应该是：\n// 分配内存，size 改变，默认初始化 static vector\u0026lt;T\u0026gt; make_default_init(std::size_t size, const T\u0026amp; val = T{}); // 分配内存，size 改变，不进行初始化 static vector\u0026lt;T\u0026gt; make_default_without_init(std::size_t size); // 分配内存，size 不变，不进行初始化 static vector\u0026lt;T\u0026gt; make_with_capacity(std::size_t size); // 重新分配内存，size 改变，不进行初始化 void resize_without_init(std::size_t size); 这个库还有个设计是，抛弃 std::allocator，使用自定义 new 和 delete\nstd::allocator 这玩意设计有误，扔掉很正常，至于为什么，看这个\n自增运算符 在最上面的代码，里面自增1都是使用+=，这是好的代码风格\n有时候你会看见这种代码：++array[index++]\n前缀/后缀自增运算符赶紧死一死，后出世的语言基本都没有++这个语法了\n更让我觉得恶心的是，群友在 AMD 的笔试说考i+++++i这种题，就算是外企我也想开喷：中国本土化了这是，真接“谭教授”的地气啊\n别说能考你 体系结构/操作系统/编译器 的知识，首先有一个大前提就是，ub 不能拿来做题目\n","date":"2022-09-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx1/","title":"C++ 胡言乱语X1"},{"content":"学vulkan时的笔记（胡言乱语\n前言 渲染需要呈现最终结果，所以和游戏引擎是“耦合”的\n写一个简单的渲染引擎，其实和写一个游戏引擎也没什么区别，因为物理和动画的呈现依赖于渲染\n这里所说的渲染应该不包含各种shader效果，更类似于怎么调图形api\n所以写渲染引擎，本质还是写游戏引擎，那么最终还是要参考游戏引擎的架构\n学vulkan也一样，最终都会写成渲染引擎，所以提前架构一下比较好。这样在使用vulkan tutorial学习时，不局限于单文件恶心自己\n调api渲染的流程 加载数据到cpu/gpu，在gpu描述数据的布局，如何操作数据\n虽然就短短一行字，但拆分下来每一部分都可以讲很多\n资产管理 资产管理，可以简单自定义一个自己的资产文件格式，可以参考vulkan guide\n我的想法是，定义一个最底层的存储格式，如 metadata + data，data 可以使用lz4算法进行压缩\nmetadata 可以是格式版本、data 的大小、是否加密\u0026hellip;\u0026hellip;\n然后又可以自定义一个 texture 和 mesh 的格式，也是 metadata + data 模式，然后把这些打包塞给上面格式的 data 里\n然后我们还需要一个转换器，负责把不同的模型格式（比如obj）转换成我们自定义的格式\n思路理清的话，基本上都是一些工程脏活了，实现难度不大\n待续 等我过一遍 unity 的 urp\n参考 有关图形学入门的一些思考·谈谈Vulkan ","date":"2022-08-08T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84/","title":"渲染引擎的架构"},{"content":"起因 在实现我的离线渲染器中，用到了大量oop（其实就是基类然后继承）\n我有一个Shape基类，里面接口全声明为标准的纯虚函数接口\nvirtual TYPE FUNCTION() const = 0; 当你继承这个类后，继承类必须实现这个接口，不然编译报错\n一开始还没有写实现，但类已经继承了，没办法，在接口开个洞（真难看啊\nvirtual TYPE FUNCTION() const {} 于是我基于 C++20 标准库的source_location写了一个\n[[noreturn]] inline void unimplemented(const std::source_location location = std::source_location::current()) { std::cerr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#39;[\u0026#39; \u0026lt;\u0026lt; location.file_name() \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; location.line() \u0026lt;\u0026lt; \u0026#34;] \u0026#34; \u0026lt;\u0026lt; location.function_name() \u0026lt;\u0026lt; \u0026#34; unimplemented!\\n\u0026#34;; exit(-1); } 还没有实现接口的时候留下unimplemented，然后运行时报错\nsource_location暂时只有clang不支持（clang对C++20支持太慢了\n网上冲浪时看到有人说，接口虚函数实现动态多态是一种糟糕实践，优雅的做法是Existential Type，在C++社区称为sean parent polymorphism\n详细可以看这个视频\nJohn Bandela “Polymorphism != Virtual: Easy, Flexible Runtime Polymorphism Without Inheritance”\nreddit上的关于该视频的讨论\n什么是多态 特定多态 Ad hoc polymorphism\n函数重载，当然运算符重载也一样\n参数化多态 Parametric polymorphism\n类似 C++ 的模板，也可以称为泛型\n子类型多态 Subtyping\n平时编程用的最多的，继承基类，调用相同符号的方法\nExistential Type 中文语境下叫类型擦除/隐藏类型实现（机翻直译叫存在类型）\n看一段 C++ 代码\n#include \u0026lt;functional\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; // type Messenger = ∃ a. { x: a, Print: a -\u0026gt; string -\u0026gt; ⊥ } struct Messenger { using QuantificationBound = auto(std::string_view)-\u0026gt;void; std::function\u0026lt;QuantificationBound\u0026gt; f = {}; Messenger() = default; Messenger(auto x) { f = [=](auto msg) { x.Print(msg); }; } auto Print(auto msg) const { f(msg); } }; struct A { auto Print(auto msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;A says \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; struct B { auto Print(auto msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;B says \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; auto main()-\u0026gt;int { auto x = std::vector\u0026lt;Messenger\u0026gt;{ A{}, B{} }; for (auto y : x) y.Print(\u0026#34;hi\u0026#34;); } 我觉得有点像上面所说的子类型\n在代码中，用std::function封装了真正的调用函数，而不需要考虑具体类型。std::function除了保存函数状态，还有运行时多态。但在不同 stl 的实现，有些是直接用 virtual，有些手动用指针打虚表。虽然看起来底层实现一样，不过好处就是，不需要给类函数加上 virtual，这算是一种解耦\n但用std::function实现其实有一些缺陷，比如将 lambda 函数赋值给它的时候，lambda capture 的变量太多会动态分配内存。比较推荐的是用 template\nReference Existential type 是什么？ 多态都不知道，谈什么对象 关于std function和lambda function的性能调试 ","date":"2022-07-25T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%A4%9A%E6%80%81/","title":"多态"},{"content":"下面的目录不好使，只要小部分能跳转，点右边的目录跳转吧\n我在知乎的点赞其实是当收藏用的， 这么多点赞，打算找时间用爬虫全部爬下来慢慢整理\n数学 物理 信息 计算机理论 软件工程 理论 实践 编程语言 C C++ Rust Haskell 体系结构 编译原理 可视化 优化 高性能计算 计算机图形学 旋转 音视频 逆向 Linux 工具 在线工具 Git Unity 二次元 galgame 资源 在线 生肉 音声 色度学 日语 misc 数学 我在知乎学数学 图形数学方法：FFT（快速傅里叶）的原理讲述 有没有比较好的学习高等数学，线性代数，概率论数理统计的英文书籍推荐？ 物理 Ten Minute Physics 信息 压缩算法lzma2,zstd,rar,brotli,lz4,lizardv1对比推荐 计算机理论 计算复杂度理论基础（一）Preliminaries 软件工程 理论 语义化版本 2.0.0 读《Fundamentals of Software Architechture》 可逆计算：下一代软件构造理论 抽象的幻觉（1） 抽象的幻觉（2） 为什么这么设计系列文章 实践 游戏架构设计——面向数据编程（DOP） 游戏架构设计——高性能并行编程 为什么我认为Rust的Result错误处理方式不如Exception，探讨了Monad和工业界主流的异常处理两种错误处理的差异 游戏编程模式 阿里云块存储团队软件工程实践 Chromium 渲染流水线——字节码到像素的一生 A development process startup founders should use to ship features weirdly fast 编程语言 C 现代化 C 使用体验 The different ways to handle errors in C C Isn\u0026rsquo;t A Programming Language Anymore C++ 单例模式 简单的 C++ 结构体字段反射 make a shared_ptr from scratch C++ 系列专题 Changing std::sort at Google’s Scale and Beyond 最好的C++学习教程(上篇)——The Cherno CppSeries 最好的C++学习教程(下篇)——The Cherno CppSeries More C++ Idioms Learn Modern C++ 现代化工具链在大规模 C++ 项目中的技术实践 Understanding the different flavors of Clang C and C++ compilers in Windows，讲述了C++ 不同编译工具链的差异 从无栈协程到C++异步框架 Rust 文組也能懂的 Rust async 機制 Rust Language Cheat Sheet Haskell Learn Haskell by building a blog generator 体系结构 与程序员相关的CPU缓存知识 深入理解CPU cache：组织、一致性（同步）、编程 深入GPU硬件架构及运行机制 如何设计内存池？ - 韦易笑的回答 - 知乎，内存管理是最能体现体系结构知识的地方之一 Microarchitecture cheat sheet When an instruction depends on the previous instruction depends on the previous instructions… : long instruction dependency chains and performance 编译原理 【科普】编译器的构建基本原理 Programming Language Documentations 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 可视化 浮点数可视化 正则表达式可视化 马尔科夫链可视化 四元数可视化 数据结构可视化 优化 浮点数计算优化 vfixupimm: signum，用 AVX 优化取浮点数符号 When an instruction depends on the previous instruction depends on the previous instructions… : long instruction dependency chains and performance，CPU 指令依赖链太长拖慢速度，但依赖链解决不了，只能交叉两个依赖链提高效率 高性能计算 高性能计算学习路线 从零开始的C/C++高性能编程指南 C++ 高性能编程实战系列（1） C++ 高性能编程实战系列（2） C++ 高性能编程实战系列（3） CMU15418 并行计算机架构与编程 计算机图形学 使用有理数进行渲染 如何验证BXDF 实时\u0026amp;离线皮肤渲染技术（Real-time \u0026amp; Offline Skin Rendering） Enterprise PBR Shading Model 多种几何体求交 How to build a BVH 旋转 可视化和公式推导 音视频 FFmpeg原理 FFmpeg5开发入门系列索引 逆向 这里我推荐 CSAPP Lab2-Bomb Lab\n[原创] 逆向并提取QQ截图\u0026ndash;OCR和其他功能 Linux Linux 101 archlinux 简明指南 一张图理解Linux文件权限 解释 shell 参数 Delightful io_uring packages and resources 工具 在线工具 知春在线工具箱 つつの工具箱 在线Ping/测速等 Git 在使用 git 时的一些尴尬场景里的修复方案 Git Command Explorer(git速查表) Unity Catlike Coding unity tutorials Unity SRP下做PBR基于物理的渲染和踩坑（一） 二次元 galgame galgame常用名词中日对照小辞典 混沌之子 CHAOS;CHILD LOVE chu chu!! 资源 VCB-Studio，专门修复动漫画质\n次元图书馆，galgame资源多，od盘下载\n琉璃神社(无注册要求)\n量子ACG(无注册要求，主要是游戏)\n萌次元(无法注册，资源社区)\nZodgame(注册已关闭，论坛)\n最ACG(无注册要求，资源社区)\nACEACG(在线本子漫画)\n紳士会所(无注册，资源社区)\nUZXun社区(无注册要求，资源论坛)\n紳士漫畫(无注册，在线本子漫画)\n松鼠症倉庫(无注册要求，在线本子漫画)\n梦璃(无注册要求，资源社区）\n布璃(无注册要求，声音资源社区)\n资源统筹局(答题注册获取邀请码，资源社区)\n次元计划(资源社区)\n梦幻之乡(无注册要求，资源社区)\n心動漫(答题注册邀请码，资源转载)\nsaber酱的抱枕(个人资源博客)\n暗萌(无注册要求，资源社区)\n灵梦御所(个人资源博客，官方有社区软件)\n初音社(无注册要求，资源社区)\n绅士茶馆(资源社区，无注册)\n扶她404(资源社区，无注册要求)\n绅士咖啡厅(资源论坛，注册邀请码获取)\n在线 bimi动漫 异世界动漫 生肉 https://www.ggbases.com https://sukebei.nyaa.si http://www.anime-sharing.com https://bbs4.2djgame.net 绯月 幽隐恋梦 音声 ASMR Online eat ASMR 色度学 色彩空间基础 色彩空间表示与转换 光谱渲染的几个例子 色温、白平衡与色彩恒常性 色彩科学学习笔记：专栏自述、目录 日语 日语学习网站\n時雨の町 duolingo LingQ 日语语法指南 misc GNU工具实现解密 漫画数据化——计算机科学在漫画领域的相关研究简介 整理记录各个包管理器，系统镜像，以及常用软件的好用镜像 图解Functor和Monad GitHub开源项目维护指南 在线矩阵计算 三维重建\u0026amp;点云处理\u0026amp;图形渲染\u0026amp;网格处理\u0026amp;游戏开发 （可能是）全网最好用的 HDR 术语速查手册 凤凰架构 构建可靠的大型分布式系统 汉语反向词典，查近义词 Lights and Shadows Quick Reference，针对开发人员的速查表 Practical Deep Learning ","date":"2022-07-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%94%B6%E8%97%8F%E5%A4%B9%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB/","title":"收藏夹（知识分类）"},{"content":"技术书看新不看旧\n计算机科学 人月神话 黑客与画家 敏捷软件开发 代码整洁之道 程序员的自我修养 : 链接、装载与库 七周七语言 代码本色 x86汇编语言 : 从实模式到保护模式 深入理解计算机系统 Head First设计模式 编程语言 C C Primer Plus C++ C++ Primer C++ Primer PLus Effective C++ More Effective C++ Effective Modern C++ C++ Best Practices: 45ish Simple Rules with Specific Action Items for Better C++ C++性能优化指南 C++并发编程实战 Rust 深入浅出Rust Rust程序设计语言 Python Python编程 从入门到实践 Haskell Haskell趣学指南 Haskell函数式编程入门 数据结构与算法 大话数据结构 算法导论 计算机体系结构 计算机组成与设计：硬件/软件接口 计算机系统要素 : 从零开始构建现代计算机 编码 : 隐匿在计算机软硬件背后的语言 操作系统 一个64位操作系统的设计与实现 Linux内核设计与实现 现代操作系统 现代操作系统：原理与实现 计算机网络 计算机网络自顶向下方法 TCP/IP详解 卷1：协议 图解HTTP 计算机图形学 Fundamentals of Computer Graphics Ray Tracing Gems series 全局光照技术 实时渲染 Real-Time Rendering 离线渲染 The Ray Tracer Challenge Ray Tracing in One Weekend series Advanced Global Illumination Physically Based Rendering: From Theory to Implementation 数学 线性代数的几何 线性代数及其应用 漫画线性代数 数值分析 从博弈问题到方法论学科 物理 现代光学基础 光学原理 游戏 游戏编程模式 游戏引擎架构 游戏设计艺术 日语 新版中日交流标准日本语初级 音乐 超简单的乐理学习图解版 认识乐理：视唱练耳同步学 杂书 视觉艺术用光 色彩与光线 写实主义绘画指南 我的二本学生 信息简史 信息论基础 信号与系统 ","date":"2022-07-05T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95%E4%B8%8B%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B9%A6%E5%90%A7/","title":"随便记录下看过的书吧"},{"content":"最近超星学习通数据泄露大家应该都知道吧，全国上下学生很多都依赖这么一个中心化的网课平台。而且学习通可能还是明文存储密码，这下坏事了，直接撞库\n撞库攻击是网络犯罪分子试图使用一组帐密同时访问多个帐户\n我很久以前就知道有密码管理器的存在，但我是懒鬼，所以没弄过。这次事件提醒了我，还是别偷懒了（\nGetting started KeePass是什么呢\nKeePass is an encrypted password database format. It is an alternative to online password managers and is supported on all major platforms.\n我这里推荐使用跨平台的KeePassXC客户端，原始KeePass客户端实在太丑陋了\n下载客户端后，新建数据库需要一个主密码，这个密码需要你记忆\n我们先来看一个图，来自xkcd 那如何根据上图思路创建一个好密码呢，这里可以看一下diceware的方法\n这个网站根据diceware方法提供在线生成随机英语单词\n如果想要生成随机中文词语，可以在此网页找到 使用diceware构造好的密码\n创建好数据库后，保存在本地随便一个目录，然后我们去KeePassXC设置面板开启浏览器集成，下载对应浏览器插件\n浏览器插件启动后需要连接KeePassXC客户端\n在网站登录页面，如果数据库里没有对应网站url或者已存在，会提示你为该网站新建/更新账号密码。如果没有提示，可以手动使用插件，或者直接在KeePassXC客户端手动录入\nKeePassXC里随手就可以生成一个密码，无论是大小写字母数字还是各种特殊符号。如果想使用密码，Ctrl-C会自动复制到你剪切板上，然后在10秒后清除\n如果手机也要密码管理，安卓客户端可以在f-droid上下载keepassdx\n同步 所有信息都在keepass创建的数据库里，这里可以使用一些文件传输软件进行备份同步，或者存github也没啥问题\n","date":"2022-06-27T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8keepass%E4%BD%9C%E4%B8%BA%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/","title":"使用KeePass作为密码管理器"},{"content":"也可以是C++小项目的配置\n开发环境构建 vscode+xmake+clang+clangd\n如果在配置过程中有问题，可以先看一下文末的FQA\nC++编译工具链 Visual Studio 2022 clang 构建系统 xmake\nVulkan SDK https://www.lunarg.com/vulkan-sdk/\n假装IDE的文本编辑器 Visual Studio Code\n安装插件\nclangd XMake Getting started 上面列出来的工具下载完成后，新建一个目录，在目录下新建xmake.lua，写入下面内容\nset_project(\u0026#34;vulkan\u0026#34;) set_arch(\u0026#34;x64\u0026#34;) set_warnings(\u0026#34;all\u0026#34;) set_languages(\u0026#34;c++20\u0026#34;) set_toolchains(\u0026#34;clang\u0026#34;) add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.releasedbg\u0026#34;, \u0026#34;mode.release\u0026#34;, \u0026#34;mode.minsizerel\u0026#34;) add_requires(\u0026#34;vulkansdk\u0026#34;, \u0026#34;glfw\u0026#34;, \u0026#34;glm\u0026#34;) target(\u0026#34;main\u0026#34;) set_default(true) set_kind(\u0026#34;binary\u0026#34;) add_files(\u0026#34;src/main.cpp\u0026#34;) add_packages(\u0026#34;vulkansdk\u0026#34;, \u0026#34;glfw\u0026#34;, \u0026#34;glm\u0026#34;) 依赖的 vulkansdk 在上面已经下载，如果用他的 installer 安装会自动设置环境变量，xmake 会根据环境变量自动探测编译器、vulkansdk 的正确位置，glm 和 glfw 由 xmake 的包管理处理\n编译 测试代码来自vulkan tutorial\n直接新建一个main.cpp，把代码复制下来\n一切配置好后，可以测试一下了\nxmake xmake run 出现窗口代表环境配置成功\nIntellisense xmake会在.vscode目录自动生成compile_commands.json\n所以我们在.vscode/settings.json给clangd加上参数\n{ \u0026#34;clangd.arguments\u0026#34;: [ \u0026#34;--compile-commands-dir=.vscode\u0026#34;, \u0026#34;--header-insertion=never\u0026#34;, \u0026#34;--completion-style=detailed\u0026#34; ] } FQA Q: xmake下载包失败怎么办\nA: 查看文档使用远程包 - xmake\nQ: 编译失败怎么办\nA: 执行xmake -v，查看详细输出信息\nQ: 我想用vs写代码怎么办\nA: 执行xmake project -k vsxmake -m \u0026quot;debug,release\u0026quot;生成vs工程文件\n","date":"2022-06-20T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%9C%A8-windows-%E4%B8%8A%E4%BD%BF%E7%94%A8-xmake-%E9%85%8D%E7%BD%AE-vulkan-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","title":"在 Windows 上使用 Xmake 配置 Vulkan 开发环境"},{"content":"图形笑话三则 来点图程破防乐子 无内鬼，来点图形笑话 再来点图程破防乐子 免费渲染模型 McGuire Computer Graphics Archive Rendering Resources 博客 A GRAPHICS GUY\u0026rsquo;S NOTE Computer Graphics IQ YangWC\u0026rsquo;s Blog AirGuanZ 《高级计算机图形学——真实感图像合成》目录及序言 OEOTYAN 课程 CS 87/287 | RENDERING ALGORITHMS UCSD CSE 272: Advanced Image Synthesis Advanced Graphics CSE 168 Computer Graphics II: Rendering CIS 565 GPU Programming and Architecture Fall 2022 各种效果 光谱 Simple Spectral Spectral Ray Tracing 天空 The Sky Dome Appearance Project 彩虹 Physically-based simulation of rainbows 动物毛发 An Efficient and Practical Near and Far Field Fur Reflectance Model 肥皂泡 Chemomechanical Simulation of Soap Film Flow on Spherical Bubbles FQA （其实就是把群友讨论结果收藏一下\n知乎上的常见问题 如何在离线渲染（路径追踪）中实现IBL？ 光线追踪中的透视畸变如何矫正？ 在通常渲染中的漫反射项，究竟是属于反射还是折射？ 如何将Surface Area Heuristic(表面面积启发式)运用到BVH的构建中？ 路径追踪光源重要性采样中为什么要每次均匀选取一个光源？ 微表面模型中几何项使用H还是N 在离线里面，一般用general smith，不需要用到H或者N的，就无所谓了。\n虚幻第一次把G=G1G1带到引擎，也是根据egsr07来的，egsr07用的就是H，但到虚幻那就突然变成N了。这也是有原因的，虚幻把Schlick G当做G1，而不是用对应D项的G1,而Schlick G的确是根据N来的。\n然后heitz后面提出了joint G，heitz的paper里面当然用的H而不是N，但是，虚幻看之前非joint g的代码用的N，就copy过来了，所以现在虚幻的joint g也是用的N。\n不知为啥，unity也用的N，好像大家都用N。\n什么是漫反射 先分类\n有无折射率突变的表面 表面是否完全光滑 透射距离与观察距离的比值大小 漫反射到底是什么呢，是材质中参与介质的部分，且特指材质中透射距离非常短的部分 这个距离不是固定短的，它跟你视角观察的距离是相关的，你拿个头发看着跟实心的似得，你拿近看会发现光线还能传过去，当可透射距离小于屏幕上一个像素，那就是漫反射了。它是不是模拟微表面多重散射用的？完全不是。\n","date":"2022-05-30T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E8%BF%9B%E9%98%B6/","title":"渲染进阶"},{"content":"随手记录的一些编译原理笔记。\n现代编译器分为前后端，为了进一步降低复杂度(模块化)，前端的流程通常是：\n词法分析 -\u0026gt; 语法分析 -\u0026gt; 语义分析 上一步的输出是下一步的输入。\n词法分析 常见的应用有正则表达式。\n先定义一个映射， tokens = map(字符串)\n这个token是啥呢，比如说我有下面这个算式：\n1 + 2 * ３ 解析后：\n值 类型 １ 整数 + 加号 2 整数 * 乘号 3 整数 我们暂时不知道有什么用，但现在我们解决了字符串里的空格，如果字符串里有奇怪的字符，比如#啥的，也可以报错。\n怎么解析其实也是个大问题，通常用自动机解决这个问题。\n语法分析 把词法分析输出的一堆token，组合成句子，检查句子的语法，最后生成抽象语法树(AST)\nAST用处广泛，比如：\n编辑器错误提示 代码格式化 代码高亮 代码自动补全 ","date":"2022-05-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A8%8B%E5%BA%8F/","title":"从代码到程序"},{"content":"Windows10 提高游戏分辨率 -\u0026gt; Magpie\n统计游戏时长兼启动器 -\u0026gt; Etupirka\n用手柄玩galgame -\u0026gt; Steam Controller\n现在你获得了一个很好的体验，启动Etupirka，然后选中想玩的galgame，绑定Magpie的快捷键到手柄上，对游戏全屏，我一个Quick load，可以继续用手柄摇杆推线咯\nLinux 一个坏消息，大部分黄油开发者根本没想过Linux平台\n一个好消息，steam的Proton可以帮助我们玩到Windows上的galgame(感谢V社)\n首先在Linux上下载steam，然后添加非steam游戏，游戏设置使用Proton，然后你就可以启动游戏啦\n但实际上只有少部分黄油能打开，就算能打开还一定会伴随bug\n能打开的游戏没见过能播放op 传言有些游戏要对应Proton版本才能打开 游戏能打开，但bug太致命完全打不了 我超，汉化补丁能打开生肉却打不开，但我想全都要怎么办 游戏打不开怎么办，乱试一下吧\n游戏路径全ascii且不留空格(游戏目录也算路径) 参考这篇文章 能用Proton直接打开基本无bug游玩是最好的，如果要折腾很久才能玩我觉得真的没必要，不如用回Windows或者虚拟机(两台以上电脑是Linux用户的最优解)\n先列个能打开的黄油名单在这吧，排排坑\n名字 Pronton版本 体验 放課後シンデレラ 7.0 非常好，没遇到坑 はつゆきさくら 7.0 播放序章op闪退了一次，再打开会提示你要不要播放op，能流畅游玩 いきなりサキュバス ～いちゃらぶ搾精ライフ～ 7.0 没完整打完，暂时无bug 白昼夢の青写真 7.0 黑屏bug，如果不是一直渲染的画面就会黑屏，比如显示文字的时候，文字外的全黑 有群友推荐lutris和proton-ge，还未研究\n","date":"2022-05-09T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E5%92%8Cwindows%E4%B8%8A%E4%BC%98%E9%9B%85%E5%9C%B0%E7%8E%A9galgame/","title":"如何在Linux和Windows上优雅地玩galgame"},{"content":"录播：Chinagraph2020\n论文推荐 真实感图形渲染科研入门笔记（一）：论文推荐\n工具链与参考资料 真实感图形渲染科研入门笔记（二）：工具链与参考资料\n迈向科研的训练 离线 用Intel的Embree写一个光线追踪器 使用多重重要性采样 支持微表面材质 实现一个正确的BDPT 95%做渲染的科研人员都没写对BDPT(太难了)\n检验：和PT的结果比较\n实时 用C++封装OpenGL 支持arcball(能用鼠标拖拽的一个球，里面的物体一起动起来)，写一个VSSM 使用Optix和OpenGL实现RTRT 使用SVGF降噪 未来 材质外观的研究才刚刚开始\n现在用的基本这两种\ndiffuse + microfacet 迪士尼原则BRDF 尽管实现很简单，但第一种对真实感渲染错的离谱\n人脸的渲染也没有好的正向模型\n","date":"2022-05-04T00:00:00Z","permalink":"https://star-hengxing.github.io/p/chinagraph2020%E4%BC%9A%E5%89%8D%E8%AF%BE%E7%A8%8B-%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%A7%91%E7%A0%94%E5%85%A5%E9%97%A8-%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95/","title":"Chinagraph2020会前课程 真实感图形渲染科研入门 随手记录"},{"content":"当发现了一个好软件，但aur上没有人打包，这很难受，所以不如自己来为社区做贡献\n这次我打的包是一个appimage，理所当然去参考一些现有的appimage打包PKGBUILD\n所以先设计再编码\nPKGBULID编写 下载最新版本的软件到本地 提取appimage，把软件icon放到/usr/share/icons 制作Desktop Entry，放到/usr/share/applications 最后将软件去掉版本号，安装到常见目录（我选择了放在/opt/appimages） 是不是看起来很简单，但由于不熟悉linux和一些常用工具，一顿操作下来，花了半天才写好PKGBUILD。\n首先是学会用sed，因为appimage里自带了一个Desktop Entry，所以要进行修改。\n其次就是安装到目录的时候需要给权限目录权限，不然复制不进去。\n当上游的包没有checksum的时候，还要自己download到本地生成然后加上PKGBULID。当然makepkg然后给了个便利的命令。\n# 如果有上一个版本的checksum,先用sed删除再执行该命令 sed -i \u0026#34;$d\u0026#34; PKGBULID makepkg -g \u0026gt;\u0026gt; PKGBULID 测试 写好PKGBULID，检查能不能用。\n# 检查PKGBUILD格式 namcap PKGBUILD # 生成包 makepkg -s # 检查包是否缺少依赖等等 namcap xxx.pkg.tar.zst 检查包的时候我弹了许多报错，不知道怎么修。然后我去用namcap检查一下我参考的那个appimage包，好家伙，他的报错跟我一样。既然他没修那我也就算了吧。\n然后尝试安装\n# 生成.SRCINFO给aur仓库的页面展示，如果第一次提交没有生成，aur仓库会拒绝你的包 makepkg -i \u0026amp;\u0026amp; makepkg --printsrcinfo \u0026gt; .SRCINFO 上传 如果一切没问题，那就可以用git上传aur了（需要一个aur帐号）。\n如果会基本的git操作，下面应该都明白怎么操作。\n# 为aur创建ssh key touch ~/.ssh/config # 写入这些 Host aur.archlinux.org IdentityFile ~/.ssh/aur User aur # 生成 ssh-keygen -f ~/.ssh/aur # 首先创建一个aur项目 git clone ssh://aur@aur.archlinux.org/\u0026lt;你的包名字\u0026gt;.git git add PKGBUILD .SRCINFO git commit -m \u0026#34;init v1.x.x\u0026#34; git push 成功之后呢，你就可以尝试用paru/yay来下载了。\nReference Arch Linux 第一次打包就上手\n","date":"2022-03-02T10:03:35+08:00","permalink":"https://star-hengxing.github.io/p/aur%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95/","title":"AUR打包记录"},{"content":"至今看过最棒的关于基础色彩理论的视频\n常识 红色和黄色可以变成橙色;黄色和蓝色变成绿色;而蓝色和红色变成紫色。如果我们将这些颜色混合在一起，我们得到更多的色调，如红橙色和黄绿色。总之，它们形成了所谓的色轮。 色调是最简单的，它基本上就是我们所说的“颜色”。 饱和度是指强度，换句话说，颜色是否重叠更微妙，或者更具活力。 色值与深浅的颜色相关，从黑到白。 专业配色方案 最简单的方法是单色因为它仅使用一个颜色或色调，选择在色轮上挑选一个点，并使用饱和度和色值的知识，能够保证匹配。 相似色搭配是使用色轮中彼此相邻的色彩样式，如红色和橙色、蓝色和绿色······ 互补色彼此相对，例如，蓝色和橙色\u0026hellip;或经典的红色和绿色。为了避免互补配色方案过于简单化可以增加更轻，更深，或者一些不同饱和度的颜色。 分裂互补配色方案使用的相对颜色的双重配色，能够提升对比之外，更有趣的结果。 三元配色方案采用三种均匀分布的颜色，在色轮上形成一个完美的三角形。这些组合的效果醒目，特别是与主色或辅色的运用。 四元色搭配在色轮上形成了一个矩形，可以通过将其中的一个颜色用于主色，其余为辅色。 解决方法 色彩扎眼——选择一种颜色，并尝试调整其亮度，暗度或饱和度。 色彩过多——也许一点点色彩就可以满足你的画面需要。 色不平衡——中性颜色，如黑色，白色和灰色可以帮助您平衡画面。 实际经验 每种颜色都会发出一个信息。考虑到项目的色调，并选择一个合理的配色方案。 明亮的颜色往往能够带来有趣或现代感的效果。 低饱和度的色彩搭配经常会受到商业公司的喜爱。 你可以在各种有趣的地方找到配色方案，比如某些广告、艺术品、配色网站、周围世界，颜色无处不在。 ","date":"2022-02-07T15:25:20+08:00","permalink":"https://star-hengxing.github.io/p/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"色彩搭配的基础知识"},{"content":"重新排版了一下\n出处： 御宅族与ChaosChild症候群 - 历久弥新的文章 - 知乎 https://zhuanlan.zhihu.com/p/44592537\n御宅族已死。\n\u0026ndash;冈田斗司夫 真正的御宅族如今是否已经消亡了？我没有相关的数据情报，所以无法作出回答。然而，在我的臆测中，真正的御宅族还存在着，但不过只是很少的一部分，并且这部分人中并没有关联。 所以，在新世代宅的急速涌入下不断被稀释着。\n我也自认为真正的御宅族，然而在我全通了CHAOS;CHILD后，发觉我也不过是“ChaosChild症候群”的一员罢了。\n逃避性 无论是真正御宅族们，还是新世代的御宅族们，虽然是不同的个体，但是却进行着妄想同步。得益于网络的普及，御宅们把本我至于同一个巨大的名为御宅文化的妄想之中（网络未普及之前已经开始，不过那时候只是小型的妄想体，朋友、学校的讨论，电视活动之类）。 美好的妄想，它与严酷的现实有着天壤之别，为了生存不得不经历人世，但是，本我还有御宅文化这个桃花源，经过学习、工作的洗礼后，坐到电脑或是沙发前，打开动画亦或是游戏，全身心的投入。\n大部分的人玩游戏的时候有个特点，对于外界置若罔闻，仿佛所有感官都集中在了游戏上，而这在做其他事情的时候是很少出现的，而且并不是可以人为控制的现象。 全身心的投入妄想之中，大脑分泌刺激性神经递质，所有其他事情烦恼都被抛在脑后，此时，仿佛就是游戏中的人物。 放松，就像是在逃避，而这并没有错，我们无时无刻不想着逃避，而超我却告诉我们不行，现在并不是共产主义社会。最后，我们只得在苦劳与逃避之间无限循环。\n有的人为自己创造虚伪的现实妄想，沉溺其中，彻底的利己主义，而这你又得到了什么呢？也许你可能得到你想要的，而这个世界却更加崩坏。当然，利己主义者不会考虑这些，只会考虑自己能否享乐。\n优越性 宅文化的一些特性加上事件误导，使得它天生作为一种非主流道德亚文化，被一般人所不适，因为历史原因在我国更是如此。\n所以宅这个ChaosChild症候群群体，天生是活在一个被一般人所蔑视的妄想中，因主流文化使得宅文化变成了自卑性的妄想，而对此宅们当然要作出应激反应。 以前，所谓的真正御宅族，用各式各样，各个门类的创作证明着自身的能力性，并与社会相关联，这样，不仅在宅圈收获了虚荣并且证明给社会人自己比他们还要强。 如果是什么都不会且自控力低下不去学的人，通常情况类似宫代拓留，自诩为情报强者，在宅圈混迹获得大量情报，自以为看透了世界的真实，看不起周围的普通人，甚至包括父母，认为他们的情报量太少，包括我也是此类。\n你们这些人天天就是看这些无脑电视剧，追星，看着无聊的花边新闻，全是萌二的B站，一遍遍刷着全是垃圾信息的微博，呵，这个人还在煞有其事地看知乎啊，知乎早就和微博没区别了，哈哈，你们这些情报弱者。\n而我不同，我刚通了CHAOS；CHILD，你们这些人一辈子也接触不到这个神作吧，呵呵，通过这个游戏，我知道了……而你们就这样浑浑噩噩地活着吧，我早已看穿一切。\n而新世代宅更加常用的是自嘲的手法，死宅真恶心、肥宅快乐……在疯狂地传播下无形间降低这些词的伤害力，并成为一种调侃娱乐。 真是可笑的手法呢，本身含着自卑的群体夺取外部人的武器抢先自行使用，而造成外部人无枪可打，同时加深内部的归属感使原本那些刺耳的话也只成为了笑料……\n我与宫代拓留有着许多相似之处，不健全的家庭环境，把自己放入妄想中，吸收大量情报，在学校，身为班级下层的我却看不起班级上层的学生，找的理由和宫代差不多，进入工作后依然是如此状态，在公司，交际能力极差导致也没有人愿意主动交谈，每天中午在食堂都是一个人吃午餐，而我，却觉得这样很轻松。\n看着周围有说有笑的人们，情报强者这个武器还真是好用呢，每天使用它来填补自己的自尊心，回到家再次沉溺在妄想之中。\n矛盾性 几个人的御宅妄想无法抵抗这个社会的压力与反对，而一大群人妄想就可以做到。作为这个妄想的每个终端，每个人把自己置于其中就可以感受到整体的包容，从而抵抗外部的侵犯。 回到家，打开电脑，进入一些网站或者社交软件，看着御宅相关的东西，购买周边，放置手办，感觉安心了，此刻，我作为子体感受到了母体的包容性。即使外面的人反对御宅文化本身，因为这个妄想内部人的数量足够庞大，个体也不会慌乱，因为我们人数众多。 矛盾的是，作为处于同一个妄想下的我们，也如One World Order实验一样，自个划分起阶级。我们共同构建起名为御宅文化的妄想，然后并不是同伴，我们只是都在汲取它而已。 具体表现之一，讽刺B站，看不惯B站小学生，认为B站已经变质，却还总是上B站。其原因在于只有B站能提供足够的妄想力。 其实所谓的真正御宅也在享受着新世代宅的恩惠，新世代宅的急流涌入增大着妄想圈，不过这样也伴随着大量的副作用。这些副作用改变了御宅妄想的形态，与真正御宅一直一来所容纳自己的妄想形态产生了变异，真正御宅因妄想的变异而发生不适，所以必须要嘲讽新世代来缓解。 并且，嘲讽新世代宅还能使用优越感这个武器填补自己的自尊心。 御宅妄想的变异越严重，对于真正御宅的压力就愈发高涨，这种压力会转变为各种行为，但这些行为基本脱离不了对于新世代御宅的嘲讽与虚荣，并且企图能有另外一些真正御宅，不，不管什么人，只要能回复支持自己就行了，这样妄想不同步产生的压力就能减轻。\n而御宅文化妄想的变异是不可逆的，如今只有两种选择：\n适应不断变化的妄想，仍然沉溺其中。 脱离妄想。 而这点不只是本人的抉择，而是和每个人的经历相关，有时候轮不到你自由选择，生活会主动帮你进行选择。\n一般来说，第二种选择脱离妄想符合绝大部分人的现实情况，也符合社会主流文化的诉求，被社会所绑架的所有人也会觉得这是合理的，应该的，是一种必经阶段。\n而我可能不会这样，如同沉迷游戏的孩子不是教训孩子而是需要从家庭与父母入手解决一样，我明白我作出这样的选择是因为我家庭的不健全所导致的，并没有、也无法像正常家庭的孩子一般，按流程走人生，所以我可能会一直停留在妄想之中。\n哪个选项比较好？从社会来说，必然是第二种：\n第一种选项意味着逃避、自卑、矛盾。而第二种意味着面对、自信、成长。\n这是对于社会人来说，显而易见的答案。\n我难道不明白吗？怎么可能？但是我为什么不选第二种，是因为懦弱？逃避？也许是这样吧。\n但是我啊，总是有一种感觉，选了第二种答案就会失去一些什么……\n你们会如何选择呢？\n","date":"2022-02-07T13:08:04+08:00","permalink":"https://star-hengxing.github.io/p/%E5%BE%A1%E5%AE%85%E6%97%8F%E4%B8%8Echaoschild%E7%97%87%E5%80%99%E7%BE%A4/","title":"御宅族与ChaosChild症候群"},{"content":"Enable ARK: Survival Evolved Events -activeevent=EventName List of ARK Events Active event Command Love Evolved -activeevent=vday Eggcelect Adventure -activeevent=Easter Anniversary -activeevent=birthday Summer Bash -activeevent=Summer Fear Evolved -activeevent=FearEvolved Turkey Trial -activeevent=TurkeyTrial Winter Wonderland -activeevent=WinterWonderland ","date":"2022-02-04T13:33:27+08:00","permalink":"https://star-hengxing.github.io/p/ark-survival-evolved-%E5%BC%80%E5%90%AF%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/","title":"ARK Survival Evolved 开启活动的命令行参数"},{"content":"务必以下三连\n大変申し訳ございません 突然フォローで失礼ですが この度は,大変ご迷惑をおかけして誠に申し訳ございませんでした。ご無礼のありました段、重ねて謹んでお詫び申し上げます。今後このようなことのありませんよう誠心誠意努力して参りますので、これからもご贔屓賜りますよう重ねて宜しくお願い申し上げます ","date":"2022-01-30T14:26:50+08:00","permalink":"https://star-hengxing.github.io/p/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%92%8C%E6%97%A5%E6%9C%AC%E4%BA%BA%E4%BA%A4%E6%B5%81/","title":"当你第一次和日本人交流"},{"content":"音程（Interval） 两个音高不同的音在一起会形成音程。一个音到下一个相邻的音的距离叫二度（second）。如果距离是半音，音程叫小二度（m2）；全音就叫大二度（M2）\n单位度作为音程的冲量单位\n旋律（Melodic） -\u0026gt; 两个音一前一后发声\n和声（Harmonic） -\u0026gt; 多个音同时发声\n和弦（chord） 同时发声的音 \u0026gt;= 3 就叫和弦\nReference 精通乐理不是梦：超简单的乐理学习图解版 认识乐理：视唱练耳同步学 ","date":"2022-01-30T11:25:23+08:00","permalink":"https://star-hengxing.github.io/p/%E9%9A%8F%E6%89%8B%E8%AE%B0%E7%9A%84%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86/","title":"随手记的乐理知识"},{"content":"Run cd /path/to/AppImage chmod +x xxx.AppImage ./xxx.AppImage Extra icon ./xxx.AppImage --appimage-extract Desktop Entry For example:\n[Desktop Entry] Version=1.0 Type=Application Name=xxx Comment=A cross platform comic client. Exec=/home/\u0026lt;user\u0026gt;/Desktop/AppImages/xxx.AppImage Icon=/home/\u0026lt;user\u0026gt;/Desktop/AppImages/icons/xxx.png Terminal=false tags=Game X-AppImage-Version=1.0.0 # Copy the content to xxx.desktop mkdir -p ~/.local/share/applications touch ~/.local/share/applications/xxx.desktop ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/appimage%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"AppImage的使用"},{"content":"基本软件 工具 名字 display manager lightdm desktop environment xfce4 文本编辑器 vscode/vim/emacs 程序启动器 rofi 输入法 fcitx5 browser microsoft-edge-dev(AUR) 多线程下载 aria2 压缩包解压/查看 ark proxy clash for window(AUR) RSS fluent-reader shell zsh PDF zathura 命令行软件 描述 名字 显示目录大小 ncdu 高级版top gotop(AUR)/htop 打印彩色的十六进制 hexyl 语法高亮和行号的cat+less bat 统计目录代码量 loc 文件浏览器 ranger 比tmux更好用的单窗口多终端 zellij 新建用户 useradd -m -G wheel username passwd username ln -s /usr/bin/vim /usr/bin/vi visudo 找到# %wheel ALL=(ALL)ALL取消注释\n硬件 网卡 万物起源先上网，但有些网卡需要手动装驱动(比如我笔记本的博通网卡)\nsudo pacman -S linux-headers broadcom-wl-dkms reboot dkms status 声卡 sudo pacman -S alsa-utils pulseaudio-alsa 蓝牙 sudo pacman -S bluez bluez-utils /etc/bluetooth/main.conf [Policy] AutoEnable=true # 开机自启 联网 启动之前安装的NetworkManager\nsystemctl enable NetworkManager 图形界面 sudo pacman -S xf86-video-intel sudo pacman -S xorg sudo pacman -S xfce4 xfce4-goodies sudo pacman -S lightdm lightdm-gtk-greeter sudo systemctl enable lightdm AUR sudo pacman -S paru bash sudo pacman -S zsh sudo chsh -s /bin/zsh username 中文字体/输入法 sudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-rime 下载 sudo pacman -S aria2 # web前端(还有很多前端可供挑选) paru ariang-allinone # copy 大佬的配置 git clone https://github.com/P3TERX/aria2.conf mkdir ~/.aria2 mv aria2.conf ~/.aria2/ touch ~/.aria2/aria2.session 看aria2.conf注释配置路径 看wiki配置开机自启 Reference Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/linux%E9%85%8D%E7%BD%AE/","title":"Linux配置"},{"content":"其实大部分情况下和raytracing类似\n不同:\n几何物体的描述 光线与几何物体求交 法线的获取 Reference iq大佬的网站 ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%9F%BA%E4%BA%8Esdf%E7%9A%84raymarching/","title":"基于SDF的Raymarching"},{"content":"自学怎么说呢，我也在摸索，不过我认为先做一下CSAPP的bomb lab比较好\nbomb lab 逆向汇编破解程序\n这个作业怎么下载还有工具自己找吧，都很容易获取\n可能要用到的东西\ngdb x86指令文档 我研究的时候是边做边学，打断点，单步看汇编，不懂的指令/寄存器现场查\ntools 强大的工具 ghidra ida gdb 十六进制编辑器 bless 十六进制查看 hexyl(跨平台/终端彩色输出) 解包 arc_unpacker crass Reference 逆向工程入门简述 汇编语言简述(逆向工程) ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","title":"逆向工程"},{"content":"我的系统是ArchLinux，所以看着archwiki一路配置比较舒服\n其他系统请看官方文档\n从安装到启动 my.domain.name替换成自己的域名就行\nsudo cd /var/lib/synapse sudo -u synapse python -m synapse.app.homeserver \\ --server-name my.domain.name \\ --config-path /etc/synapse/homeserver.yaml \\ --generate-config \\ --report-stats=yes sudo systemctl start synapse.service # 服务器至少要有一个用户 register_new_matrix_user -c /etc/synapse/homeserver.yaml http://127.0.0.1:8008 这时候应该就可以用一个matrix client来连接了，这里选择element\n","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8synapse%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"使用Synapse自建聊天服务器"},{"content":"yt-dlp 一个命令行下载youtube视频软件，目前来说就他下载速度还行，其他同类工具被限速了\nTL;DR\n下载一个视频\nyt-dlp URL 不下载，查看视频下载的信息(选择画质)\nyt-dlp -F URL [BiliBili] 12Q4y1S73g: Downloading webpage [BiliBili] 12Q4y1S73g: Downloading video info page [info] Available formats for 12Q4y1S73g: format code extension resolution note 0 flv unknown 1 flv unknown 2 flv unknown 295.77MiB (best) 下载bilibili视频 Bilibili Evolved + aria2 下载视频\nBilibili Evolved提供了几种视频下载方式，我这里选择aria2\n启动aria2后，在插件里选择aria2 rpc就可以自动下载视频了\n","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91/","title":"使用命令行工具下载在线视频"},{"content":"编年史和纪传体 编年史:\n15年你，你表哥，你表妹做了哪些事情\n16年你，你表哥，你表妹做了哪些事情\n。。。。。\nN年你，你表哥，你表妹做了哪些事情\n记传使：\n15-N年，你做了什么事情\n15-N年，你表哥做了什么事情\n15-N年，你表妹做了什么事情\n小结，比喻不准确。\n断网时谷歌浏览器小游戏 谷歌浏览器输入chrome://dino/\nEnter后按空格\n就有个小游戏玩了\n甚至还有人用js写了个外挂\n乱数假文 Lorem ipsum，中文又称“乱数假文”，是指一篇常用于排版设计领域的拉丁文文章，主要的目的为测试文章或文字在不同字型、版型下看起来的效果，通常网站还没建设好时会出现这段字 -来自百度 科普\n【木鱼说129】如果你网龄够长，一定看过这张图——从「乱数假文」到「互联网第一夫人」知识科学科普\nsex English words Cunnilingus paedophilia pspanking ","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%B0%8F%E7%9F%A5%E8%AF%86/","title":"小知识"},{"content":"圆内接正多边形的面积 假设半径为R，正多边形顶点数为n\n正多边形外接圆，圆和正多边形中心点为同一位置\n将中心点对每个角连线，生成n个等腰三角形，腰长等于半径\n求出单个三角形面积，再乘以三角形数量\n$$ S = \\frac{nR^{2}sin(\\frac{2\\pi}{n})}{2} $$\n","date":"2022-01-29T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%9C%86%E5%86%85%E6%8E%A5%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/","title":"圆内接正多边形的面积"},{"content":"满足range这个concept就可以使用该函数\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;ranges\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; template \u0026lt;std::ranges::range T\u0026gt; void println(const T\u0026amp; args) { for(const auto\u0026amp; v : args) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template \u0026lt;std::ranges::range... Ts\u0026gt; void print(Ts... args) { (println(args), ...); } int main() { std::array\u0026lt;int, 10\u0026gt; arr; std::iota(arr.begin(), arr.end(), 0); std::vector\u0026lt;int\u0026gt; vec(10); std::iota(vec.begin(), vec.end(), -10); print(arr, vec); } 输出\n0 1 2 3 4 5 6 7 8 9\r-10 -9 -8 -7 -6 -5 -4 -3 -2 -1\r","date":"2022-01-11T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0stl%E5%AE%B9%E5%99%A8/","title":"一个函数打印STL容器"},{"content":"前置知识 编译链接到可执行程序一系列流程 x86架构的一些寄存器 elf头 下面工具的使用 环境配置 os: Linux\n可能会用到的工具:\ngcc(编译) ld(链接) objcopy(提取二进制) dd(写入虚拟镜像) gdb(调试) make(自动化构建) qemu(虚拟机) 大部分linux发行版都会自带大部分工具，自行安装最新版本即可\n基本介绍 目标是实现一个不依赖操作系统就能运行的二进制程序，在虚拟机屏幕显示hello world\n计算机启动，按下电源开关通电启动bios，检查硬件，没啥问题的话，bios会加载该储存设备第一个扇区的512字节(MBR)到物理内存0x7C00\n如果扇区最后两个字节是0x55和0xAA，那么说明是启动设备，否则bios会跳过该扇区\n如果装过系统的话，会发现这就是BIOS+MBR传统启动计算机方式，而现在比较“先进”的方式是UEFI启动\n最后bios使用命令jmp 0x7c00跳到我们代码，我们旅程就这样开始了\n实现 coding 汇编大体上两种语法，intel和AT\u0026amp;T，这里选择AT\u0026amp;T，如果是用intel语法，可以去找nasm等汇编器编译\n附上两个伪指令，表明是16位代码和程序开头在main\n.globl main\r.code16\r然后设置段寄存器为零，异或清零是常用的手法。为什么要清零，因为此时cpu在实模式下(real mode)，物理内存寻址是采用 段：偏移，计算方式如下\n物理地址 = 段 * 16 + 偏移\n如果我们直接设零，那么偏移量直接等于物理地址\nxorw %ax, %ax\rmovw %ax, %ds\rmovw %ax, %es\rmovw %ax, %ss\r因为现代操作系统是分页管理内存，段管理内存已经不再使用，但有时候他会以某种方式出现我们眼前\n比如：平时写C/C++程序遇到的Segmentation fault\n如何在屏幕上输出字符串呢，答案是使用bios中断\nbios中断没必要深究，当成api使用即可，使用方法就是在指定寄存器赋值，然后使用int指令和对应中断号\n这里看0x10中断指令的用法\n中断返回后，可以看到字符串按照我们的格式输出在屏幕上\n编译 这里我们使用make来管理编译流程\ngcc/ld/objcopy/dd等使用方法参考我的makefile\n编译汇编源文件为.o文件 指定程序入口函数和地址，链接成elf文件 将elf文件中代码和数据提取成纯二进制文件 然后使用dd拼接512字节的MBR\n生成全为零的512字节文件 开头刻录我们的二进制文件 最后两个字节刻录魔数 这里使用其他工具或python脚本也可以完成\n运行 qemu-system-x86_64 -no-shutdown -no-reboot -m 128M -hda \u0026lt;你的镜像\u0026gt;\rdebug 加上debug参数的启动命令\nqemu-system-x86_64 -S -s -no-shutdown -no-reboot -m 128M -hda \u0026lt;你的镜像\u0026gt;\rgdb脚本解读：设置架构-远程链接虚拟机-debug文件-在main函数打断点-显示汇编和寄存器-运行\nset architecture i386:x86-64\rtarget remote:1234\rfile build/debug/hello.elf\rbreak main\rlayout asm\rlayout regs\rcontinue\r使用gdb脚本\ngdb -q -x kernel.gdbinit\r输入si执行单条汇编指令，观察寄存器变化\nReference INT 10H AMD64 Architecture Programmer’s Manual Volume 3: General Purpose and System Instructions ","date":"2021-10-12T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E8%A3%B8%E6%9C%BA%E8%BF%90%E8%A1%8Chello-world/","title":"裸机运行Hello world"},{"content":" 部分游戏没有全通 有些gal没有吐槽 系列作品会合在一起 没有汉化 tag 的默认是生肉 内有剧透（这不是废话么） オモカゲ ～えっちなハプニング!? なんでもどんとこい!～ 译名：思影\n会社：あかべぇそふとすりぃ\nTag：汉化 萌拔 幼驯染 后宫\n空の青と白と／瞬きの夏 译名：天空的蓝与白/如梭夏日\n会社：バリスタラボ\nTag：汉化 废萌\n輪舞曲Duo -夜明けのフォルテシモ- ぷにゅぷりff 译名：天空的蓝与白/如梭夏日\n会社：ティンクルベル\nTag：汉化 百合 扶她 拔作\n神採りアルケミーマイスター 译名：神采炼金大师\n会社：エウシュリー\nTag：汉化 SLG 后宫\n放課後シンデレラ２ 译名：放学后的灰姑娘2\n会社：HOOKSOFT\nTag：废萌\n共通日常可以，个人线没对上胃口\n終わる世界とバースデイ 译名：世界末日和生日\n会社：コットンソフト\nTag：科幻 悬疑 妹系 泣系 猎奇\n演出神作，尽管推完的那天并不是自己的生日，还是被感动到哭了\n穢翼のユースティア 译名：秽翼的尤斯蒂娅\n会社：オーガスト\nTag：汉化 奇幻\nISLAND 会社：Front Wing\nTag：汉化 科幻 悬疑\nシロナガス島への帰還 译名：重返蓝鲸岛\n会社：旅の道\nTag：汉化 恐怖 悬疑 馆系\nふゆから、くるる 译名：冬旅，方冥冥\n会社：シルキーズプラス\nTag：汉化 科幻 悬疑 百合 扶她\n時計仕掛けのレイライン 译名：时钟机关的Ley-line\n会社：ユニゾンシフト：ブロッサム\nTag：汉化 傲娇\n有人讲是三部曲，但我感觉是分割商法出的三部作品，所以应该当成同一部作品对待\n在第一部中，各种遗品剧情的插入感觉有点生硬，后面有所改观。剧情最后提了一点因果律，但没有继续深入\n总的来说，算是稳扎稳打，伏笔都能完整回收，剧情高潮时一气呵成，因此可能缺乏一定的剧情深度\n最棒的是塑造了个完美的傲娇女主-憂緒，而且巨乳角色很少，治好了我的晕奶。其他女主的恋爱戏份很少，几乎可以当只有憂緒一个女主。不过一些个人线玩起来很欢乐，比如眠子\n金色ラブリッチェ 译名：金辉恋曲四重奏\n会社：Saga Planets\nTag: 汉化 废萌 后宫\n玲奈线，感觉剧情浪费人设了😢\n3p先不谈，先打炮再表白感觉不爽，后半段剧情还一点镜头都没有，变成基友主场\n在bangumi吐槽区发现一处很符合我的想法\n情弱弟\n游艺dz，鉴定为：八成废萌。剩下两成是作者多次强调的：找到属于自己的金色时光，在这短暂的日子里不留遗憾地尽情“耍帅”。虽然升华了，但可能笔力有限，情感传达不到位，有点强行点题，显得说教意味偏浓了。\n和我以前写语文作文强行点题那味了\nRewrite 译名：罚抄\n会社：Key\nFD：Rewrite Harvest festa!\n后劲很大\nはつゆきさくら 译名：初雪樱\n会社：Saga Planets\n好像勉勉强强get到新岛夕说什么，但又没说什么。最后的毕业倒是有点煽情\n毕业的时候来栖老师说，把一堆麻烦塞给男主，其实是为了让他过上正常的校园生活，这一点我倒是很赞同(谁不想过上青春的校园生活)。不过本作的日常写的一般，而且黄段子属实尬，但女主面对黄段子的演出不错，属实浪费好画风和cv了\n不过相比魔女恋爱日记好的就是，起码把故事给我讲懂了\n大部分个人线感觉良好，除了シロクマ，完全意义不明。个人最喜欢あずま 夜\nClover Day\u0026rsquo;s 译名：幸运草的约定\n会社：ALcot\n治愈废萌，可爱就完事\n幼馴染と十年、夏 译名：幼驯染与十年之夏\n会社：夜のひつじ\n短篇单线幼驯染作品，氛围不错，但我觉得还是太短了\n放課後シンデレラ 译名：放学后的灰姑娘\n会社：HOOKSOFT\n平平淡淡的废萌发糖作，共通线基本就是与女主深入了解交流（不点名批评某位女主，在共通线一直觉得操作很迷惑）\nPRIMAL×HEARTS 月幕\n译名：月色天娇\n会社：ま～まれぇど\n也是比较平平淡淡废萌作品，一开始推了駒形线，感觉不是很对胃口\n其实进线前我是二选一，所以我直接冲向歌奈线\n不行了我，麻麻的，感觉身体有电流穿过，这就是恋爱么，而且还是小恶魔学姐，一直拖着不给男主告白，却又给男主尝了点甜头，实在是太刺激了\n个人线里的冲突事件都处理的很好，很快就完事了，没有高血压操作\nかりぐらし恋愛 月幕\n译名：寄宿之恋\n会社：ASa Project\n共通线够搞笑，个人线只推了理兎，平平淡淡的发糖\n群友告诉我，说不定其他线路有意想不到的剧情了，单线战士不可取（可恶，我是纯爱党）。所以我还是去推其他线了\n好家伙，几乎每条线都能看到理兎妒忌其他女主吃醋，这不让我更爱这个美少女么，呜呜\nすぃ～と・はに～・ふぁみり～ 娘ト妻ニ甘イハ父ノ習ヒ 月幕\n译名：甜蜜家庭～妻女和宠溺父亲的每一天～\n会社：オーバードーズ\n拔作，老婆女儿孕肚play好耶\nレイジングループ 译名：人狼村之谜\n会社：KEMCO\n日式狼人杀，故事看得很上头\n灰色系列 会社：Frontwing\nグリザイアの果実 月幕\n译名：灰色的果实\n个人线都很赞，辛线是唯一看哭的（呜呜）\n蒔菜线，两个结局感觉都很痛苦（但拿狙击枪的美少女真的很帅啊，后续乐园还有狙击操作）\n天音线，懂得都懂，那段生存剧情确实很过瘾，动画制作组也懂，所以动画也花了很多精力去做这段剧情。最后面有段小高潮被人追杀，能互相为对方舍命，有点感动。好结局有一丝丝悲伤，毕竟，看到了美少女变老的场景，总觉得心，哪里很难受\nグリザイアの迷宮 月幕\n译名：灰色的迷宫\nOP最好听\nグリザイアの楽園 月幕\n译名：灰色的乐园\n战斗的美少女太帅啦\nフレラバ ～Friend to Lover～ 月幕\n译名：从朋友到恋人\n会社：Smee\nFD：フレラバ 〜Friend to Lover〜 ミニファンディスク\n甜死了甜死了，傲娇大好き\nいきなりサキュバス ～いちゃらぶ搾精ライフ～ 月幕\n译名：\n会社：ZION\n白丝巨乳萝莉魅魔，魅魔星奏的发糖续作\nChaos;Child 月幕 /萌娘百科\n译名：混沌之子\n会社：5pb.\n通关后感觉不是滋味，我实在与宮代 拓留太像了，刚好看的一篇文章也令人深思\n御宅族与ChaosChild症候群\n说的对，这就是部垃圾作品，痛击死宅罢了\nRemember11 -The Age of Infinity- 月幕 /中文版解密篇网站\n译名：Remember11：无限轮回的时光\n会社：KID\n从艺术方面看，即使解密篇没有出，但刚刚好完成了困住玩家的这个目标 从商业作品看，确实是部不完整的作品 但对于我来说，在我认为的神作中排第一\nEver17 —the out of infinity— 译名：Ever17—时空轮回\n会社：KID\n约定好不要剧透\n出会って5分は俺のもの！時間停止と不可避な運命 译名：相遇之后的5分钟属于我！时间停止与不可避的命运\n会社：Hulotte\n白毛萝莉妙啊\nキミのとなりで恋してる 译名：慕情之心今随君作伴\n会社：ALcot ハニカム\nFD：キミのとなりで恋してる！ -THE RESPECTIVE HAPPINESS-\n理想中的幼驯染\n車輪の国、悠久の少年少女 译名：车轮之国：悠久之少男少女\n会社：AKABEiSOFT2\n不会日语，还好早就被剧透了游戏的最后一句话，毕竟这句话是真的man\n車輪の国、向日葵の少女 译名：车轮之国：向日葵的少女\n会社：AKABEiSOFT2\n05年画风也真好看\nG線上の魔王 译名：G弦上的魔王\n会社：AKABEiSOFT2\n带有叙诡类型的游戏玩的少，所以智斗代入感非常强，看的也很爽\nきまぐれテンプテーション 译名：异想魅惑\n会社：Silky\u0026rsquo;s Plus WASABI\nnaizi好晃\nきゃらぶれーしょん！ ～乙女は恋してキャラぶれる～ 译名：恋爱少女人格崩坏\n会社：AKABEiSOFT3\n表里不一（\n抖m狂喜\neuphoria 译名：乐园\n会社：CLOCKUP\n第一次碰猎奇作品，感觉慢慢能接受？\n倉野くんちのふたご事情 译名：仓野家的双子情事\n会社：CUBE\n妹妹可爱\n3days～満ちてゆく刻の彼方で～ 译名：3days～在逝去时间的另一端～\n会社：Lass\n死了N次，还是得看攻略啊（\n君と彼女と彼女の恋 译名：你和她和她的恋爱\n会社：Nitro+\n打到困住轮回里就没怎么打了\nSummer Pockets 译名：夏日口袋\n会社：Key\nKey社换画师后画风好了很多\n恋×シンアイ彼女 译名：想要传达给你的爱恋\n会社：Us:track\n彩音线好甜\n魔女こいにっき 译名：魔女恋爱日记\n会社：Qoobrand\n故事没看懂\u0026hellip;\nオトメ＊ドメイン 译名：少女领域\n会社：Palette\n忘却執事と恋するお嬢様の回想録 译名：忘却管家与恋爱大小姐的回忆录\n会社：Campus\n僕と恋するポンコツアクマ。すっごいえっち 译名：与我恋爱的废材恶魔\n会社：Smile\n太拔勒，虚了\nイブニクル 译名：夏娃年代记1\n会社：Alicesoft\n打怪升级玩上瘾了，已经三周目\n","date":"2021-09-19T00:00:00Z","permalink":"https://star-hengxing.github.io/p/galgame%E6%B8%B8%E7%8E%A9%E8%AE%B0%E5%BD%95/","title":"galgame游玩记录"},{"content":"配置 虚拟机: Oracle VM VirtualBox 笔记本：UEFI启动 镜像: 官网 前提 了解UEFI还是BIOS启动，不同的启动方式对应不同的步骤 基本的linux命令行操作和知识 足够耐心 善用archwiki 安装 联网 wifi配置麻烦，强烈建议网线或者手机usb联网\nip link 然后ping查看联网是否成功\nping baidu.com 更新系统时间 timedatectl set-ntp true timedatectl status # 检查服务状态 硬盘分区 硬盘分区工具有很多，推荐小白使用cfdisk\n查看硬盘用lsblk\n在分区前，需了解swap(分区)，区别linux根分区和windows盘符的概念\n如果是UEFI启动，需要分一个EFI区，而BIOS则不用\n分区步骤大概就是：new-\u0026gt;分大小-\u0026gt;改类型-\u0026gt;保存-\u0026gt;格式化-\u0026gt;挂载\nEFI分区和正常分区格式化工具不一样\n根分区需要首先挂载\nswap区看需求分(格式化和挂载是单独命令使用)\n添加国内镜像加速 vim /etc/pacman.d/mirrorlist # 添加 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.zju.edu.cn/archlinux/$repo/os/$arch 安装基本包 pacstrap /mnt base linux linux-firmware 在此步骤可以考虑把常用软件装了(vim/networkmanager/sudo)\n配置Fstab genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab # 检查 change root 切换到自己系统\narch-chroot /mnt 设置时区 # Asia和Shanghai按需替换 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 设置Locale # 把需要用的注释取消 vim /etc/locale.gen # 当前使用的locale echo LANG=en_US.UTF-8 \u0026gt;\u0026gt; /etc/locale.conf # 初始化 locale-gen 设置root密码 passwd # 密码不回显 网络配置 # myhostname替换自己主机名 echo myhostname \u0026gt;\u0026gt; /etc/hostname vim /etc/hosts 添加 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyhostname.localdomain\tmyhostname # 主机名.本地域名 主机名 安装引导程序 grub 不使用grub启动 ps:用这个方法前，假如你是intel-cpu，需要先安装intel-ucode\nbootctl install # 添加 vim /boot/loader/loader.conf default arch timeout 4 # 添加 vim /boot/loader/entries/arch.conf title Arch Linux linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux.img options root=根分区路径 rw # 例如/dev/sda2 重新启动 exit poweroff/reboot 拔掉u盘，等待弹出tty终端，要求输入账户密码登录\n因为我是UEFI引导，所以笔记本需要更改启动方式为UEFI，而不使用BIOS，\nReference 以官方Wiki的方式安装ArchLinux ","date":"2021-08-02T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E8%AE%B0%E5%BD%95%E5%AE%89%E8%A3%85arch%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"记录安装arch的过程"},{"content":"在一些基础的光线追踪教程中，光线求交通常发生在世界空间(world space)\n但在离线渲染器中(比如PBRT)，光线求交发生在几何图形自己的局部空间(local/object/model space)\n这是有好处的，比如说简化求交代码，相交表面的normal和uv也很容易计算\n下面就记录一些几何求交的做法，自身经验有限，如有错误请指出\n前提 这里采用的是y轴朝上的右手坐标系，-z轴指向屏幕里，x轴在右手 默认光线已经变换到对象的局部空间 使用几何体的变换矩阵和其逆矩阵，求交时将光线变换到对象空间\n$$ Ray(t)=o+td (t \u0026gt; 0) $$\n$$ Ray_{object}=M^{-1}Ray_{world} $$\n矩形(Rectangle) 假设矩形高度为0，躺在xz平面上。长和宽控制矩形大小\n忽略平行于平面的光线\nif(is_zero(ray.direction.y)) return false; 使用高度计算相交点 $$ t=\\frac{0 - o_{y}}{d_{y}} $$\nconst auto t = ray.inv_at\u0026lt;Axis::Y\u0026gt;(0); const auto [x, y, z] = ray.at(t); 在矩形范围内的点才算相交成功\nif(std::abs(x) \u0026gt; length || std::abs(z) \u0026gt; width) return false; 球(Sphere) 假设球心在原点，半径控制球的大小\n三维空间中球的一般方程 $$ x^{2}+y^{2}+z^{2}=r^{2} $$\n将光线代入方程 $$ (o+td)^{2}=r^{2} $$\n整理可得关于t的一元二次方程 $$ d^{2}t^{2}+2odt+o^{2}-r^{2}=0\\ \\begin{align*} \u0026amp; a=d^{2}\\ \u0026amp; b=2od\\ \u0026amp; c=o^{2}-r^{2} \\end{align*} $$\n假如光线的方向向量已经归一化，那么 $$ |\\overrightarrow{d}|^{2}=1 $$\nconst auto a = 1; const auto b = 2 * dot(ray.origin, ray.direction); const auto c = dot(ray.origin, ray.origin) - radius * radius; 解一元二次方程，没有解则求交失败\nconst auto result = quadratic(a, b, c); if(!result) return false; 有解则找到最近的交点\nconst auto [x1, x2] = result.value(); const auto t = min(x1, x2); 圆柱(Cylinder) 假设圆柱底面在xz平面，底面圆心在原点，半径和高度控制圆柱大小和长度，phi表示圆柱曲面的完整度\n首先忽略y轴，求出相交点是否在圆柱底面\n圆柱底面的一般方程 $$ x^{2}+z^{2}=r^{2} $$\n将光线代入，同理可得 $$ (d_{x}^{2}+d_{z}^{2})t^{2}+2(o_{x}d_{x}+o_{z}d_{z})t+o_{x}^{2}+o_{z}^{2}-r^{2}=0 $$\n日常解一元二次方程\n$$ \\begin{align*} \u0026amp; a = d_{x}^{2}+d_{z}^{2}\\ \u0026amp; b = 2(o_{x}d_{x}+o_{z}d_{z})\\ \u0026amp; c = o_{x}^{2}+o_{z}^{2}-r^{2} \\end{align*} $$\nconst auto a = dx * dx + dz * dz; const auto b = 2 * (ox * dx + oz * dz); const auto c = ox * ox + oz * oz - radius * radius; const auto result = quadratic(a, b, c); if(!result) return false; 计算相交点高度判断是否在范围内，先从最小t开始\nauto [x1, x2] = result.value(); if(x1 \u0026gt; x2) std::swap(x1, x2); auto t = x1; auto [x, y, z] = ray.at(t); auto phi = std::atan2(z, x); if(phi \u0026lt; 0) phi += 2 * PI\u0026lt;f32\u0026gt;; 假如第一个x1不符合条件，需要对x2继续进行判断\nif(y \u0026lt; min_height || y \u0026gt; max_height || phi \u0026gt; max_angle) { t = x2; auto [x, y, z] = ray.at(t); phi = std::atan2(z, x); if(phi \u0026lt; 0) phi += 2 * PI\u0026lt;f32\u0026gt;; if(y \u0026lt; min_height || y \u0026gt; max_height || phi \u0026gt; max_angle) return false; } 小提示：当圆柱曲面不是封闭的时候，所求相交点有可能在圆柱内部，这时需要反转(flip)法线才能进行正确的着色\n顶盖和底盖(Cap) 这时候圆柱求交算是基本完成了，但渲染的时候又发现一个问题，圆柱没有顶盖和底盖，也就是二维曲面并不是封闭的，因为圆柱体是一个退化的二维曲面\n这时候相当于加入了两个圆盘(Disk)\n如果在之前与圆柱曲面相交了，需要传入t与这次求交所得cap_t判断哪个最近\nconst auto intersect = [\u0026amp;](f32 cap_t) { if(cap_t \u0026gt;= t || cap_t \u0026lt;= 0) return; if(!check_cap(ray, cap_t)) return; t = cap_t; }; 我们可以增加一个枚举变量cylinder_shape，来表示需要圆柱的顶面/底面，或者说我全都要也行\nif(cylinder_shape \u0026amp; cylinder_top) intersect(ray.inv_at\u0026lt;Axis::Y\u0026gt;(max_height)); if(cylinder_shape \u0026amp; cylinder_bottom) intersect(ray.inv_at\u0026lt;Axis::Y\u0026gt;(min_height)); 圆盘求交也很简单 $$ x^{2}+z^{2} \\leq r^{2} $$\nbool Cylinder::check_cap(const Ray3f\u0026amp; ray, f32 t) const { const auto x = ray.at\u0026lt;Axis::X\u0026gt;(t); const auto z = ray.at\u0026lt;Axis::Z\u0026gt;(t); return (x * x + z * z) \u0026lt;= radius * radius; } Reference Physically Based Rendering: From Theory to Implementation The Ray Tracer Challenge ","date":"2021-04-11T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E5%85%89%E7%BA%BF%E4%B8%8E%E5%90%84%E7%A7%8D%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E6%B1%82%E4%BA%A4/","title":"光线与各种几何图形求交"},{"content":"GAMES101:现代计算机图形学入门 网课，可在b站上观看\nassignment 5-7 是光线追踪的作业\n如果对光栅化，几何，动画与模拟，不感兴趣，可以只看Lecture 13-20（个人建议：把整套课看完也是不错的）\nTaichi课程 课程主页\n网课，其中6-7讲涉及光线追踪\nPeter Shirley写的光线追踪三部曲 Ray Tracing in One Weekend Ray Tracing: The Next Week Ray Tracing: The Rest of Your Life 书中配套代码，在网上能搜到这三本的笔记和翻译版本\n我认为这是光线追踪入门的最好教程\nDaily Pathtracer Aras Pranckevičius大佬写的教程\n介绍 博客\nNori an educational ray tracer\n主页\n5个assignment\nPBRT Physically Based Rendering:From Theory To Implementation\n这本书是学习离线渲染系统书（离线渲染圣经），配套代码在github上\n网上在线阅读\n此为光线追踪进阶书籍\n书 Ray Tracing Gems Advanced global illumination Fundamentals of Computer Graphics Real-Time Rendering 全局光照技术 杂类 github上收集的图形学资料 milo yip的用JavaScript玩转计算机图形学-光线追踪入门 scratchapixel，图形学网站，对细节讲解很详细，配套代码 99行代码写出路径追踪-smallpt real-time-rendering，网站内附带很多图形学资料 mitsuba,一个开源渲染器 stackexchange的计算机图形学板块 ","date":"2020-12-16T00:00:00Z","permalink":"https://star-hengxing.github.io/p/%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/","title":"离线渲染-光线追踪框架学习资料"}]