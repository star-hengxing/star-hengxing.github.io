<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 恒星的小站</title>
    <link>https://star-hengxing.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 恒星的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 04 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://star-hengxing.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Xmake 常见问题解答</title>
      <link>https://star-hengxing.github.io/p/xmake-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</link>
      <pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/xmake-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</guid>
      <description>如果在本文没找到解答，可以去 github 提 issue 和讨论区搜索。
如果是官方包管理的问题，或者想请求加入一些包，去 xmake-repo 提 issue。
提 issue 请附带 log，xmake -vD命令可以输出详细的 log 信息。
如何一键编译运行 在 target 下加入以下代码：
before_run(function (target) os.execv(&amp;#34;xmake build &amp;#34; .. target:name()) end) -- xmake run target 反过来也可以
after_build(function (target) os.execv(&amp;#34;xmake run &amp;#34; .. target:name()) end) -- xmake IDE(vscode/vs)不显示头文件 给 target 加上add_headerfiles(&amp;quot;**.h)
vs工程 自动更新 sln。 add_rules(&amp;#34;plugin.vsxmake.autoupdate&amp;#34;) 使用set_group可以给代码结构分组。 如何在脚本域添加文件 只能在on_load添加，并且需要确保路径正确。
因为描述域的add_files()和脚本域的target:add(&amp;quot;files&amp;quot;)有一些差异，并不会做路径转换。
后者接口可能会在任何地方使用，所以路径只能用os.projectdir或者os.scriptdir进行拼接路径。
此外，需要确保该 target 已经应用了一个编译规则，否则不会根据后缀名去添加文件。
比如你在脚本域添加 .cpp 文件，那么首先在描述域添加add_rules(&amp;quot;c++&amp;quot;)。
有些远程包为什么没有拉预编译版本 众所周知 c++ 编译器编译出的二进制有 abi 问题，同一个编译器不同版本都可能不兼容，所以当预编译库的编译器版本（github ci 编译）和本地编译器版本不一致的时候，会拉取源码进行编译。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 胡言乱语X2</title>
      <link>https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx2/</link>
      <pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx2/</guid>
      <description>子标题：理解 std::move 和所有权。
前言 关于 std::move 其实也有很多文章了，不过为了给群友解释，再造一次轮子。
std::move 我们打开 std::move 的实现，发现里面是一个强制类型转换（随便找的代码）。
template &amp;lt;typename T&amp;gt; typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; arg) { return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(arg); } 使用：
Object A; Object B = std::move(A); 这右值有啥用啊？假设 Object 类有以下构造函数：
// 函数1 Object(const Object&amp;amp; object); // 函数2 Object(Object&amp;amp;&amp;amp; object); 如果没有std::move(A)这一步，那么B将会调用函数1进行构造，反之调用函数2。
但分开两个构造函数是干什么呢，这里就牵涉到一个资源分配和所有权问题。
所有权 假如你是A，你从宠物商店买了一只仓鼠回来（仓鼠挺可爱的），那你就成为了这只仓鼠的主人。
B是你的好朋友，他经常到你家玩。他觉得你的仓鼠很可爱，于是他也想买一只，但是他没有足够的钱。
分支路线1： 可是突然有一天，你不想养这只仓鼠了，就想找个人帮你继续养下去。你知道B也想养一只属于自己的仓鼠，但没有钱去买。于是你找来了B，将仓鼠送给了他。
那么B从这天起，就成为了仓鼠的第二任主人了。
分支路线2： 有一天B打工赚了许多钱，于是他去问你这只仓鼠是什么品种，然后自己到宠物商店买了一只差不多一样的。
现在又有一只小仓鼠找到了新家了。
回到主题，在上面，抽象来讲，买了一只仓鼠，其实就是分配了一个资源，你就拥有了他的使用权（所有权）。
分支路线1中，A把仓鼠送给了B，这就是转移了仓鼠的所有权，主人从A变成了B，对应Object(Object&amp;amp;&amp;amp; object)。
分支路线2中，B也买了一只仓鼠，这样两只仓鼠，都有了各自的主人，对应Object(const Object&amp;amp; object)。
要知道买一只新仓鼠是要花钱的，所以在某些场景用 std::move 来节省这个资源的开销。
但仓鼠毕竟是别人养过的，想要一只独一无二属于自己的小仓鼠，那就买一只新的吧，所以就需要申请一份新的资源。
后记 理解所有权后，就像学数据结构学会了链表。学习新的知识，第一步总是最难的。</description>
    </item>
    
    <item>
      <title>使用 Xmake 作为 CS149 作业的 bulild system</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/</link>
      <pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/</guid>
      <description>前言 CS149 是一个教并行编程的课程，课程作业使用了 makefile 作为 build system。
本文通过改造 build system 来讲述一些xmake的使用方法。
分析 这个课程主要有四个作业，那么是一个多target工程，考虑用多级配置。
作业里用到了很多工具，xmake都支持这些工具链。不过有些作业不跨平台（只能在 Linux 下运行），所以尽可能地将作业移植到 windows 上。
改造 完整配置在GitHub上，这里选讲几个部分。
根目录配置 最小xmake版本。 set_xmakever(&amp;#34;2.7.5&amp;#34;) 跨平台首选clang作为 C++ 编译器，在 windows 下使用clang-cl接受 msvc 风格的参数。 在开发环境下，链接动态库可以减少二进制体积，加速链接。 添加宏定义处理一些 windows 的屎。 if is_plat(&amp;#34;windows&amp;#34;) then -- set_toolchains(&amp;#34;clang-cl&amp;#34;) set_runtimes(&amp;#34;MD&amp;#34;) add_defines(&amp;#34;_CRT_SECURE_NO_WARNINGS&amp;#34;, &amp;#34;NOMINMAX&amp;#34;) else -- set_toolchains(&amp;#34;clang&amp;#34;) end 源码目录配置 考虑到 windows 没有getopt.h，这里在 github 上随便找了一个库代替，并开放头文件权限给依赖此库的target使用。 if is_plat(&amp;#34;windows&amp;#34;) then target(&amp;#34;getopt&amp;#34;) set_kind(&amp;#34;static&amp;#34;) add_includedirs(&amp;#34;getopt-for-windows&amp;#34;, {public = true}) add_files(&amp;#34;getopt-for-windows/getopt.c&amp;#34;) target_end() end 作业1 作业有多个target，其实可以考虑每个给每个target单独一个配置，不过这里选择把多个target都放在同一个xmake.lua中。
根据原始 makefile 参数，处理一些跨平台配置。 考虑到作业会生成 ppm 格式的图片，所以改变该target的运行目录。 target(&amp;#34;mandelbrot&amp;#34;) set_kind(&amp;#34;binary&amp;#34;) add_files(&amp;#34;prog1_mandelbrot_threads/*.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 胡言乱语X1</title>
      <link>https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx1/</link>
      <pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx1/</guid>
      <description>某些 STL 容器 在刷 leetcode，其中某道题中的代码片段是这样的
string res; res.resize(size - i); // res.reserve(size - i); for (int j = 0; i &amp;lt; size; i += 1, j += 1) { res[j] = arr[i] + &amp;#39;0&amp;#39;; // res.push_back(arr[i] + &amp;#39;0&amp;#39;); } 没注释的代码比注释的快了几ms，原因如下
因为容器一开始是空的，不需要考虑拷贝原来的元素
resize 重新分配内存并且默认初始化，size 改变（大概开销 malloc + memset） reserve 重新分配了内存，不初始化，size 不变 push_back 需要检查 size 有没有大于 capacity，多了分支的开销 然而这里代码也不是最快的，思考一下，这里 resize 还多了一个 memset 的开销，所以最优解应该是，用自己写的 vector（逃
不知道是历史原因还是标准委员会根本没考虑到，应该加多几个函数来表示需不需要初始化
改造容器 这里先看一个别人家的 vector：Less
看一下某个代码片段
struct default_init_t {}; inline constexpr default_init_t default_init; struct with_capacity_t {}; inline constexpr with_capacity_t with_capacity; vector(default_init_t, size_type const size) { this-&amp;gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T; }); } vector(size_type size) { this-&amp;gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T(); }); } vector(with_capacity_t, size_type const capacity) { this-&amp;gt;construct(0u, capacity, [](auto, auto) {}); } vector(size_type size, T const&amp;amp; value) { this-&amp;gt;construct(size, size, [&amp;amp;](auto p, auto) { new (p, placement_tag) T(value); }); } 思考🤔，直接把一个结构体类型作为参数？算了直接去 c++ 群问一下</description>
    </item>
    
    <item>
      <title>多态</title>
      <link>https://star-hengxing.github.io/p/%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%A4%9A%E6%80%81/</guid>
      <description>起因 在实现我的离线渲染器中，用到了大量oop（其实就是基类然后继承）
我有一个Shape基类，里面接口全声明为标准的纯虚函数接口
virtual TYPE FUNCTION() const = 0; 当你继承这个类后，继承类必须实现这个接口，不然编译报错
一开始还没有写实现，但类已经继承了，没办法，在接口开个洞（真难看啊
virtual TYPE FUNCTION() const {} 于是我基于 C++20 标准库的source_location写了一个
[[noreturn]] inline void unimplemented(const std::source_location location = std::source_location::current()) { std::cerr &amp;lt;&amp;lt; &amp;#39;\n&amp;#39; &amp;lt;&amp;lt; &amp;#39;[&amp;#39; &amp;lt;&amp;lt; location.file_name() &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; location.line() &amp;lt;&amp;lt; &amp;#34;] &amp;#34; &amp;lt;&amp;lt; location.function_name() &amp;lt;&amp;lt; &amp;#34; unimplemented!\n&amp;#34;; exit(-1); } 还没有实现接口的时候留下unimplemented，然后运行时报错
source_location暂时只有clang不支持（clang对C++20支持太慢了
网上冲浪时看到有人说，接口虚函数实现动态多态是一种糟糕实践，优雅的做法是Existential Type，在C++社区称为sean parent polymorphism
详细可以看这个视频
John Bandela “Polymorphism != Virtual: Easy, Flexible Runtime Polymorphism Without Inheritance”
reddit上的关于该视频的讨论
什么是多态 特定多态 Ad hoc polymorphism</description>
    </item>
    
    <item>
      <title>一个函数打印STL容器</title>
      <link>https://star-hengxing.github.io/p/%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0stl%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0stl%E5%AE%B9%E5%99%A8/</guid>
      <description>满足range这个concept就可以使用该函数
#include &amp;lt;iostream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;ranges&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;array&amp;gt; template &amp;lt;std::ranges::range T&amp;gt; void println(const T&amp;amp; args) { for(const auto&amp;amp; v : args) { std::cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } template &amp;lt;std::ranges::range... Ts&amp;gt; void print(Ts... args) { (println(args), ...); } int main() { std::array&amp;lt;int, 10&amp;gt; arr; std::iota(arr.begin(), arr.end(), 0); std::vector&amp;lt;int&amp;gt; vec(10); std::iota(vec.begin(), vec.end(), -10); print(arr, vec); } 输出
0 1 2 3 4 5 6 7 8 9-10 -9 -8 -7 -6 -5 -4 -3 -2 -1</description>
    </item>
    
  </channel>
</rss>
