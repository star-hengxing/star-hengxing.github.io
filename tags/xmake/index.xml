<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xmake on 恒星的小站</title>
    <link>https://star-hengxing.github.io/tags/xmake/</link>
    <description>Recent content in Xmake on 恒星的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 04 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://star-hengxing.github.io/tags/xmake/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Xmake 常见问题解答</title>
      <link>https://star-hengxing.github.io/p/xmake-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</link>
      <pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/xmake-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</guid>
      <description>如果在本文没找到解答，可以去 github 提 issue 和讨论区搜索。
如果是官方包管理的问题，或者想请求加入一些包，去 xmake-repo 提 issue。
提 issue 请附带 log，xmake -vD命令可以输出详细的 log 信息。
如何一键编译运行 在 target 下加入以下代码：
before_run(function (target) os.execv(&amp;#34;xmake build &amp;#34; .. target:name()) end) -- xmake run target 反过来也可以
after_build(function (target) os.execv(&amp;#34;xmake run &amp;#34; .. target:name()) end) -- xmake IDE(vscode/vs)不显示头文件 给 target 加上add_headerfiles(&amp;quot;**.h)
vs工程 自动更新 sln。 add_rules(&amp;#34;plugin.vsxmake.autoupdate&amp;#34;) 使用set_group可以给代码结构分组。 如何在脚本域添加文件 只能在on_load添加，并且需要确保路径正确。
因为描述域的add_files()和脚本域的target:add(&amp;quot;files&amp;quot;)有一些差异，并不会做路径转换。
后者接口可能会在任何地方使用，所以路径只能用os.projectdir或者os.scriptdir进行拼接路径。
此外，需要确保该 target 已经应用了一个编译规则，否则不会根据后缀名去添加文件。
比如你在脚本域添加 .cpp 文件，那么首先在描述域添加add_rules(&amp;quot;c++&amp;quot;)。
有些远程包为什么没有拉预编译版本 众所周知 c++ 编译器编译出的二进制有 abi 问题，同一个编译器不同版本都可能不兼容，所以当预编译库的编译器版本（github ci 编译）和本地编译器版本不一致的时候，会拉取源码进行编译。</description>
    </item>
    
    <item>
      <title>使用 Xmake 生成静态和动态库</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>前言 当前环境在 Windows，默认了解 C/C++ 编译流程。 不一定是最佳实践。 静态库 target 下直接考虑用set_kind(&amp;quot;static&amp;quot;)即可。
有一个可以注意的地方，可以使用set_policy(&amp;quot;build.merge_archive&amp;quot;, true)来合并所有静态库。（大概是用在分发二进制的时候？）
动态库 考虑到 windows dll 要在函数声明__declspec(dllexport)导出接口（也可以用.def文件）。
手动给每个符号声明很麻烦，需要 build system 来自动化。
xmake 对此做了支持，只需要在 target 下添加：
-- C add_rules(&amp;#34;utils.symbols.export_all&amp;#34;) -- C++ add_rules(&amp;#34;utils.symbols.export_all&amp;#34;, {export_classes = true}) 就会生成正确 dll 文件了。
如果想要自定义导出符号，使用utils.symbols.export_list。
直接配置 假设test目录下是一个库，把上面静态库和动态库的用法结合起来：
add_includedirs(&amp;#34;include&amp;#34;, {public = true}) target(&amp;#34;add&amp;#34;) set_kind(&amp;#34;$(kind)&amp;#34;) add_files(&amp;#34;src/add.cpp&amp;#34;) if is_kind(&amp;#34;shared&amp;#34;) and is_plat(&amp;#34;windows&amp;#34;) then add_rules(&amp;#34;utils.symbols.export_all&amp;#34;, {export_classes = true}) end target(&amp;#34;sub&amp;#34;) set_kind(&amp;#34;$(kind)&amp;#34;) add_files(&amp;#34;src/sub.cpp&amp;#34;) if is_kind(&amp;#34;shared&amp;#34;) and is_plat(&amp;#34;windows&amp;#34;) then add_rules(&amp;#34;utils.symbols.export_all&amp;#34;, {export_classes = true}) end target(&amp;#34;test&amp;#34;) set_kind(&amp;#34;$(kind)&amp;#34;) add_files(&amp;#34;src/test.</description>
    </item>
    
    <item>
      <title>使用 Xmake 作为 CS149 作业的 bulild system</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/</link>
      <pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/</guid>
      <description>前言 CS149 是一个教并行编程的课程，课程作业使用了 makefile 作为 build system。
本文通过改造 build system 来讲述一些xmake的使用方法。
分析 这个课程主要有四个作业，那么是一个多target工程，考虑用多级配置。
作业里用到了很多工具，xmake都支持这些工具链。不过有些作业不跨平台（只能在 Linux 下运行），所以尽可能地将作业移植到 windows 上。
改造 完整配置在GitHub上，这里选讲几个部分。
根目录配置 最小xmake版本。 set_xmakever(&amp;#34;2.7.5&amp;#34;) 跨平台首选clang作为 C++ 编译器，在 windows 下使用clang-cl接受 msvc 风格的参数。 在开发环境下，链接动态库可以减少二进制体积，加速链接。 添加宏定义处理一些 windows 的屎。 if is_plat(&amp;#34;windows&amp;#34;) then -- set_toolchains(&amp;#34;clang-cl&amp;#34;) set_runtimes(&amp;#34;MD&amp;#34;) add_defines(&amp;#34;_CRT_SECURE_NO_WARNINGS&amp;#34;, &amp;#34;NOMINMAX&amp;#34;) else -- set_toolchains(&amp;#34;clang&amp;#34;) end 源码目录配置 考虑到 windows 没有getopt.h，这里在 github 上随便找了一个库代替，并开放头文件权限给依赖此库的target使用。 if is_plat(&amp;#34;windows&amp;#34;) then target(&amp;#34;getopt&amp;#34;) set_kind(&amp;#34;static&amp;#34;) add_includedirs(&amp;#34;getopt-for-windows&amp;#34;, {public = true}) add_files(&amp;#34;getopt-for-windows/getopt.c&amp;#34;) target_end() end 作业1 作业有多个target，其实可以考虑每个给每个target单独一个配置，不过这里选择把多个target都放在同一个xmake.lua中。
根据原始 makefile 参数，处理一些跨平台配置。 考虑到作业会生成 ppm 格式的图片，所以改变该target的运行目录。 target(&amp;#34;mandelbrot&amp;#34;) set_kind(&amp;#34;binary&amp;#34;) add_files(&amp;#34;prog1_mandelbrot_threads/*.</description>
    </item>
    
  </channel>
</rss>
