<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 恒星的小站</title>
    <link>https://star-hengxing.github.io/post/</link>
    <description>Recent content in Posts on 恒星的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 04 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://star-hengxing.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 Xmake 生成静态和动态库</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>前言 当前环境在 Windows，默认了解 C/C++ 编译流程。
静态库 target 下直接考虑用set_kind(&amp;quot;static&amp;quot;)即可。
有一个可以注意的地方，可以使用set_policy(&amp;quot;build.merge_archive&amp;quot;, true)来合并所有静态库。（大概是用在分发二进制的时候？）
动态库 C 考虑到 windows dll 要在函数声明__declspec(dllexport)才能导出接口（当然不止这个方法）。
xmake 对 C 语言做了支持，不用手动声明，只要在 target 下添加：
add_rules(&amp;#34;utils.symbols.export_all&amp;#34;) 如果想要自定义导出的符号，使用utils.symbols.export_list，参考文档
C++ 众所周知 C++ 的符号比较复杂（毕竟有重载这一大特性），所以 xmake 暂未支持。
那还是用回上述方案，通常我们定义这样一个宏：
#ifdef _WIN32 #ifdef LIBRARY_EXPORTS #define LIBRARY_API __declspec(dllexport) #else #define LIBRARY_API // #define LIBRARY_API __declspec(dllimport) #endif #elif #define LIBRARY_API #endif 然后在函数声明加上：
LIBRARY_API auto read_file(const char* filename) -&amp;gt; std::tuple&amp;lt;std::unique_ptr&amp;lt;char[]&amp;gt;, size_t&amp;gt;; 如果没有修饰函数，即使用了set_kind(&amp;quot;shared&amp;quot;)，当程序调用 dll 里的 api 的时候会直接崩溃。
然后在库xmake.lua写：
add_includedirs(&amp;#34;include&amp;#34;, {public = true}) option(&amp;#34;shared&amp;#34;) set_default(false) set_showmenu(true) set_description(&amp;#34;Enable shared library (default: false)&amp;#34;) option_end() function my_config(target) if has_config(&amp;#34;shared&amp;#34;) then target:set(&amp;#34;kind&amp;#34;, &amp;#34;shared&amp;#34;) if is_plat(&amp;#34;windows&amp;#34;) then target:add(&amp;#34;defines&amp;#34;, &amp;#34;LIBRARY_EXPORTS&amp;#34;) end else target:set(&amp;#34;kind&amp;#34;, &amp;#34;static&amp;#34;) end end target(&amp;#34;add&amp;#34;) add_files(&amp;#34;src/add.</description>
    </item>
    
    <item>
      <title>使用 Xmake 作为 CS149 作业的 bulild system</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/</link>
      <pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8-xmake-%E4%BD%9C%E4%B8%BA-cs149-%E4%BD%9C%E4%B8%9A%E7%9A%84-bulild-system/</guid>
      <description>前言 CS149 是一个教并行编程的课程，课程作业使用了 makefile 作为 build system。
本文通过改造 build system 来讲述一些xmake的使用方法。
分析 这个课程主要有四个作业，那么是一个多target工程，考虑用多级配置。
作业里用到了很多工具，xmake都支持这些工具链。不过有些作业不跨平台（只能在 Linux 下运行），所以尽可能地将作业移植到 windows 上。
改造 完整配置在GitHub上，这里选讲几个部分。
根目录配置 最小xmake版本。ispc编译在这个版本后支持。 set_xmakever(&amp;#34;2.7.3&amp;#34;) 跨平台首选clang作为 C++ 编译器，在 windows 下使用clang-cl接受 msvc 风格的参数。 在开发环境下，链接动态库可以减少二进制体积，加速链接。 添加宏定义处理一些 windows 的屎。 if is_os(&amp;#34;windows&amp;#34;) then set_toolchains(&amp;#34;clang-cl&amp;#34;) set_runtimes(&amp;#34;MD&amp;#34;) add_defines(&amp;#34;_CRT_SECURE_NO_WARNINGS&amp;#34;, &amp;#34;NOMINMAX&amp;#34;) else set_toolchains(&amp;#34;clang&amp;#34;) end 源码目录配置 考虑到 windows 没有getopt.h，这里在 github 上随便找了一个库代替，并开放头文件权限给依赖此库的target使用。 if is_os(&amp;#34;windows&amp;#34;) then target(&amp;#34;getopt&amp;#34;) set_kind(&amp;#34;static&amp;#34;) add_includedirs(&amp;#34;getopt-for-windows&amp;#34;, {public = true}) add_files(&amp;#34;getopt-for-windows/getopt.c&amp;#34;) end 作业1 作业有多个target，其实可以考虑每个给每个target单独一个配置，不过这里选择把多个target都放在同一个xmake.lua中。
根据原始 makefile 参数，处理一些跨平台配置。 考虑到作业会生成 ppm 格式的图片，所以改变该target的运行目录。 target(&amp;#34;mandelbrot&amp;#34;) set_kind(&amp;#34;binary&amp;#34;) add_files(&amp;#34;prog1_mandelbrot_threads/*.</description>
    </item>
    
    <item>
      <title>用 vscode 写 UE 代码</title>
      <link>https://star-hengxing.github.io/p/%E7%94%A8-vscode-%E5%86%99-ue-%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E7%94%A8-vscode-%E5%86%99-ue-%E4%BB%A3%E7%A0%81/</guid>
      <description>前提 目前来说 Rider 还是最好的 UE IDE，本文只是提供多一种选项来写 UE 代码。
环境 vscode 插件 clangd clang Windows 推荐使用 scoop 下载 clang。
scoop install llvm 部署 用 vscode 打开 UE 项目目录，新建.vscode目录。
新建.vscode/settings.json文件，写入下面内容。
{ &amp;#34;clangd.arguments&amp;#34;: [ &amp;#34;--background-index&amp;#34;, &amp;#34;--compile-commands-dir=.vscode&amp;#34;, // completion &amp;#34;--header-insertion=never&amp;#34;, &amp;#34;--completion-style=bundled&amp;#34;, &amp;#34;--function-arg-placeholders=false&amp;#34;, // effective &amp;#34;--pch-storage=memory&amp;#34;, &amp;#34;-j=16&amp;#34;, // coding &amp;#34;--clang-tidy&amp;#34;, // misc &amp;#34;--log=error&amp;#34; ] } 在项目目录新建.clang-format文件，谷歌一下 UE clang-format，随便找一个复制下来。这里用来格式化代码。
使用脚本生成反射信息和compile_commands.json
compile_commands.json成功生成后，打开 cpp 文件，clangd 就会自动运行。
UE 的 Unreal Build Tool 可以生成compile_commands.json，需要 clang 辅助。不过 UBT 写的比较奇葩，在命令行直接clang -v有结果，但 UBT 还是找不到，在论坛看了一遍 Linux/Windows 都是这样。</description>
    </item>
    
    <item>
      <title>浏览器插件</title>
      <link>https://star-hengxing.github.io/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</guid>
      <description>使用 edge，不需要科学上网就能在不同电脑同步插件
整洁 清理广告 -&amp;gt; AdGuard 移除 cookies 提醒 -&amp;gt; I don&amp;rsquo;t care about cookies 移除 url 跟踪参数 -&amp;gt; ClearURLs 效率 生成目录 -&amp;gt; Smart TOC 浏览网页 -&amp;gt; Vimium C 鼠标悬停链接显示图像/视频 -&amp;gt; Imagus 贴心工具 网页截图 -&amp;gt; Awesome Screenshot 听歌 -&amp;gt; Listen 1 自定义个人主页 -&amp;gt; Custom New Tab URL 破解网页限制复制 -&amp;gt; SuperCopy github 代码文件树 -&amp;gt; Octotree 集成 Aria2 for Edge KeePassXC-Browser v2ex plus Tampermonkey B站增强 -&amp;gt; Bilibili Evolved 移除 url 跟踪参数 -&amp;gt; Bilibili 干净链接 秒传 -&amp;gt; rapidupload-userscript 给片假名显示原词 -&amp;gt; 片假名终结者 知乎增强 贴吧页面精简 护眼模式 </description>
    </item>
    
    <item>
      <title>C&#43;&#43; 胡言乱语X1</title>
      <link>https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx1/</link>
      <pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/c-%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%ADx1/</guid>
      <description>某些 STL 容器 在刷 leetcode，其中某道题中的代码片段是这样的
string res; res.resize(size - i); // res.reserve(size - i); for (int j = 0; i &amp;lt; size; i += 1, j += 1) { res[j] = arr[i] + &amp;#39;0&amp;#39;; // res.push_back(arr[i] + &amp;#39;0&amp;#39;); } 没注释的代码比注释的快了几ms，原因如下
因为容器一开始是空的，不需要考虑拷贝原来的元素
resize 重新分配内存并且默认初始化，size 改变（大概开销 malloc + memset） reserve 重新分配了内存，不初始化，size 不变 push_back 需要检查 size 有没有大于 capacity，多了分支的开销 然而这里代码也不是最快的，思考一下，这里 resize 还多了一个 memset 的开销，所以最优解应该是，用自己写的 vector（逃
不知道是历史原因还是标准委员会根本没考虑到，应该加多几个函数来表示需不需要初始化
改造容器 这里先看一个别人家的 vector：Less
看一下某个代码片段
struct default_init_t {}; inline constexpr default_init_t default_init; struct with_capacity_t {}; inline constexpr with_capacity_t with_capacity; vector(default_init_t, size_type const size) { this-&amp;gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T; }); } vector(size_type size) { this-&amp;gt;construct(size, size, [](auto p, auto) { new (p, placement_tag) T(); }); } vector(with_capacity_t, size_type const capacity) { this-&amp;gt;construct(0u, capacity, [](auto, auto) {}); } vector(size_type size, T const&amp;amp; value) { this-&amp;gt;construct(size, size, [&amp;amp;](auto p, auto) { new (p, placement_tag) T(value); }); } 思考🤔，直接把一个结构体类型作为参数？算了直接去 c++ 群问一下</description>
    </item>
    
    <item>
      <title>渲染引擎的架构</title>
      <link>https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84/</guid>
      <description>学vulkan时的笔记（胡言乱语
前言 渲染需要呈现最终结果，所以和游戏引擎是“耦合”的
写一个简单的渲染引擎，其实和写一个游戏引擎也没什么区别，因为物理和动画的呈现依赖于渲染
这里所说的渲染应该不包含各种shader效果，更类似于怎么调图形api
所以写渲染引擎，本质还是写游戏引擎，那么最终还是要参考游戏引擎的架构
学vulkan也一样，最终都会写成渲染引擎，所以提前架构一下比较好。这样在使用vulkan tutorial学习时，不局限于单文件恶心自己
调api渲染的流程 加载数据到cpu/gpu，在gpu描述数据的布局，如何操作数据
虽然就短短一行字，但拆分下来每一部分都可以讲很多
资产管理 资产管理，可以简单自定义一个自己的资产文件格式，可以参考vulkan guide
我的想法是，定义一个最底层的存储格式，如 metadata + data，data 可以使用lz4算法进行压缩
metadata 可以是格式版本、data 的大小、是否加密&amp;hellip;&amp;hellip;
然后又可以自定义一个 texture 和 mesh 的格式，也是 metadata + data 模式，然后把这些打包塞给上面格式的 data 里
然后我们还需要一个转换器，负责把不同的模型格式（比如obj）转换成我们自定义的格式
思路理清的话，基本上都是一些工程脏活了，实现难度不大
待续 等我过一遍 unity 的 urp
参考 有关图形学入门的一些思考·谈谈Vulkan </description>
    </item>
    
    <item>
      <title>多态</title>
      <link>https://star-hengxing.github.io/p/%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%A4%9A%E6%80%81/</guid>
      <description>起因 在实现我的离线渲染器中，用到了大量oop（其实就是基类然后继承）
我有一个Shape基类，里面接口全声明为标准的纯虚函数接口
virtual TYPE FUNCTION() const = 0; 当你继承这个类后，继承类必须实现这个接口，不然编译报错
一开始还没有写实现，但类已经继承了，没办法，在接口开个洞（真难看啊
virtual TYPE FUNCTION() const {} 于是我基于 C++20 标准库的source_location写了一个
[[noreturn]] inline void unimplemented(const std::source_location location = std::source_location::current()) { std::cerr &amp;lt;&amp;lt; &amp;#39;\n&amp;#39; &amp;lt;&amp;lt; &amp;#39;[&amp;#39; &amp;lt;&amp;lt; location.file_name() &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; location.line() &amp;lt;&amp;lt; &amp;#34;] &amp;#34; &amp;lt;&amp;lt; location.function_name() &amp;lt;&amp;lt; &amp;#34; unimplemented!\n&amp;#34;; exit(-1); } 还没有实现接口的时候留下unimplemented，然后运行时报错
source_location暂时只有clang不支持（clang对C++20支持太慢了
网上冲浪时看到有人说，接口虚函数实现动态多态是一种糟糕实践，优雅的做法是Existential Type，在C++社区称为sean parent polymorphism
详细可以看这个视频
John Bandela “Polymorphism != Virtual: Easy, Flexible Runtime Polymorphism Without Inheritance”
reddit上的关于该视频的讨论
什么是多态 特定多态 Ad hoc polymorphism</description>
    </item>
    
    <item>
      <title>收藏夹（知识分类）</title>
      <link>https://star-hengxing.github.io/p/%E6%94%B6%E8%97%8F%E5%A4%B9%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB/</link>
      <pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E6%94%B6%E8%97%8F%E5%A4%B9%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB/</guid>
      <description>下面的目录不好使，只要小部分能跳转，点右边的目录跳转吧
我在知乎的点赞其实是当收藏用的， 这么多点赞，打算找时间用爬虫全部爬下来慢慢整理
数学 物理 信息 计算机理论 软件工程 理论 实践 编程语言 C C++ Rust Haskell 体系结构 编译原理 可视化 优化 高性能计算 计算机图形学 旋转 音视频 逆向 Linux 工具 在线工具 Git Unity 二次元 galgame 资源 在线 生肉 音声 色度学 日语 misc 数学 我在知乎学数学 图形数学方法：FFT（快速傅里叶）的原理讲述 有没有比较好的学习高等数学，线性代数，概率论数理统计的英文书籍推荐？ 物理 Ten Minute Physics 信息 压缩算法lzma2,zstd,rar,brotli,lz4,lizardv1对比推荐 计算机理论 计算复杂度理论基础（一）Preliminaries 软件工程 理论 语义化版本 2.0.0 读《Fundamentals of Software Architechture》 可逆计算：下一代软件构造理论 抽象的幻觉（1） 抽象的幻觉（2） 为什么这么设计系列文章 实践 游戏架构设计——面向数据编程（DOP） 游戏架构设计——高性能并行编程 为什么我认为Rust的Result错误处理方式不如Exception，探讨了Monad和工业界主流的异常处理两种错误处理的差异 游戏编程模式 阿里云块存储团队软件工程实践 Chromium 渲染流水线——字节码到像素的一生 A development process startup founders should use to ship features weirdly fast 编程语言 C 现代化 C 使用体验 The different ways to handle errors in C C Isn&amp;rsquo;t A Programming Language Anymore C++ 单例模式 简单的 C++ 结构体字段反射 make a shared_ptr from scratch C++ 系列专题 Changing std::sort at Google’s Scale and Beyond 最好的C++学习教程(上篇)——The Cherno CppSeries 最好的C++学习教程(下篇)——The Cherno CppSeries More C++ Idioms Learn Modern C++ 现代化工具链在大规模 C++ 项目中的技术实践 Understanding the different flavors of Clang C and C++ compilers in Windows，讲述了C++ 不同编译工具链的差异 从无栈协程到C++异步框架 Rust 文組也能懂的 Rust async 機制 Rust Language Cheat Sheet Haskell Learn Haskell by building a blog generator 体系结构 与程序员相关的CPU缓存知识 深入理解CPU cache：组织、一致性（同步）、编程 深入GPU硬件架构及运行机制 如何设计内存池？ - 韦易笑的回答 - 知乎，内存管理是最能体现体系结构知识的地方之一 Microarchitecture cheat sheet When an instruction depends on the previous instruction depends on the previous instructions… : long instruction dependency chains and performance 编译原理 【科普】编译器的构建基本原理 Programming Language Documentations 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 可视化 浮点数可视化 正则表达式可视化 马尔科夫链可视化 四元数可视化 数据结构可视化 优化 浮点数计算优化 vfixupimm: signum，用 AVX 优化取浮点数符号 When an instruction depends on the previous instruction depends on the previous instructions… : long instruction dependency chains and performance，CPU 指令依赖链太长拖慢速度，但依赖链解决不了，只能交叉两个依赖链提高效率 高性能计算 高性能计算学习路线 从零开始的C/C++高性能编程指南 C++ 高性能编程实战系列（1） C++ 高性能编程实战系列（2） C++ 高性能编程实战系列（3） CMU15418 并行计算机架构与编程 计算机图形学 使用有理数进行渲染 如何验证BXDF 实时&amp;amp;离线皮肤渲染技术（Real-time &amp;amp; Offline Skin Rendering） Enterprise PBR Shading Model 多种几何体求交 How to build a BVH 旋转 可视化和公式推导 音视频 FFmpeg原理 FFmpeg5开发入门系列索引 逆向 这里我推荐 CSAPP Lab2-Bomb Lab</description>
    </item>
    
    <item>
      <title>随便记录下看过的书吧</title>
      <link>https://star-hengxing.github.io/p/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95%E4%B8%8B%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B9%A6%E5%90%A7/</link>
      <pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95%E4%B8%8B%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B9%A6%E5%90%A7/</guid>
      <description>技术书看新不看旧
计算机科学 人月神话 黑客与画家 敏捷软件开发 代码整洁之道 程序员的自我修养 : 链接、装载与库 七周七语言 代码本色 x86汇编语言 : 从实模式到保护模式 深入理解计算机系统 Head First设计模式 编程语言 C C Primer Plus C++ C++ Primer C++ Primer PLus Effective C++ More Effective C++ Effective Modern C++ C++ Best Practices: 45ish Simple Rules with Specific Action Items for Better C++ C++性能优化指南 C++并发编程实战 Rust 深入浅出Rust Rust程序设计语言 Python Python编程 从入门到实践 Haskell Haskell趣学指南 Haskell函数式编程入门 数据结构与算法 大话数据结构 算法导论 计算机体系结构 计算机组成与设计：硬件/软件接口 计算机系统要素 : 从零开始构建现代计算机 编码 : 隐匿在计算机软硬件背后的语言 操作系统 一个64位操作系统的设计与实现 Linux内核设计与实现 现代操作系统 现代操作系统：原理与实现 计算机网络 计算机网络自顶向下方法 TCP/IP详解 卷1：协议 图解HTTP 计算机图形学 Fundamentals of Computer Graphics Ray Tracing Gems series 全局光照技术 实时渲染 Real-Time Rendering 离线渲染 The Ray Tracer Challenge Ray Tracing in One Weekend series Advanced Global Illumination Physically Based Rendering: From Theory to Implementation 数学 线性代数的几何 线性代数及其应用 漫画线性代数 数值分析 从博弈问题到方法论学科 物理 现代光学基础 光学原理 游戏 游戏编程模式 游戏引擎架构 游戏设计艺术 日语 新版中日交流标准日本语初级 音乐 超简单的乐理学习图解版 认识乐理：视唱练耳同步学 杂书 视觉艺术用光 色彩与光线 写实主义绘画指南 我的二本学生 信息简史 信息论基础 信号与系统 </description>
    </item>
    
    <item>
      <title>使用KeePass作为密码管理器</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8keepass%E4%BD%9C%E4%B8%BA%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8keepass%E4%BD%9C%E4%B8%BA%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>最近超星学习通数据泄露大家应该都知道吧，全国上下学生很多都依赖这么一个中心化的网课平台。而且学习通可能还是明文存储密码，这下坏事了，直接撞库
撞库攻击是网络犯罪分子试图使用一组帐密同时访问多个帐户
我很久以前就知道有密码管理器的存在，但我是懒鬼，所以没弄过。这次事件提醒了我，还是别偷懒了（
Getting started KeePass是什么呢
KeePass is an encrypted password database format. It is an alternative to online password managers and is supported on all major platforms.
我这里推荐使用跨平台的KeePassXC客户端，原始KeePass客户端实在太丑陋了
下载客户端后，新建数据库需要一个主密码，这个密码需要你记忆
我们先来看一个图，来自xkcd 那如何根据上图思路创建一个好密码呢，这里可以看一下diceware的方法
这个网站根据diceware方法提供在线生成随机英语单词
如果想要生成随机中文词语，可以在此网页找到 使用diceware构造好的密码
创建好数据库后，保存在本地随便一个目录，然后我们去KeePassXC设置面板开启浏览器集成，下载对应浏览器插件
浏览器插件启动后需要连接KeePassXC客户端
在网站登录页面，如果数据库里没有对应网站url或者已存在，会提示你为该网站新建/更新账号密码。如果没有提示，可以手动使用插件，或者直接在KeePassXC客户端手动录入
KeePassXC里随手就可以生成一个密码，无论是大小写字母数字还是各种特殊符号。如果想使用密码，Ctrl-C会自动复制到你剪切板上，然后在10秒后清除
如果手机也要密码管理，安卓客户端可以在f-droid上下载keepassdx
同步 所有信息都在keepass创建的数据库里，这里可以使用一些文件传输软件进行备份同步，或者存github也没啥问题</description>
    </item>
    
    <item>
      <title>在 Windows 上使用 Xmake 配置 Vulkan 开发环境</title>
      <link>https://star-hengxing.github.io/p/%E5%9C%A8-windows-%E4%B8%8A%E4%BD%BF%E7%94%A8-xmake-%E9%85%8D%E7%BD%AE-vulkan-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%9C%A8-windows-%E4%B8%8A%E4%BD%BF%E7%94%A8-xmake-%E9%85%8D%E7%BD%AE-vulkan-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>也可以是C++小项目的配置
开发环境构建 vscode+xmake+clang+clangd
如果在配置过程中有问题，可以先看一下文末的FQA
C++编译工具链 Visual Studio 2022 clang 构建系统 xmake
Vulkan SDK https://www.lunarg.com/vulkan-sdk/
假装IDE的文本编辑器 Visual Studio Code
安装插件
clangd XMake Getting started 上面列出来的工具下载完成后，新建一个目录，在目录下新建xmake.lua，写入下面内容
set_project(&amp;#34;vulkan&amp;#34;) set_arch(&amp;#34;x64&amp;#34;) set_warnings(&amp;#34;all&amp;#34;) set_languages(&amp;#34;c++20&amp;#34;) set_toolchains(&amp;#34;clang&amp;#34;) add_rules(&amp;#34;mode.debug&amp;#34;, &amp;#34;mode.releasedbg&amp;#34;, &amp;#34;mode.release&amp;#34;, &amp;#34;mode.minsizerel&amp;#34;) add_requires(&amp;#34;vulkansdk&amp;#34;, &amp;#34;glfw&amp;#34;, &amp;#34;glm&amp;#34;) target(&amp;#34;main&amp;#34;) set_default(true) set_kind(&amp;#34;binary&amp;#34;) add_files(&amp;#34;src/main.cpp&amp;#34;) add_packages(&amp;#34;vulkansdk&amp;#34;, &amp;#34;glfw&amp;#34;, &amp;#34;glm&amp;#34;) 依赖的 vulkansdk 在上面已经下载，如果用他的 installer 安装会自动设置环境变量，xmake 会根据环境变量自动探测编译器、vulkansdk 的正确位置，glm 和 glfw 由 xmake 的包管理处理
编译 测试代码来自vulkan tutorial
直接新建一个main.cpp，把代码复制下来
一切配置好后，可以测试一下了
xmake xmake run 出现窗口代表环境配置成功
Intellisense xmake会在.vscode目录自动生成compile_commands.json
所以我们在.vscode/settings.json给clangd加上参数
{ &amp;#34;clangd.arguments&amp;#34;: [ &amp;#34;--compile-commands-dir=.</description>
    </item>
    
    <item>
      <title>渲染进阶</title>
      <link>https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E6%B8%B2%E6%9F%93%E8%BF%9B%E9%98%B6/</guid>
      <description>图形笑话三则 来点图程破防乐子 无内鬼，来点图形笑话 再来点图程破防乐子 免费渲染模型 McGuire Computer Graphics Archive Rendering Resources 博客 A GRAPHICS GUY&amp;rsquo;S NOTE Computer Graphics IQ YangWC&amp;rsquo;s Blog AirGuanZ 《高级计算机图形学——真实感图像合成》目录及序言 OEOTYAN 课程 CS 87/287 | RENDERING ALGORITHMS UCSD CSE 272: Advanced Image Synthesis Advanced Graphics CSE 168 Computer Graphics II: Rendering CIS 565 GPU Programming and Architecture Fall 2022 各种效果 光谱 Simple Spectral Spectral Ray Tracing 天空 The Sky Dome Appearance Project 彩虹 Physically-based simulation of rainbows 动物毛发 An Efficient and Practical Near and Far Field Fur Reflectance Model 肥皂泡 Chemomechanical Simulation of Soap Film Flow on Spherical Bubbles FQA （其实就是把群友讨论结果收藏一下</description>
    </item>
    
    <item>
      <title>从代码到程序</title>
      <link>https://star-hengxing.github.io/p/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A8%8B%E5%BA%8F/</guid>
      <description>随手记录的一些编译原理笔记。
现代编译器分为前后端，为了进一步降低复杂度(模块化)，前端的流程通常是：
词法分析 -&amp;gt; 语法分析 -&amp;gt; 语义分析 上一步的输出是下一步的输入。
词法分析 常见的应用有正则表达式。
先定义一个映射， tokens = map(字符串)
这个token是啥呢，比如说我有下面这个算式：
1 + 2 * ３ 解析后：
值 类型 １ 整数 + 加号 2 整数 * 乘号 3 整数 我们暂时不知道有什么用，但现在我们解决了字符串里的空格，如果字符串里有奇怪的字符，比如#啥的，也可以报错。
怎么解析其实也是个大问题，通常用自动机解决这个问题。
语法分析 把词法分析输出的一堆token，组合成句子，检查句子的语法，最后生成抽象语法树(AST)
AST用处广泛，比如：
编辑器错误提示 代码格式化 代码高亮 代码自动补全 </description>
    </item>
    
    <item>
      <title>如何在Linux和Windows上优雅地玩galgame</title>
      <link>https://star-hengxing.github.io/p/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E5%92%8Cwindows%E4%B8%8A%E4%BC%98%E9%9B%85%E5%9C%B0%E7%8E%A9galgame/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E5%92%8Cwindows%E4%B8%8A%E4%BC%98%E9%9B%85%E5%9C%B0%E7%8E%A9galgame/</guid>
      <description>Windows10 提高游戏分辨率 -&amp;gt; Magpie
统计游戏时长兼启动器 -&amp;gt; Etupirka
用手柄玩galgame -&amp;gt; Steam Controller
现在你获得了一个很好的体验，启动Etupirka，然后选中想玩的galgame，绑定Magpie的快捷键到手柄上，对游戏全屏，我一个Quick load，可以继续用手柄摇杆推线咯
Linux 一个坏消息，大部分黄油开发者根本没想过Linux平台
一个好消息，steam的Proton可以帮助我们玩到Windows上的galgame(感谢V社)
首先在Linux上下载steam，然后添加非steam游戏，游戏设置使用Proton，然后你就可以启动游戏啦
但实际上只有少部分黄油能打开，就算能打开还一定会伴随bug
能打开的游戏没见过能播放op 传言有些游戏要对应Proton版本才能打开 游戏能打开，但bug太致命完全打不了 我超，汉化补丁能打开生肉却打不开，但我想全都要怎么办 游戏打不开怎么办，乱试一下吧
游戏路径全ascii且不留空格(游戏目录也算路径) 参考这篇文章 能用Proton直接打开基本无bug游玩是最好的，如果要折腾很久才能玩我觉得真的没必要，不如用回Windows或者虚拟机(两台以上电脑是Linux用户的最优解)
先列个能打开的黄油名单在这吧，排排坑
名字 Pronton版本 体验 放課後シンデレラ 7.0 非常好，没遇到坑 はつゆきさくら 7.0 播放序章op闪退了一次，再打开会提示你要不要播放op，能流畅游玩 いきなりサキュバス ～いちゃらぶ搾精ライフ～ 7.0 没完整打完，暂时无bug 白昼夢の青写真 7.0 黑屏bug，如果不是一直渲染的画面就会黑屏，比如显示文字的时候，文字外的全黑 有群友推荐lutris和proton-ge，还未研究</description>
    </item>
    
    <item>
      <title>Chinagraph2020会前课程 真实感图形渲染科研入门 随手记录</title>
      <link>https://star-hengxing.github.io/p/chinagraph2020%E4%BC%9A%E5%89%8D%E8%AF%BE%E7%A8%8B-%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%A7%91%E7%A0%94%E5%85%A5%E9%97%A8-%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/chinagraph2020%E4%BC%9A%E5%89%8D%E8%AF%BE%E7%A8%8B-%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%A7%91%E7%A0%94%E5%85%A5%E9%97%A8-%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95/</guid>
      <description>录播：Chinagraph2020
论文推荐 真实感图形渲染科研入门笔记（一）：论文推荐
工具链与参考资料 真实感图形渲染科研入门笔记（二）：工具链与参考资料
迈向科研的训练 离线 用Intel的Embree写一个光线追踪器 使用多重重要性采样 支持微表面材质 实现一个正确的BDPT 95%做渲染的科研人员都没写对BDPT(太难了)
检验：和PT的结果比较
实时 用C++封装OpenGL 支持arcball(能用鼠标拖拽的一个球，里面的物体一起动起来)，写一个VSSM 使用Optix和OpenGL实现RTRT 使用SVGF降噪 未来 材质外观的研究才刚刚开始
现在用的基本这两种
diffuse + microfacet 迪士尼原则BRDF 尽管实现很简单，但第一种对真实感渲染错的离谱
人脸的渲染也没有好的正向模型</description>
    </item>
    
    <item>
      <title>AUR打包记录</title>
      <link>https://star-hengxing.github.io/p/aur%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 02 Mar 2022 10:03:35 +0800</pubDate>
      
      <guid>https://star-hengxing.github.io/p/aur%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95/</guid>
      <description>当发现了一个好软件，但aur上没有人打包，这很难受，所以不如自己来为社区做贡献
这次我打的包是一个appimage，理所当然去参考一些现有的appimage打包PKGBUILD
所以先设计再编码
PKGBULID编写 下载最新版本的软件到本地 提取appimage，把软件icon放到/usr/share/icons 制作Desktop Entry，放到/usr/share/applications 最后将软件去掉版本号，安装到常见目录（我选择了放在/opt/appimages） 是不是看起来很简单，但由于不熟悉linux和一些常用工具，一顿操作下来，花了半天才写好PKGBUILD。
首先是学会用sed，因为appimage里自带了一个Desktop Entry，所以要进行修改。
其次就是安装到目录的时候需要给权限目录权限，不然复制不进去。
当上游的包没有checksum的时候，还要自己download到本地生成然后加上PKGBULID。当然makepkg然后给了个便利的命令。
# 如果有上一个版本的checksum,先用sed删除再执行该命令 sed -i &amp;#34;$d&amp;#34; PKGBULID makepkg -g &amp;gt;&amp;gt; PKGBULID 测试 写好PKGBULID，检查能不能用。
# 检查PKGBUILD格式 namcap PKGBUILD # 生成包 makepkg -s # 检查包是否缺少依赖等等 namcap xxx.pkg.tar.zst 检查包的时候我弹了许多报错，不知道怎么修。然后我去用namcap检查一下我参考的那个appimage包，好家伙，他的报错跟我一样。既然他没修那我也就算了吧。
然后尝试安装
# 生成.SRCINFO给aur仓库的页面展示，如果第一次提交没有生成，aur仓库会拒绝你的包 makepkg -i &amp;amp;&amp;amp; makepkg --printsrcinfo &amp;gt; .SRCINFO 上传 如果一切没问题，那就可以用git上传aur了（需要一个aur帐号）。
如果会基本的git操作，下面应该都明白怎么操作。
# 为aur创建ssh key touch ~/.ssh/config # 写入这些 Host aur.archlinux.org IdentityFile ~/.ssh/aur User aur # 生成 ssh-keygen -f ~/.ssh/aur # 首先创建一个aur项目 git clone ssh://aur@aur.</description>
    </item>
    
    <item>
      <title>色彩搭配的基础知识</title>
      <link>https://star-hengxing.github.io/p/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 07 Feb 2022 15:25:20 +0800</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>至今看过最棒的关于基础色彩理论的视频
常识 红色和黄色可以变成橙色;黄色和蓝色变成绿色;而蓝色和红色变成紫色。如果我们将这些颜色混合在一起，我们得到更多的色调，如红橙色和黄绿色。总之，它们形成了所谓的色轮。 色调是最简单的，它基本上就是我们所说的“颜色”。 饱和度是指强度，换句话说，颜色是否重叠更微妙，或者更具活力。 色值与深浅的颜色相关，从黑到白。 专业配色方案 最简单的方法是单色因为它仅使用一个颜色或色调，选择在色轮上挑选一个点，并使用饱和度和色值的知识，能够保证匹配。 相似色搭配是使用色轮中彼此相邻的色彩样式，如红色和橙色、蓝色和绿色······ 互补色彼此相对，例如，蓝色和橙色&amp;hellip;或经典的红色和绿色。为了避免互补配色方案过于简单化可以增加更轻，更深，或者一些不同饱和度的颜色。 分裂互补配色方案使用的相对颜色的双重配色，能够提升对比之外，更有趣的结果。 三元配色方案采用三种均匀分布的颜色，在色轮上形成一个完美的三角形。这些组合的效果醒目，特别是与主色或辅色的运用。 四元色搭配在色轮上形成了一个矩形，可以通过将其中的一个颜色用于主色，其余为辅色。 解决方法 色彩扎眼——选择一种颜色，并尝试调整其亮度，暗度或饱和度。 色彩过多——也许一点点色彩就可以满足你的画面需要。 色不平衡——中性颜色，如黑色，白色和灰色可以帮助您平衡画面。 实际经验 每种颜色都会发出一个信息。考虑到项目的色调，并选择一个合理的配色方案。 明亮的颜色往往能够带来有趣或现代感的效果。 低饱和度的色彩搭配经常会受到商业公司的喜爱。 你可以在各种有趣的地方找到配色方案，比如某些广告、艺术品、配色网站、周围世界，颜色无处不在。 </description>
    </item>
    
    <item>
      <title>御宅族与ChaosChild症候群</title>
      <link>https://star-hengxing.github.io/p/%E5%BE%A1%E5%AE%85%E6%97%8F%E4%B8%8Echaoschild%E7%97%87%E5%80%99%E7%BE%A4/</link>
      <pubDate>Mon, 07 Feb 2022 13:08:04 +0800</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%BE%A1%E5%AE%85%E6%97%8F%E4%B8%8Echaoschild%E7%97%87%E5%80%99%E7%BE%A4/</guid>
      <description>重新排版了一下
出处： 御宅族与ChaosChild症候群 - 历久弥新的文章 - 知乎 https://zhuanlan.zhihu.com/p/44592537
御宅族已死。
&amp;ndash;冈田斗司夫 真正的御宅族如今是否已经消亡了？我没有相关的数据情报，所以无法作出回答。然而，在我的臆测中，真正的御宅族还存在着，但不过只是很少的一部分，并且这部分人中并没有关联。 所以，在新世代宅的急速涌入下不断被稀释着。
我也自认为真正的御宅族，然而在我全通了CHAOS;CHILD后，发觉我也不过是“ChaosChild症候群”的一员罢了。
逃避性 无论是真正御宅族们，还是新世代的御宅族们，虽然是不同的个体，但是却进行着妄想同步。得益于网络的普及，御宅们把本我至于同一个巨大的名为御宅文化的妄想之中（网络未普及之前已经开始，不过那时候只是小型的妄想体，朋友、学校的讨论，电视活动之类）。 美好的妄想，它与严酷的现实有着天壤之别，为了生存不得不经历人世，但是，本我还有御宅文化这个桃花源，经过学习、工作的洗礼后，坐到电脑或是沙发前，打开动画亦或是游戏，全身心的投入。
大部分的人玩游戏的时候有个特点，对于外界置若罔闻，仿佛所有感官都集中在了游戏上，而这在做其他事情的时候是很少出现的，而且并不是可以人为控制的现象。 全身心的投入妄想之中，大脑分泌刺激性神经递质，所有其他事情烦恼都被抛在脑后，此时，仿佛就是游戏中的人物。 放松，就像是在逃避，而这并没有错，我们无时无刻不想着逃避，而超我却告诉我们不行，现在并不是共产主义社会。最后，我们只得在苦劳与逃避之间无限循环。
有的人为自己创造虚伪的现实妄想，沉溺其中，彻底的利己主义，而这你又得到了什么呢？也许你可能得到你想要的，而这个世界却更加崩坏。当然，利己主义者不会考虑这些，只会考虑自己能否享乐。
优越性 宅文化的一些特性加上事件误导，使得它天生作为一种非主流道德亚文化，被一般人所不适，因为历史原因在我国更是如此。
所以宅这个ChaosChild症候群群体，天生是活在一个被一般人所蔑视的妄想中，因主流文化使得宅文化变成了自卑性的妄想，而对此宅们当然要作出应激反应。 以前，所谓的真正御宅族，用各式各样，各个门类的创作证明着自身的能力性，并与社会相关联，这样，不仅在宅圈收获了虚荣并且证明给社会人自己比他们还要强。 如果是什么都不会且自控力低下不去学的人，通常情况类似宫代拓留，自诩为情报强者，在宅圈混迹获得大量情报，自以为看透了世界的真实，看不起周围的普通人，甚至包括父母，认为他们的情报量太少，包括我也是此类。
你们这些人天天就是看这些无脑电视剧，追星，看着无聊的花边新闻，全是萌二的B站，一遍遍刷着全是垃圾信息的微博，呵，这个人还在煞有其事地看知乎啊，知乎早就和微博没区别了，哈哈，你们这些情报弱者。
而我不同，我刚通了CHAOS；CHILD，你们这些人一辈子也接触不到这个神作吧，呵呵，通过这个游戏，我知道了……而你们就这样浑浑噩噩地活着吧，我早已看穿一切。
而新世代宅更加常用的是自嘲的手法，死宅真恶心、肥宅快乐……在疯狂地传播下无形间降低这些词的伤害力，并成为一种调侃娱乐。 真是可笑的手法呢，本身含着自卑的群体夺取外部人的武器抢先自行使用，而造成外部人无枪可打，同时加深内部的归属感使原本那些刺耳的话也只成为了笑料……
我与宫代拓留有着许多相似之处，不健全的家庭环境，把自己放入妄想中，吸收大量情报，在学校，身为班级下层的我却看不起班级上层的学生，找的理由和宫代差不多，进入工作后依然是如此状态，在公司，交际能力极差导致也没有人愿意主动交谈，每天中午在食堂都是一个人吃午餐，而我，却觉得这样很轻松。
看着周围有说有笑的人们，情报强者这个武器还真是好用呢，每天使用它来填补自己的自尊心，回到家再次沉溺在妄想之中。
矛盾性 几个人的御宅妄想无法抵抗这个社会的压力与反对，而一大群人妄想就可以做到。作为这个妄想的每个终端，每个人把自己置于其中就可以感受到整体的包容，从而抵抗外部的侵犯。 回到家，打开电脑，进入一些网站或者社交软件，看着御宅相关的东西，购买周边，放置手办，感觉安心了，此刻，我作为子体感受到了母体的包容性。即使外面的人反对御宅文化本身，因为这个妄想内部人的数量足够庞大，个体也不会慌乱，因为我们人数众多。 矛盾的是，作为处于同一个妄想下的我们，也如One World Order实验一样，自个划分起阶级。我们共同构建起名为御宅文化的妄想，然后并不是同伴，我们只是都在汲取它而已。 具体表现之一，讽刺B站，看不惯B站小学生，认为B站已经变质，却还总是上B站。其原因在于只有B站能提供足够的妄想力。 其实所谓的真正御宅也在享受着新世代宅的恩惠，新世代宅的急流涌入增大着妄想圈，不过这样也伴随着大量的副作用。这些副作用改变了御宅妄想的形态，与真正御宅一直一来所容纳自己的妄想形态产生了变异，真正御宅因妄想的变异而发生不适，所以必须要嘲讽新世代来缓解。 并且，嘲讽新世代宅还能使用优越感这个武器填补自己的自尊心。 御宅妄想的变异越严重，对于真正御宅的压力就愈发高涨，这种压力会转变为各种行为，但这些行为基本脱离不了对于新世代御宅的嘲讽与虚荣，并且企图能有另外一些真正御宅，不，不管什么人，只要能回复支持自己就行了，这样妄想不同步产生的压力就能减轻。
而御宅文化妄想的变异是不可逆的，如今只有两种选择：
适应不断变化的妄想，仍然沉溺其中。 脱离妄想。 而这点不只是本人的抉择，而是和每个人的经历相关，有时候轮不到你自由选择，生活会主动帮你进行选择。
一般来说，第二种选择脱离妄想符合绝大部分人的现实情况，也符合社会主流文化的诉求，被社会所绑架的所有人也会觉得这是合理的，应该的，是一种必经阶段。
而我可能不会这样，如同沉迷游戏的孩子不是教训孩子而是需要从家庭与父母入手解决一样，我明白我作出这样的选择是因为我家庭的不健全所导致的，并没有、也无法像正常家庭的孩子一般，按流程走人生，所以我可能会一直停留在妄想之中。
哪个选项比较好？从社会来说，必然是第二种：
第一种选项意味着逃避、自卑、矛盾。而第二种意味着面对、自信、成长。
这是对于社会人来说，显而易见的答案。
我难道不明白吗？怎么可能？但是我为什么不选第二种，是因为懦弱？逃避？也许是这样吧。
但是我啊，总是有一种感觉，选了第二种答案就会失去一些什么……
你们会如何选择呢？</description>
    </item>
    
    <item>
      <title>ARK Survival Evolved 开启活动的命令行参数</title>
      <link>https://star-hengxing.github.io/p/ark-survival-evolved-%E5%BC%80%E5%90%AF%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 04 Feb 2022 13:33:27 +0800</pubDate>
      
      <guid>https://star-hengxing.github.io/p/ark-survival-evolved-%E5%BC%80%E5%90%AF%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</guid>
      <description>Enable ARK: Survival Evolved Events -activeevent=EventName List of ARK Events Active event Command Love Evolved -activeevent=vday Eggcelect Adventure -activeevent=Easter Anniversary -activeevent=birthday Summer Bash -activeevent=Summer Fear Evolved -activeevent=FearEvolved Turkey Trial -activeevent=TurkeyTrial Winter Wonderland -activeevent=WinterWonderland </description>
    </item>
    
    <item>
      <title>当你第一次和日本人交流</title>
      <link>https://star-hengxing.github.io/p/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%92%8C%E6%97%A5%E6%9C%AC%E4%BA%BA%E4%BA%A4%E6%B5%81/</link>
      <pubDate>Sun, 30 Jan 2022 14:26:50 +0800</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%BD%93%E4%BD%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%92%8C%E6%97%A5%E6%9C%AC%E4%BA%BA%E4%BA%A4%E6%B5%81/</guid>
      <description>务必以下三连
大変申し訳ございません 突然フォローで失礼ですが この度は,大変ご迷惑をおかけして誠に申し訳ございませんでした。ご無礼のありました段、重ねて謹んでお詫び申し上げます。今後このようなことのありませんよう誠心誠意努力して参りますので、これからもご贔屓賜りますよう重ねて宜しくお願い申し上げます </description>
    </item>
    
    <item>
      <title>随手记的乐理知识</title>
      <link>https://star-hengxing.github.io/p/%E9%9A%8F%E6%89%8B%E8%AE%B0%E7%9A%84%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 30 Jan 2022 11:25:23 +0800</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E9%9A%8F%E6%89%8B%E8%AE%B0%E7%9A%84%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86/</guid>
      <description>音程（Interval） 两个音高不同的音在一起会形成音程。一个音到下一个相邻的音的距离叫二度（second）。如果距离是半音，音程叫小二度（m2）；全音就叫大二度（M2）
单位度作为音程的冲量单位
旋律（Melodic） -&amp;gt; 两个音一前一后发声
和声（Harmonic） -&amp;gt; 多个音同时发声
和弦（chord） 同时发声的音 &amp;gt;= 3 就叫和弦
Reference 精通乐理不是梦：超简单的乐理学习图解版 认识乐理：视唱练耳同步学 </description>
    </item>
    
    <item>
      <title>AppImage的使用</title>
      <link>https://star-hengxing.github.io/p/appimage%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/appimage%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Run cd /path/to/AppImage chmod +x xxx.AppImage ./xxx.AppImage Extra icon ./xxx.AppImage --appimage-extract Desktop Entry For example:
[Desktop Entry] Version=1.0 Type=Application Name=xxx Comment=A cross platform comic client. Exec=/home/&amp;lt;user&amp;gt;/Desktop/AppImages/xxx.AppImage Icon=/home/&amp;lt;user&amp;gt;/Desktop/AppImages/icons/xxx.png Terminal=false tags=Game X-AppImage-Version=1.0.0 # Copy the content to xxx.desktop mkdir -p ~/.local/share/applications touch ~/.local/share/applications/xxx.desktop </description>
    </item>
    
    <item>
      <title>Linux配置</title>
      <link>https://star-hengxing.github.io/p/linux%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/linux%E9%85%8D%E7%BD%AE/</guid>
      <description>基本软件 工具 名字 display manager lightdm desktop environment xfce4 文本编辑器 vscode/vim/emacs 程序启动器 rofi 输入法 fcitx5 browser microsoft-edge-dev(AUR) 多线程下载 aria2 压缩包解压/查看 ark proxy clash for window(AUR) RSS fluent-reader shell zsh PDF zathura 命令行软件 描述 名字 显示目录大小 ncdu 高级版top gotop(AUR)/htop 打印彩色的十六进制 hexyl 语法高亮和行号的cat+less bat 统计目录代码量 loc 文件浏览器 ranger 比tmux更好用的单窗口多终端 zellij 新建用户 useradd -m -G wheel username passwd username ln -s /usr/bin/vim /usr/bin/vi visudo 找到# %wheel ALL=(ALL)ALL取消注释
硬件 网卡 万物起源先上网，但有些网卡需要手动装驱动(比如我笔记本的博通网卡)
sudo pacman -S linux-headers broadcom-wl-dkms reboot dkms status 声卡 sudo pacman -S alsa-utils pulseaudio-alsa 蓝牙 sudo pacman -S bluez bluez-utils /etc/bluetooth/main.</description>
    </item>
    
    <item>
      <title>基于SDF的Raymarching</title>
      <link>https://star-hengxing.github.io/p/%E5%9F%BA%E4%BA%8Esdf%E7%9A%84raymarching/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%9F%BA%E4%BA%8Esdf%E7%9A%84raymarching/</guid>
      <description>其实大部分情况下和raytracing类似
不同:
几何物体的描述 光线与几何物体求交 法线的获取 Reference iq大佬的网站 </description>
    </item>
    
    <item>
      <title>逆向工程</title>
      <link>https://star-hengxing.github.io/p/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid>
      <description>自学怎么说呢，我也在摸索，不过我认为先做一下CSAPP的bomb lab比较好
bomb lab 逆向汇编破解程序
这个作业怎么下载还有工具自己找吧，都很容易获取
可能要用到的东西
gdb x86指令文档 我研究的时候是边做边学，打断点，单步看汇编，不懂的指令/寄存器现场查
tools 强大的工具 ghidra ida gdb 十六进制编辑器 bless 十六进制查看 hexyl(跨平台/终端彩色输出) 解包 arc_unpacker crass Reference 逆向工程入门简述 汇编语言简述(逆向工程) </description>
    </item>
    
    <item>
      <title>使用Synapse自建聊天服务器</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8synapse%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8synapse%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>我的系统是ArchLinux，所以看着archwiki一路配置比较舒服
其他系统请看官方文档
从安装到启动 my.domain.name替换成自己的域名就行
sudo cd /var/lib/synapse sudo -u synapse python -m synapse.app.homeserver \ --server-name my.domain.name \ --config-path /etc/synapse/homeserver.yaml \ --generate-config \ --report-stats=yes sudo systemctl start synapse.service # 服务器至少要有一个用户 register_new_matrix_user -c /etc/synapse/homeserver.yaml http://127.0.0.1:8008 这时候应该就可以用一个matrix client来连接了，这里选择element</description>
    </item>
    
    <item>
      <title>使用命令行工具下载在线视频</title>
      <link>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91/</guid>
      <description>yt-dlp 一个命令行下载youtube视频软件，目前来说就他下载速度还行，其他同类工具被限速了
TL;DR
下载一个视频
yt-dlp URL 不下载，查看视频下载的信息(选择画质)
yt-dlp -F URL [BiliBili] 12Q4y1S73g: Downloading webpage [BiliBili] 12Q4y1S73g: Downloading video info page [info] Available formats for 12Q4y1S73g: format code extension resolution note 0 flv unknown 1 flv unknown 2 flv unknown 295.77MiB (best) 下载bilibili视频 Bilibili Evolved + aria2 下载视频
Bilibili Evolved提供了几种视频下载方式，我这里选择aria2
启动aria2后，在插件里选择aria2 rpc就可以自动下载视频了</description>
    </item>
    
    <item>
      <title>小知识</title>
      <link>https://star-hengxing.github.io/p/%E5%B0%8F%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%B0%8F%E7%9F%A5%E8%AF%86/</guid>
      <description>编年史和纪传体 编年史:
15年你，你表哥，你表妹做了哪些事情
16年你，你表哥，你表妹做了哪些事情
。。。。。
N年你，你表哥，你表妹做了哪些事情
记传使：
15-N年，你做了什么事情
15-N年，你表哥做了什么事情
15-N年，你表妹做了什么事情
小结，比喻不准确。
断网时谷歌浏览器小游戏 谷歌浏览器输入chrome://dino/
Enter后按空格
就有个小游戏玩了
甚至还有人用js写了个外挂
乱数假文 Lorem ipsum，中文又称“乱数假文”，是指一篇常用于排版设计领域的拉丁文文章，主要的目的为测试文章或文字在不同字型、版型下看起来的效果，通常网站还没建设好时会出现这段字 -来自百度 科普
【木鱼说129】如果你网龄够长，一定看过这张图——从「乱数假文」到「互联网第一夫人」知识科学科普
sex English words Cunnilingus paedophilia pspanking </description>
    </item>
    
    <item>
      <title>圆内接正多边形的面积</title>
      <link>https://star-hengxing.github.io/p/%E5%9C%86%E5%86%85%E6%8E%A5%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%9C%86%E5%86%85%E6%8E%A5%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</guid>
      <description>圆内接正多边形的面积 假设半径为R，正多边形顶点数为n
正多边形外接圆，圆和正多边形中心点为同一位置
将中心点对每个角连线，生成n个等腰三角形，腰长等于半径
求出单个三角形面积，再乘以三角形数量
$$ S = \frac{nR^{2}sin(\frac{2\pi}{n})}{2} $$</description>
    </item>
    
    <item>
      <title>一个函数打印STL容器</title>
      <link>https://star-hengxing.github.io/p/%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0stl%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0stl%E5%AE%B9%E5%99%A8/</guid>
      <description>满足range这个concept就可以使用该函数
#include &amp;lt;iostream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;ranges&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;array&amp;gt; template &amp;lt;std::ranges::range T&amp;gt; void println(const T&amp;amp; args) { for(const auto&amp;amp; v : args) { std::cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } template &amp;lt;std::ranges::range... Ts&amp;gt; void print(Ts... args) { (println(args), ...); } int main() { std::array&amp;lt;int, 10&amp;gt; arr; std::iota(arr.begin(), arr.end(), 0); std::vector&amp;lt;int&amp;gt; vec(10); std::iota(vec.begin(), vec.end(), -10); print(arr, vec); } 输出
0 1 2 3 4 5 6 7 8 9-10 -9 -8 -7 -6 -5 -4 -3 -2 -1</description>
    </item>
    
    <item>
      <title>裸机运行Hello world</title>
      <link>https://star-hengxing.github.io/p/%E8%A3%B8%E6%9C%BA%E8%BF%90%E8%A1%8Chello-world/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E8%A3%B8%E6%9C%BA%E8%BF%90%E8%A1%8Chello-world/</guid>
      <description>前置知识 编译链接到可执行程序一系列流程 x86架构的一些寄存器 elf头 下面工具的使用 环境配置 os: Linux
可能会用到的工具:
gcc(编译) ld(链接) objcopy(提取二进制) dd(写入虚拟镜像) gdb(调试) make(自动化构建) qemu(虚拟机) 大部分linux发行版都会自带大部分工具，自行安装最新版本即可
基本介绍 目标是实现一个不依赖操作系统就能运行的二进制程序，在虚拟机屏幕显示hello world
计算机启动，按下电源开关通电启动bios，检查硬件，没啥问题的话，bios会加载该储存设备第一个扇区的512字节(MBR)到物理内存0x7C00
如果扇区最后两个字节是0x55和0xAA，那么说明是启动设备，否则bios会跳过该扇区
如果装过系统的话，会发现这就是BIOS+MBR传统启动计算机方式，而现在比较“先进”的方式是UEFI启动
最后bios使用命令jmp 0x7c00跳到我们代码，我们旅程就这样开始了
实现 coding 汇编大体上两种语法，intel和AT&amp;amp;T，这里选择AT&amp;amp;T，如果是用intel语法，可以去找nasm等汇编器编译
附上两个伪指令，表明是16位代码和程序开头在main
.globl main.code16然后设置段寄存器为零，异或清零是常用的手法。为什么要清零，因为此时cpu在实模式下(real mode)，物理内存寻址是采用 段：偏移，计算方式如下
物理地址 = 段 * 16 + 偏移
如果我们直接设零，那么偏移量直接等于物理地址
xorw %ax, %axmovw %ax, %dsmovw %ax, %esmovw %ax, %ss因为现代操作系统是分页管理内存，段管理内存已经不再使用，但有时候他会以某种方式出现我们眼前
比如：平时写C/C++程序遇到的Segmentation fault
如何在屏幕上输出字符串呢，答案是使用bios中断
bios中断没必要深究，当成api使用即可，使用方法就是在指定寄存器赋值，然后使用int指令和对应中断号
这里看0x10中断指令的用法
中断返回后，可以看到字符串按照我们的格式输出在屏幕上
编译 这里我们使用make来管理编译流程
gcc/ld/objcopy/dd等使用方法参考我的makefile
编译汇编源文件为.o文件 指定程序入口函数和地址，链接成elf文件 将elf文件中代码和数据提取成纯二进制文件 然后使用dd拼接512字节的MBR
生成全为零的512字节文件 开头刻录我们的二进制文件 最后两个字节刻录魔数 这里使用其他工具或python脚本也可以完成</description>
    </item>
    
    <item>
      <title>galgame游玩记录</title>
      <link>https://star-hengxing.github.io/p/galgame%E6%B8%B8%E7%8E%A9%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/galgame%E6%B8%B8%E7%8E%A9%E8%AE%B0%E5%BD%95/</guid>
      <description>部分游戏没有全通 有些gal没有吐槽 系列作品会合在一起 没有汉化 tag 的默认是生肉 内有剧透（这不是废话么） オモカゲ ～えっちなハプニング!? なんでもどんとこい!～ 译名：思影
会社：あかべぇそふとすりぃ
Tag：汉化 萌拔 幼驯染 后宫
空の青と白と／瞬きの夏 译名：天空的蓝与白/如梭夏日
会社：バリスタラボ
Tag：汉化 废萌
輪舞曲Duo -夜明けのフォルテシモ- ぷにゅぷりff 译名：天空的蓝与白/如梭夏日
会社：ティンクルベル
Tag：汉化 百合 扶她 拔作
神採りアルケミーマイスター 译名：神采炼金大师
会社：エウシュリー
Tag：汉化 SLG 后宫
放課後シンデレラ２ 译名：放学后的灰姑娘2
会社：HOOKSOFT
Tag：废萌
共通日常可以，个人线没对上胃口
終わる世界とバースデイ 译名：世界末日和生日
会社：コットンソフト
Tag：科幻 悬疑 妹系 泣系 猎奇
演出神作，尽管推完的那天并不是自己的生日，还是被感动到哭了
穢翼のユースティア 译名：秽翼的尤斯蒂娅
会社：オーガスト
Tag：汉化 奇幻
ISLAND 会社：Front Wing
Tag：汉化 科幻 悬疑
シロナガス島への帰還 译名：重返蓝鲸岛
会社：旅の道
Tag：汉化 恐怖 悬疑 馆系
ふゆから、くるる 译名：冬旅，方冥冥</description>
    </item>
    
    <item>
      <title>记录安装arch的过程</title>
      <link>https://star-hengxing.github.io/p/%E8%AE%B0%E5%BD%95%E5%AE%89%E8%A3%85arch%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E8%AE%B0%E5%BD%95%E5%AE%89%E8%A3%85arch%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>配置 虚拟机: Oracle VM VirtualBox 笔记本：UEFI启动 镜像: 官网 前提 了解UEFI还是BIOS启动，不同的启动方式对应不同的步骤 基本的linux命令行操作和知识 足够耐心 善用archwiki 安装 联网 wifi配置麻烦，强烈建议网线或者手机usb联网
ip link 然后ping查看联网是否成功
ping baidu.com 更新系统时间 timedatectl set-ntp true timedatectl status # 检查服务状态 硬盘分区 硬盘分区工具有很多，推荐小白使用cfdisk
查看硬盘用lsblk
在分区前，需了解swap(分区)，区别linux根分区和windows盘符的概念
如果是UEFI启动，需要分一个EFI区，而BIOS则不用
分区步骤大概就是：new-&amp;gt;分大小-&amp;gt;改类型-&amp;gt;保存-&amp;gt;格式化-&amp;gt;挂载
EFI分区和正常分区格式化工具不一样
根分区需要首先挂载
swap区看需求分(格式化和挂载是单独命令使用)
添加国内镜像加速 vim /etc/pacman.d/mirrorlist # 添加 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.zju.edu.cn/archlinux/$repo/os/$arch 安装基本包 pacstrap /mnt base linux linux-firmware 在此步骤可以考虑把常用软件装了(vim/networkmanager/sudo)
配置Fstab genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab cat /mnt/etc/fstab # 检查 change root 切换到自己系统
arch-chroot /mnt 设置时区 # Asia和Shanghai按需替换 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 设置Locale # 把需要用的注释取消 vim /etc/locale.</description>
    </item>
    
    <item>
      <title>光线与各种几何图形求交</title>
      <link>https://star-hengxing.github.io/p/%E5%85%89%E7%BA%BF%E4%B8%8E%E5%90%84%E7%A7%8D%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E6%B1%82%E4%BA%A4/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E5%85%89%E7%BA%BF%E4%B8%8E%E5%90%84%E7%A7%8D%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E6%B1%82%E4%BA%A4/</guid>
      <description>在一些基础的光线追踪教程中，光线求交通常发生在世界空间(world space)
但在离线渲染器中(比如PBRT)，光线求交发生在几何图形自己的局部空间(local/object/model space)
这是有好处的，比如说简化求交代码，相交表面的normal和uv也很容易计算
下面就记录一些几何求交的做法，自身经验有限，如有错误请指出
前提 这里采用的是y轴朝上的右手坐标系，-z轴指向屏幕里，x轴在右手 默认光线已经变换到对象的局部空间 使用几何体的变换矩阵和其逆矩阵，求交时将光线变换到对象空间
$$ Ray(t)=o+td (t &amp;gt; 0) $$
$$ Ray_{object}=M^{-1}Ray_{world} $$
矩形(Rectangle) 假设矩形高度为0，躺在xz平面上。长和宽控制矩形大小
忽略平行于平面的光线
if(is_zero(ray.direction.y)) return false; 使用高度计算相交点 $$ t=\frac{0 - o_{y}}{d_{y}} $$
const auto t = ray.inv_at&amp;lt;Axis::Y&amp;gt;(0); const auto [x, y, z] = ray.at(t); 在矩形范围内的点才算相交成功
if(std::abs(x) &amp;gt; length || std::abs(z) &amp;gt; width) return false; 球(Sphere) 假设球心在原点，半径控制球的大小
三维空间中球的一般方程 $$ x^{2}+y^{2}+z^{2}=r^{2} $$
将光线代入方程 $$ (o+td)^{2}=r^{2} $$
整理可得关于t的一元二次方程 $$ d^{2}t^{2}+2odt+o^{2}-r^{2}=0\ \begin{align*} &amp;amp; a=d^{2}\ &amp;amp; b=2od\ &amp;amp; c=o^{2}-r^{2} \end{align*} $$</description>
    </item>
    
    <item>
      <title>离线渲染-光线追踪框架学习资料</title>
      <link>https://star-hengxing.github.io/p/%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://star-hengxing.github.io/p/%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</guid>
      <description>GAMES101:现代计算机图形学入门 网课，可在b站上观看
assignment 5-7 是光线追踪的作业
如果对光栅化，几何，动画与模拟，不感兴趣，可以只看Lecture 13-20（个人建议：把整套课看完也是不错的）
Taichi课程 课程主页
网课，其中6-7讲涉及光线追踪
Peter Shirley写的光线追踪三部曲 Ray Tracing in One Weekend Ray Tracing: The Next Week Ray Tracing: The Rest of Your Life 书中配套代码，在网上能搜到这三本的笔记和翻译版本
我认为这是光线追踪入门的最好教程
Daily Pathtracer Aras Pranckevičius大佬写的教程
介绍 博客
Nori an educational ray tracer
主页
5个assignment
PBRT Physically Based Rendering:From Theory To Implementation
这本书是学习离线渲染系统书（离线渲染圣经），配套代码在github上
网上在线阅读
此为光线追踪进阶书籍
书 Ray Tracing Gems Advanced global illumination Fundamentals of Computer Graphics Real-Time Rendering 全局光照技术 杂类 github上收集的图形学资料 milo yip的用JavaScript玩转计算机图形学-光线追踪入门 scratchapixel，图形学网站，对细节讲解很详细，配套代码 99行代码写出路径追踪-smallpt real-time-rendering，网站内附带很多图形学资料 mitsuba,一个开源渲染器 stackexchange的计算机图形学板块 </description>
    </item>
    
  </channel>
</rss>
